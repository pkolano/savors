=for license_for_this_file_only
Artistic License 2.0

Copyright (c) 2000-2006, The Perl Foundation.

Everyone is permitted to copy and distribute verbatim copies of this license
document, but changing it is not allowed.

Preamble

This license establishes the terms under which a given free software Package
may be copied, modified, distributed, and/or redistributed. The intent is that
the Copyright Holder maintains some artistic control over the development of
that Package while still keeping the Package available as open source and free
software.

You are always permitted to make arrangements wholly outside of this license
directly with the Copyright Holder of a given Package. If the terms of this
license do not permit the full use that you propose to make of the Package, you
should contact the Copyright Holder and seek a different licensing arrangement.

Definitions

"Copyright Holder" means the individual(s) or organization(s) named in the
copyright notice for the entire Package.

"Contributor" means any party that has contributed code or other material to
the Package, in accordance with the Copyright Holder's procedures.

"You" and "your" means any person who would like to copy, distribute, or modify
the Package.

"Package" means the collection of files distributed by the Copyright Holder,
and derivatives of that collection and/or of those files. A given Package may
consist of either the Standard Version, or a Modified Version.

"Distribute" means providing a copy of the Package or making it accessible to
anyone else, or in the case of a company or organization, to others outside of
your company or organization.

"Distributor Fee" means any fee that you charge for Distributing this Package
or providing support for this Package to another party. It does not mean
licensing fees.

"Standard Version" refers to the Package if it has not been modified, or has
been modified only in ways explicitly requested by the Copyright Holder.

"Modified Version" means the Package, if it has been changed, and such changes
were not explicitly requested by the Copyright Holder.

"Original License" means this Artistic License as Distributed with the Standard
Version of the Package, in its current version or as it may be modified by The
Perl Foundation in the future.

"Source" form means the source code, documentation source, and configuration
files for the Package.

"Compiled" form means the compiled bytecode, object code, binary, or any other
form resulting from mechanical transformation or translation of the Source
form.

Permission for Use and Modification Without Distribution

(1) You are permitted to use the Standard Version and create and use Modified
Versions for any purpose without restriction, provided that you do not
Distribute the Modified Version.

Permissions for Redistribution of the Standard Version

(2) You may Distribute verbatim copies of the Source form of the Standard
Version of this Package in any medium without restriction, either gratis or for
a Distributor Fee, provided that you duplicate all of the original copyright
notices and associated disclaimers. At your discretion, such verbatim copies
may or may not include a Compiled form of the Package.

(3) You may apply any bug fixes, portability changes, and other modifications
made available from the Copyright Holder. The resulting Package will still be
considered the Standard Version, and as such will be subject to the Original
License.

Distribution of Modified Versions of the Package as Source

(4) You may Distribute your Modified Version as Source (either gratis or for a
Distributor Fee, and with or without a Compiled form of the Modified Version)
provided that you clearly document how it differs from the Standard Version,
including, but not limited to, documenting any non-standard features,
executables, or modules, and provided that you do at least ONE of the
following:

(a) make the Modified Version available to the Copyright Holder of the Standard
Version, under the Original License, so that the Copyright Holder may include
your modifications in the Standard Version.
(b) ensure that installation of your Modified Version does not prevent the user
installing or running the Standard Version. In addition, the Modified Version
must bear a name that is different from the name of the Standard Version.
(c) allow anyone who receives a copy of the Modified Version to make the Source
form of the Modified Version available to others under
(i) the Original License or
(ii) a license that permits the licensee to freely copy, modify and
redistribute the Modified Version using the same licensing terms that apply to
the copy that the licensee received, and requires that the Source form of the
Modified Version, and of any works derived from it, be made freely available in
that license fees are prohibited but Distributor Fees are allowed.

Distribution of Compiled Forms of the Standard Version or Modified Versions
without the Source

(5) You may Distribute Compiled forms of the Standard Version without the
Source, provided that you include complete instructions on how to get the
Source of the Standard Version. Such instructions must be valid at the time of
your distribution. If these instructions, at any time while you are carrying
out such distribution, become invalid, you must provide new instructions on
demand or cease further distribution. If you provide valid instructions or
cease distribution within thirty days after you become aware that the
instructions are invalid, then you do not forfeit any of your rights under this
license.

(6) You may Distribute a Modified Version in Compiled form without the Source,
provided that you comply with Section 4 with respect to the Source of the
Modified Version.

Aggregating or Linking the Package

(7) You may aggregate the Package (either the Standard Version or Modified
Version) with other packages and Distribute the resulting aggregation provided
that you do not charge a licensing fee for the Package. Distributor Fees are
permitted, and licensing fees for other components in the aggregation are
permitted. The terms of this license apply to the use and Distribution of the
Standard or Modified Versions as included in the aggregation.

(8) You are permitted to link Modified and Standard Versions with other works,
to embed the Package in a larger work of your own, or to build stand-alone
binary or bytecode versions of applications that include the Package, and
Distribute the result without restriction, provided the result does not expose
a direct interface to the Package.

Items That are Not Considered Part of a Modified Version

(9) Works (including, but not limited to, modules and scripts) that merely
extend or make use of the Package, do not, by themselves, cause the Package to
be a Modified Version. In addition, such works are not considered parts of the
Package itself, and are not subject to the terms of this license.

General Provisions

(10) Any use, modification, and distribution of the Standard or Modified
Versions is governed by this Artistic License. By using, modifying or
distributing the Package, you accept this license. Do not use, modify, or
distribute the Package, if you do not accept this license.

(11) If your Modified Version has been derived from a Modified Version made by
someone other than you, you are nevertheless required to ensure that your
Modified Version complies with the requirements of this license.

(12) This license does not grant you the right to use any trademark, service
mark, tradename, or logo of the Copyright Holder.

(13) This license includes the non-exclusive, worldwide, free-of-charge patent
license to make, have made, use, offer to sell, sell, import and otherwise
transfer the Package with respect to any patent claims licensable by the
Copyright Holder that are necessarily infringed by the Package. If you
institute patent litigation (including a cross-claim or counterclaim) against
any party alleging that the Package constitutes direct or contributory patent
infringement, then this Artistic License to you shall terminate on the date
that such litigation is filed.

(14) Disclaimer of Warranty: THE PACKAGE IS PROVIDED BY THE COPYRIGHT HOLDER
AND CONTRIBUTORS "AS IS' AND WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES. THE
IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR
NON-INFRINGEMENT ARE DISCLAIMED TO THE EXTENT PERMITTED BY YOUR LOCAL LAW.
UNLESS REQUIRED BY LAW, NO COPYRIGHT HOLDER OR CONTRIBUTOR WILL BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING IN ANY WAY
OUT OF THE USE OF THE PACKAGE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
DAMAGE.
=cut

1;

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"Chart/Bars.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CHART_BARS';
  package Chart::Bars;use Chart::Base '2.4.10';use GD;use Carp;use strict;@Chart::Bars::ISA=qw(Chart::Base);$Chart::Bars::VERSION='2.4.10';sub _draw_data {my$self=shift;my$data=$self->{'dataref'};my$misccolor=$self->_color_role_to_index('misc');my ($x1,$x2,$x3,$y1,$y2,$y3);my ($width,$height,$delta1,$delta2,$map,$mod,$cut,$pink);my ($i,$j,$color);my$temp=0;my$font=$self->{'legend_font'};my$fontW=$self->{'legend_font'}->width;my$fontH=$self->{'legend_font'}->height;my$textcolor=$self->_color_role_to_index('text');if ($self->true($self->{'imagemap'})){$self->{'imagemap_data'}=[]}my$max_label_len=0;for$i (1 .. $self->{'num_datasets'}){for$j (0 .. $self->{'num_datapoints'}){if (defined($data->[$i][$j])&& $data->[$i][$j]=~ /^[\-\+]{0,1}\s*[\d\.eE\-\+]+/){if (defined$self->{'label_values'}&& $self->{'label_values'}=~ /^value$/i){my$label=sprintf("%.2f",$data->[$i][$j]);my$label_length=length($label);$max_label_len=$label_length if ($max_label_len < $label_length)}}}}$max_label_len *= $fontH;$width=$self->{'curr_x_max'}- $self->{'curr_x_min'};$height=$self->{'curr_y_max'}- $self->{'curr_y_min'};$delta1=($self->{'num_datapoints'}> 0)? $width / ($self->{'num_datapoints'}* 1): $width;$map=(($self->{'max_val'}- $self->{'min_val'})> 0)? $height / ($self->{'max_val'}- $self->{'min_val'}): $height;if ($self->true($self->{'spaced_bars'})){$delta2=(($self->{'num_datasets'}+ 2)> 0)? $delta1 / ($self->{'num_datasets'}+ 2): $delta1}else {$delta2=($self->{'num_datasets'}> 0)? $delta1 / $self->{'num_datasets'}: $delta1}$x1=$self->{'curr_x_min'};if ($self->{'min_val'}>= 0){$y1=$self->{'curr_y_max'};$mod=$self->{'min_val'}}elsif ($self->{'max_val'}<= 0){$y1=$self->{'curr_y_min'};$mod=$self->{'max_val'}}else {$y1=$self->{'curr_y_min'}+ ($map * $self->{'max_val'});$mod=0;$self->{'gd_obj'}->line($self->{'curr_x_min'},$y1,$self->{'curr_x_max'},$y1,$misccolor)}for$i (1 .. $self->{'num_datasets'}){$color=$self->_color_role_to_index('dataset' .($i - 1));for$j (0 .. $self->{'num_datapoints'}){if (defined($data->[$i][$j])&& $data->[$i][$j]=~ /^[\-\+]{0,1}\s*[\d\.eE\-\+]+/){if ($self->true($self->{'spaced_bars'})){$x2=($x1 + ($j * $delta1)+ ($i * $delta2))}else {$x2=$x1 + ($j * $delta1)+ (($i - 1)* $delta2)}$y2=$y1;$x3=$x2 + $delta2;$y3=$y1 - (($data->[$i][$j]- $mod)* $map);if ($data->[$i][$j]> $self->{'max_val'}){$y3=$y1 - (($self->{'max_val'}- $mod)* $map);$cut=1}elsif ($data->[$i][$j]< $self->{'min_val'}){$y3=$y1 - (($self->{'min_val'}- $mod)* $map);$cut=1}else {$cut=0}if ($data->[$i][$j]> 0){$self->{'gd_obj'}->filledRectangle($x2,$y3,$x3,$y2,$color);if ($self->true($self->{'imagemap'})){$self->{'imagemap_data'}->[$i][$j]=[$x2,$y3,$x3,$y2 ]}if (defined$self->{'label_values'}&& $self->{'label_values'}=~ /^value$/i){my$labelX=$x2;my$labelY=$y3 + $fontH;if ($labelY < 0){$labelY=$y3}my$label=sprintf("%.2f",$data->[$i][$j]);$self->{'gd_obj'}->stringUp($font,$labelX + $fontW * 0.5,$labelY,$label,$textcolor)}}else {$self->{'gd_obj'}->filledRectangle($x2,$y2,$x3,$y3,$color);if ($self->true($self->{'imagemap'})){$self->{'imagemap_data'}->[$i][$j]=[$x2,$y2,$x3,$y3 ]}}unless ($cut){$self->{'gd_obj'}->rectangle($x2,$y3,$x3,$y2,$misccolor)}else {$pink=$self->{'gd_obj'}->colorAllocate(255,0,255);$self->{'gd_obj'}->rectangle($x2,$y3,$x3,$y2,$pink)}}else {if ($self->true($self->{'imagemap'})){$self->{'imagemap_data'}->[$i][$j]=[undef(),undef(),undef(),undef()]}}}}$self->{'gd_obj'}->rectangle($self->{'curr_x_min'},$self->{'curr_y_min'},$self->{'curr_x_max'},$self->{'curr_y_max'},$misccolor);return}1;
CHART_BARS

$fatpacked{"Chart/Base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CHART_BASE';
  package Chart::Base;use GD;use Carp;use FileHandle;use Chart::Constants;use GD::Image;$Chart::Base::VERSION='2.4.10';use vars qw(%named_colors);use strict;sub new {my$proto=shift;my$class=ref($proto)|| $proto;my$self={};bless$self,$class;$self->_init(@_);return$self}sub set {my$self=shift;my%opts=@_;unless ($#_ % 2){carp "Whoops, some option to be set didn't have a value.\n","You might want to look at that.\n"}for (keys%opts){$self->{$_}=$opts{$_};$self->{saveopts}->{$_}=$opts{$_};if ($_ =~ /^colors$/){my%hash=%{$opts{$_}};for my$key (sort keys%hash){if ($key =~ /^grid_lines$/){if (ref($hash{'grid_lines'})eq 'ARRAY'){my@aLocal=($hash{'grid_lines'}[0],$hash{'grid_lines'}[1],$hash{'grid_lines'}[2]);$self->{'colors'}{'y_grid_lines'}=[@aLocal];$self->{'colors'}{'x_grid_lines'}=[@aLocal];$self->{'colors'}{'y2_grid_lines'}=[@aLocal]}elsif (ref(\$hash{'grid_lines'})eq 'SCALAR'){my$sLocal=$hash{'grid_lines'};$self->{'colors'}{'y_grid_lines'}=$sLocal;$self->{'colors'}{'x_grid_lines'}=$sLocal;$self->{'colors'}{'y2_grid_lines'}=$sLocal}else {carp "colors{'grid_lines'} is not SCALAR and not ARRAY\n"}}}}}return 1}sub getopts {my$self=shift;my%opts=();for (keys %{$self->{saveopts}}){$opts{$_}=$self->{saveopts}}return%opts}sub add_pt {my$self=shift;my@data=();if ((ref $_[0])=~ /^ARRAY/){my$rdata=shift;@data=@$rdata if @$rdata}elsif ((ref \$_[0])=~ /^SCALAR/){if (defined $_[0]){@data=@_}}else {croak "Not an array or reference to array"}if ($self->{'dataref'}&& ($#{$self->{'dataref'}}!=$#data)){carp "New point to be added has an incorrect number of data sets";return 0}for (0 .. $#data){push @{$self->{'dataref'}->[$_]},$data[$_]}return 1}sub add_dataset {my$self=shift;my@data=();if ((ref $_[0])=~ /^ARRAY/){my$rdata=shift;@data=@$rdata if @$rdata}elsif ((ref \$_[0])=~ /^SCALAR/){if (defined $_[0]){@data=@_}}else {croak "Not an array or reference to array";return}if ($self->{'dataref'}&& ($#{$self->{'dataref'}->[0]}!=$#data)){carp "New data set to be added has an incorrect number of points"}push @{$self->{'dataref'}},[@data];return 1}sub add_datafile {my$self=shift;my$filename=shift;my$format=shift;my ($File,@array);if ((ref \$filename)eq 'SCALAR'){open($File,$filename)or croak "Can't open the datafile: $filename.\n"}elsif ((ref \$filename)=~ /^(?:REF|GLOB)$/){$File=$filename}else {carp "I'm not sure what kind of datafile you gave me,\n","but it wasn't a filename or a filehandle.\n"}while (<$File>){@array=split;if ($#array > -1){if ($format =~ m/^pt$/i){$self->add_pt(@array)}elsif ($format =~ m/^set$/i){$self->add_dataset(@array)}else {carp "Tell me what kind of file you gave me: 'pt' or 'set'\n"}}}close($File)}sub clear_data {my$self=shift;$self->{'dataref'}=undef;return 1}sub get_data {my$self=shift;my$ref=[];my ($i,$j);for$i (0 .. $#{$self->{'dataref'}}){@{$ref->[$i]}=@{$self->{'dataref'}->[$i]}}return$ref}sub png {my$self=shift;my$file=shift;my$dataref=shift;my$fh;if ((ref \$file)eq 'SCALAR'){if (-f $file){my$number_deleted_files=unlink$file;if ($number_deleted_files!=1){croak "Error: File \"$file\" did already exist, but it failed to delete it"}}$fh=FileHandle->new(">$file");if (!defined$fh){croak "Error: File \"$file\" could not be created!\n"}}elsif ((ref \$file)=~ /^(?:REF|GLOB)$/){$fh=$file}else {croak "I'm not sure what you gave me to write this png to,\n","but it wasn't a filename or a filehandle.\n"}$self->_set_colors();$self->_copy_data($dataref);$self->_check_data();$self->_draw();binmode$fh;print$fh $self->{'gd_obj'}->png();return 1}sub cgi_png {my$self=shift;my$dataref=shift;$self->_set_colors();$self->_copy_data($dataref);$self->_check_data();$self->_draw();if ($self->true($self->{no_cache})){print "Content-type: image/png\015\012Pragma: no-cache\015\012\015\012"}else {print "Content-type: image/png\015\012\015\012"}binmode STDOUT;print STDOUT$self->{'gd_obj'}->png();return 1}sub scalar_png {my$self=shift;my$dataref=shift;$self->_set_colors();$self->_copy_data($dataref);$self->_check_data();$self->_draw();return$self->{'gd_obj'}->png()}sub jpeg {my$self=shift;my$file=shift;my$dataref=shift;my$fh;if ((ref \$file)eq 'SCALAR'){if (-f $file){my$number_deleted_files=unlink$file;if ($number_deleted_files!=1){croak "Error: File \"$file\" did already exist, but it fails to delete it"}}$fh=FileHandle->new(">$file");if (!defined$fh){croak "Error: File \"$file\" could not be created!\n"}}elsif ((ref \$file)=~ /^(?:REF|GLOB)$/){$fh=$file}else {croak "I'm not sure what you gave me to write this jpeg to,\n","but it wasn't a filename or a filehandle.\n"}$self->_set_colors();$self->_copy_data($dataref);$self->_check_data;$self->_draw();binmode$fh;print$fh $self->{'gd_obj'}->jpeg([100]);return 1}sub cgi_jpeg {my$self=shift;my$dataref=shift;$self->_set_colors();$self->_copy_data($dataref);$self->_check_data();$self->_draw();if ($self->true($self->{no_cache})){print "Content-type: image/jpeg\015\012Pragma: no-cache\015\012\015\012"}else {print "Content-type: image/jpeg\015\012\015\012"}binmode STDOUT;print STDOUT$self->{'gd_obj'}->jpeg([100]);return 1}sub scalar_jpeg {my$self=shift;my$dataref=shift;$self->_set_colors();$self->_copy_data($dataref);$self->_check_data();$self->_draw();$self->{'gd_obj'}->jpeg([100])}sub make_gd {my$self=shift;my$dataref=shift;$self->_set_colors();$self->_copy_data($dataref);$self->_check_data();$self->_draw();return$self->{'gd_obj'}}sub imagemap_dump {my$self=shift;my$ref=[];my ($i,$j);unless (($self->true($self->{'imagemap'}))&& $self->{'imagemap_data'}){croak "You need to set the imagemap option to true, and then call the png method, before you can get the imagemap data"}for$i (0 .. $#{$self->{'imagemap_data'}}){for$j (0 .. $#{$self->{'imagemap_data'}->[$i]}){$ref->[$i][$j]=[@{$self->{'imagemap_data'}->[$i][$j]}]}}return$ref}sub minimum {my$self=shift;my@array=@_;return undef if!@array;my$min=$array[0];for (my$iIndex=0 ;$iIndex < scalar@array ;$iIndex++ ){$min=$array[$iIndex]if ($min > $array[$iIndex])}$min}sub maximum {my$self=shift;my@array=@_;return undef if!@array;my$max=$array[0];for (my$iIndex=0 ;$iIndex < scalar@array ;$iIndex++ ){$max=$array[$iIndex]if ($max < $array[$iIndex])}$max}sub arccos {my$self=shift;my$a=shift;return (atan2(sqrt(1 - $a * $a),$a))}sub arcsin {my$self=shift;my$a=shift;return (atan2($a,sqrt(1 - $a * $a)))}sub true {my$pkg=shift;my$arg=shift;if (!defined($arg)){return 0}if ($arg eq 'true' || $arg eq 'TRUE' || $arg eq 't' || $arg eq 'T' || $arg eq '1'){return 1}return 0}sub false {my$pkg=shift;my$arg=shift;if (!defined($arg)){return 1}if ($arg eq 'false' || $arg eq 'FALSE' || $arg eq 'f' || $arg eq 'F' || $arg eq '0' || $arg eq 'none'){return 1}return 0}sub modulo {my$pkg=shift;my$a=shift;my$b=shift;my$erg=0.0;if (!defined($a)||!defined($b)|| $b==0){die "Modulo needs valid parameters!"}my$div=$a / $b;$erg=$a - int($div)* $b;return$erg}sub _init {my$self=shift;my$x=shift || 400;my$y=shift || 300;$self->{'gd_obj'}=GD::Image->new($x,$y);$self->{'curr_y_min'}=0;$self->{'curr_y_max'}=$y;$self->{'curr_x_min'}=0;$self->{'curr_x_max'}=$x;$self->{'png_border'}=10;$self->{'text_space'}=2;$self->{'graph_border'}=10;$self->{'legend_space'}=4;$self->{'title_font'}=gdLargeFont,$self->{'sub_title_font'}=gdLargeFont,$self->{'legend_font'}=gdSmallFont,$self->{'label_font'}=gdMediumBoldFont,$self->{'tick_label_font'}=gdSmallFont;$self->{'legend'}='right';$self->{'legend_labels'}=[];$self->{'legend_example_size'}=20;$self->{'y_ticks'}=6,$self->{'min_y_ticks'}=6,$self->{'max_y_ticks'}=100,$self->{'x_number_ticks'}=1,$self->{'min_x_ticks'}=6,$self->{'max_x_ticks'}=100;$self->{'tick_len'}=4;$self->{'y_tick_labels'}=undef;$self->{'patterns'}=undef;$self->{'brush_size'}=6;$self->{'pt_size'}=18;$self->{'spaced_bars'}='true';$self->{'grey_background'}='true';$self->{'transparent'}='false';$self->{'x_ticks'}='normal';$self->{'component'}='false';$self->{'same_y_axes'}='false';$self->{'legend_example_height'}='false';$self->{'integer_ticks_only'}='false';$self->{'include_zero'}='false';$self->{'imagemap'}='false';$self->{grid_lines}='false',$self->{x_grid_lines}='false',$self->{y_grid_lines}='false',$self->{y2_grid_lines}='false';$self->{no_cache}='false';$self->{skip_y_ticks}=1;$self->{skip_int_ticks}=1;$self->{precision}=3;$self->{legend_label_values}='value';$self->{label_values}='percent';$self->{y_axes}='left';$self->{temp_x_min}=0;$self->{temp_x_max}=0;$self->{temp_y_min}=0;$self->{temp_y_max}=0;$self->{sum}=0;$self->{'sort'}='false';$self->{'interval'}=undef;$self->{'start'}=undef;$self->{'interval_ticks'}=6;$self->{'scale'}=1;$self->{'xy_plot'}='false';$self->{'x_min_val'}=1;$self->{'x_max_val'}=1;$self->{'same_error'}='false';$self->{'min_circles'}=4,$self->{'max_circles'}=100;$self->{'point'}='true',$self->{'line'}='false',$self->{'arrow'}='false';$self->{'angle_interval'}=30;$self->{'pairs'}='false';$self->{'polar'}='false';$self->{'legend_lines'}='false';$self->{'ring'}=1;$self->{'stepline'}='false';$self->{'stepline_mode'}='end';$self->{f_x_tick}=\&_default_f_tick,$self->{f_y_tick}=\&_default_f_tick,$self->{f_z_tick}=\&_default_f_tick;my$d=0;$self->{'colors_default_spec'}={background=>'white',misc=>'black',text=>'black',y_label=>'black',y_label2=>'black',grid_lines=>'black',grey_background=>'grey',(map {'dataset' .$d++=>$_}qw (red green blue purple peach orange mauve olive pink light_purple light_blue plum yellow turquoise light_green brown HotPink PaleGreen1 DarkBlue BlueViolet orange2 chocolate1 LightGreen pink light_purple light_blue plum yellow turquoise light_green brown pink PaleGreen2 MediumPurple PeachPuff1 orange3 chocolate2 olive pink light_purple light_blue plum yellow turquoise light_green brown DarkOrange PaleGreen3 SlateBlue BlueViolet PeachPuff2 orange4 chocolate3 LightGreen pink light_purple light_blue plum yellow turquoise light_green brown snow1 honeydew3 SkyBlue1 cyan3 DarkOliveGreen1 IndianRed3 orange1 LightPink3 MediumPurple1 snow3 LavenderBlush1 SkyBlue3 DarkSlateGray1 DarkOliveGreen3 sienna1 orange3 PaleVioletRed1 MediumPurple3 seashell1 LavenderBlush3 LightSkyBlue1 DarkSlateGray3 khaki1 sienna3 DarkOrange1 PaleVioletRed3 thistle1 seashell3 MistyRose1 LightSkyBlue3 aquamarine1 khaki3 burlywood1 DarkOrange3 maroon1 thistle3 AntiqueWhite1 MistyRose3 SlateGray1 aquamarine3 LightGoldenrod1 burlywood3 coral1 maroon3 AntiqueWhite3 azure1 SlateGray3 DarkSeaGreen1 LightGoldenrod3 wheat1 coral3 VioletRed1 bisque1 azure3 LightSteelBlue1 DarkSeaGreen3 LightYellow1 wheat3 tomato1 VioletRed3 bisque3 SlateBlue1 LightSteelBlue3 SeaGreen1 LightYellow3 tan1 tomato3 magenta1 PeachPuff1 SlateBlue3 LightBlue1 SeaGreen3 yellow1 tan3 OrangeRed1 magenta3 PeachPuff3 RoyalBlue1 LightBlue3 PaleGreen1 yellow3 chocolate1 OrangeRed3 orchid1 NavajoWhite1 RoyalBlue3 LightCyan1 PaleGreen3 gold1 chocolate3 red1 orchid3 NavajoWhite3 blue1 LightCyan3 SpringGreen1 gold3 firebrick1 red3 plum1 LemonChiffon1 blue3 PaleTurquoise1 SpringGreen3 goldenrod1 firebrick3 DeepPink1 plum3 LemonChiffon3 DodgerBlue1 PaleTurquoise3 green1 goldenrod3 brown1 DeepPink3 MediumOrchid1 cornsilk1 DodgerBlue3 CadetBlue1 green3 DarkGoldenrod1 brown3 HotPink1 MediumOrchid3 cornsilk3 SteelBlue1 CadetBlue3 chartreuse1 DarkGoldenrod3 salmon1 HotPink3 DarkOrchid1 ivory1 SteelBlue3 turquoise1 chartreuse3 RosyBrown1 salmon3 pink1 DarkOrchid3 ivory3 DeepSkyBlue1 turquoise3 OliveDrab1 RosyBrown3 LightSalmon1 pink3 purple1 honeydew1 DeepSkyBlue3 cyan1 OliveDrab3 IndianRed1 LightSalmon3 LightPink1 purple3 honeydew2 DeepSkyBlue4 cyan2 OliveDrab4 IndianRed2 LightSalmon4 LightPink2 purple4 snow2 honeydew4 SkyBlue2 cyan4 DarkOliveGreen2 IndianRed4 orange2 LightPink4 MediumPurple2 snow4 LavenderBlush2 SkyBlue4 DarkSlateGray2 DarkOliveGreen4 sienna2 orange4 PaleVioletRed2 MediumPurple4 seashell2 LavenderBlush4 LightSkyBlue2 DarkSlateGray4 khaki2 sienna4 DarkOrange2 PaleVioletRed4 thistle2 seashell4 MistyRose2 LightSkyBlue4 aquamarine2 khaki4 burlywood2 DarkOrange4 maroon2 thistle4 AntiqueWhite2 MistyRose4 SlateGray2 aquamarine4 LightGoldenrod2 burlywood4 coral2 maroon4 AntiqueWhite4 azure2 SlateGray4 DarkSeaGreen2 LightGoldenrod4 wheat2 coral4 VioletRed2 bisque2 azure4 LightSteelBlue2 DarkSeaGreen4 LightYellow2 wheat4 tomato2 VioletRed4 bisque4 SlateBlue2 LightSteelBlue4 SeaGreen2 LightYellow4 tan2 tomato4 magenta2 PeachPuff2 SlateBlue4 LightBlue2 SeaGreen4 yellow2 tan4 OrangeRed2 magenta4 PeachPuff4 RoyalBlue2 LightBlue4 PaleGreen2 yellow4 chocolate2 OrangeRed4 orchid2 NavajoWhite2 RoyalBlue4 LightCyan2 PaleGreen4 gold2 chocolate4 red2 orchid4 NavajoWhite4 blue2 LightCyan4 SpringGreen2 gold4 firebrick2 red4 plum2 LemonChiffon2 blue4 PaleTurquoise2 SpringGreen4 goldenrod2 firebrick4 DeepPink2 plum4 LemonChiffon4 DodgerBlue2 PaleTurquoise4 green2 goldenrod4 brown2 DeepPink4 MediumOrchid2 cornsilk2 DodgerBlue4 CadetBlue2 green4 DarkGoldenrod2 brown4 HotPink2 MediumOrchid4 cornsilk4 SteelBlue2 CadetBlue4 chartreuse2 DarkGoldenrod4 salmon2 HotPink4 DarkOrchid2 ivory2 SteelBlue4 turquoise2 chartreuse4 RosyBrown2 salmon4 pink2 DarkOrchid4 ivory4 DeepSkyBlue2 turquoise4 OliveDrab2 RosyBrown4 LightSalmon2 pink4 purple2)),};$self->{'colors_default_role'}={'x_grid_lines'=>'grid_lines','y_grid_lines'=>'grid_lines','y2_grid_lines'=>'grid_lines',};$self->{'brushStyle'}='FilledCircle';return 1}sub _copy_data {my$self=shift;my$extern_ref=shift;my ($ref,$i);if ($self->{'dataref'}){return 1}else {$ref=[];for$i (0 .. $#{$extern_ref}){@{$ref->[$i]}=@{$extern_ref->[$i]}}$self->{'dataref'}=$ref;return 1}}sub _check_data {my$self=shift;my$length=0;unless (scalar(@{$self->{'dataref'}})>= 2){croak "Call me again when you have some data to chart"}if ($self->{'y_ticks'}<= 1){$self->{'y_ticks'}=2;carp "The number of y_ticks displayed must be at least 2"}$self->{'num_datasets'}=$#{$self->{'dataref'}};$self->{'num_datapoints'}=0;for (0 .. $self->{'num_datasets'}){if (scalar(@{$self->{'dataref'}[$_]})> $self->{'num_datapoints'}){$self->{'num_datapoints'}=scalar(@{$self->{'dataref'}[$_]})}}$self->_find_y_scale();$length=0;for (@{$self->{'dataref'}->[0]}){next if!defined($_);if (length($self->{f_x_tick}->($_))> $length){$length=length($self->{f_x_tick}->($_))}}if ($length <= 0){$length=1}$self->{'x_tick_label_length'}=$length;if ($self->true($self->{'xy_plot'})&& ($self->isa('Chart::Lines')|| $self->isa('Chart::Points')|| $self->isa('Chart::LinesPoints')|| $self->isa('Chart::Split')|| $self->isa('Chart::ErrorBars'))){$self->_find_x_scale}return 1}sub _draw {my$self=shift;$self->{'curr_x_max'}-= $self->{'png_border'};$self->{'curr_x_min'}+= $self->{'png_border'};$self->{'curr_y_max'}-= $self->{'png_border'};$self->{'curr_y_min'}+= $self->{'png_border'};$self->_draw_title()if$self->{'title'};$self->_draw_sub_title()if$self->{'sub_title'};$self->_sort_data()if ($self->true($self->{'sort'}));$self->_plot();return 1}our%named_colors=('white'=>[255,255,255 ],'black'=>[0,0,0 ],'red'=>[200,0,0 ],'green'=>[0,175,0 ],'blue'=>[0,0,200 ],'orange'=>[250,125,0 ],'orange2'=>[238,154,0 ],'orange3'=>[205,133,0 ],'orange4'=>[139,90,0 ],'yellow'=>[225,225,0 ],'purple'=>[200,0,200 ],'light_blue'=>[0,125,250 ],'light_green'=>[125,250,0 ],'light_purple'=>[145,0,250 ],'pink'=>[250,0,125 ],'peach'=>[250,125,125 ],'olive'=>[125,125,0 ],'plum'=>[125,0,125 ],'turquoise'=>[0,125,125 ],'mauve'=>[200,125,125 ],'brown'=>[160,80,0 ],'grey'=>[225,225,225 ],'HotPink'=>[255,105,180 ],'PaleGreen1'=>[154,255,154 ],'PaleGreen2'=>[144,238,144 ],'PaleGreen3'=>[124,205,124 ],'PaleGreen4'=>[84,138,84 ],'DarkBlue'=>[0,0,139 ],'BlueViolet'=>[138,43,226 ],'PeachPuff'=>[255,218,185 ],'PeachPuff1'=>[255,218,185 ],'PeachPuff2'=>[238,203,173 ],'PeachPuff3'=>[205,175,149 ],'PeachPuff4'=>[139,119,101 ],'chocolate1'=>[255,127,36 ],'chocolate2'=>[238,118,33 ],'chocolate3'=>[205,102,29 ],'chocolate4'=>[139,69,19 ],'LightGreen'=>[144,238,144 ],'lavender'=>[230,230,250 ],'MediumPurple'=>[147,112,219 ],'DarkOrange'=>[255,127,0 ],'DarkOrange2'=>[238,118,0 ],'DarkOrange3'=>[205,102,0 ],'DarkOrange4'=>[139,69,0 ],'SlateBlue'=>[106,90,205 ],'BlueViolet'=>[138,43,226 ],'RoyalBlue'=>[65,105,225 ],'AntiqueWhite'=>[250,235,215 ],'AntiqueWhite1'=>[255,239,219 ],'AntiqueWhite2'=>[238,223,204 ],'AntiqueWhite3'=>[205,192,176 ],'AntiqueWhite4'=>[139,131,120 ],'CadetBlue'=>[95,158,160 ],'CadetBlue1'=>[152,245,255 ],'CadetBlue2'=>[142,229,238 ],'CadetBlue3'=>[122,197,205 ],'CadetBlue4'=>[83,134,139 ],'DarkGoldenrod'=>[184,134,11 ],'DarkGoldenrod1'=>[255,185,15 ],'DarkGoldenrod2'=>[238,173,14 ],'DarkGoldenrod3'=>[205,149,12 ],'DarkGoldenrod4'=>[139,101,8 ],'DarkOliveGreen'=>[85,107,47 ],'DarkOliveGreen1'=>[202,255,112 ],'DarkOliveGreen2'=>[188,238,104 ],'DarkOliveGreen3'=>[162,205,90 ],'DarkOliveGreen4'=>[110,139,61 ],'DarkOrange1'=>[255,127,0 ],'DarkOrchid'=>[153,50,204 ],'DarkOrchid1'=>[191,62,255 ],'DarkOrchid2'=>[178,58,238 ],'DarkOrchid3'=>[154,50,205 ],'DarkOrchid4'=>[104,34,139 ],'DarkSeaGreen'=>[143,188,143 ],'DarkSeaGreen1'=>[193,255,193 ],'DarkSeaGreen2'=>[180,238,180 ],'DarkSeaGreen3'=>[155,205,155 ],'DarkSeaGreen4'=>[105,139,105 ],'DarkSlateGray'=>[47,79,79 ],'DarkSlateGray1'=>[151,255,255 ],'DarkSlateGray2'=>[141,238,238 ],'DarkSlateGray3'=>[121,205,205 ],'DarkSlateGray4'=>[82,139,139 ],'DeepPink'=>[255,20,147 ],'DeepPink1'=>[255,20,147 ],'DeepPink2'=>[238,18,137 ],'DeepPink3'=>[205,16,118 ],'DeepPink4'=>[139,10,80 ],'DeepSkyBlue'=>[0,191,255 ],'DeepSkyBlue1'=>[0,191,255 ],'DeepSkyBlue2'=>[0,178,238 ],'DeepSkyBlue3'=>[0,154,205 ],'DeepSkyBlue4'=>[0,104,139 ],'DodgerBlue'=>[30,144,255 ],'DodgerBlue1'=>[30,144,255 ],'DodgerBlue2'=>[28,134,238 ],'DodgerBlue3'=>[24,116,205 ],'DodgerBlue4'=>[16,78,139 ],'HotPink1'=>[255,110,180 ],'HotPink2'=>[238,106,167 ],'HotPink3'=>[205,96,144 ],'HotPink4'=>[139,58,98 ],'IndianRed'=>[205,92,92 ],'IndianRed1'=>[255,106,106 ],'IndianRed2'=>[238,99,99 ],'IndianRed3'=>[205,85,85 ],'IndianRed4'=>[139,58,58 ],'LavenderBlush'=>[255,240,245 ],'LavenderBlush1'=>[255,240,245 ],'LavenderBlush2'=>[238,224,229 ],'LavenderBlush3'=>[205,193,197 ],'LavenderBlush4'=>[139,131,134 ],'LemonChiffon'=>[255,250,205 ],'LemonChiffon1'=>[255,250,205 ],'LemonChiffon2'=>[238,233,191 ],'LemonChiffon3'=>[205,201,165 ],'LemonChiffon4'=>[139,137,112 ],'LightBlue'=>[173,216,230 ],'LightBlue1'=>[191,239,255 ],'LightBlue2'=>[178,223,238 ],'LightBlue3'=>[154,192,205 ],'LightBlue4'=>[104,131,139 ],'LightCyan'=>[224,255,255 ],'LightCyan1'=>[224,255,255 ],'LightCyan2'=>[209,238,238 ],'LightCyan3'=>[180,205,205 ],'LightCyan4'=>[122,139,139 ],'LightGoldenrod'=>[238,221,130 ],'LightGoldenrod1'=>[255,236,139 ],'LightGoldenrod2'=>[238,220,130 ],'LightGoldenrod3'=>[205,190,112 ],'LightGoldenrod4'=>[139,129,76 ],'LightPink'=>[255,182,193 ],'LightPink1'=>[255,174,185 ],'LightPink2'=>[238,162,173 ],'LightPink3'=>[205,140,149 ],'LightPink4'=>[139,95,101 ],'LightSalmon'=>[255,160,122 ],'LightSalmon1'=>[255,160,122 ],'LightSalmon2'=>[238,149,114 ],'LightSalmon3'=>[205,129,98 ],'LightSalmon4'=>[139,87,66 ],'LightSkyBlue'=>[135,206,250 ],'LightSkyBlue1'=>[176,226,255 ],'LightSkyBlue2'=>[164,211,238 ],'LightSkyBlue3'=>[141,182,205 ],'LightSkyBlue4'=>[96,123,139 ],'LightSteelBlue'=>[176,196,222 ],'LightSteelBlue1'=>[202,225,255 ],'LightSteelBlue2'=>[188,210,238 ],'LightSteelBlue3'=>[162,181,205 ],'LightSteelBlue4'=>[110,123,139 ],'LightYellow'=>[255,255,224 ],'LightYellow1'=>[255,255,224 ],'LightYellow2'=>[238,238,209 ],'LightYellow3'=>[205,205,180 ],'LightYellow4'=>[139,139,122 ],'MediumOrchid'=>[186,85,211 ],'MediumOrchid1'=>[224,102,255 ],'MediumOrchid2'=>[209,95,238 ],'MediumOrchid3'=>[180,82,205 ],'MediumOrchid4'=>[122,55,139 ],'MediumPurple1'=>[171,130,255 ],'MediumPurple2'=>[159,121,238 ],'MediumPurple3'=>[137,104,205 ],'MediumPurple4'=>[93,71,139 ],'MistyRose'=>[255,228,225 ],'MistyRose1'=>[255,228,225 ],'MistyRose2'=>[238,213,210 ],'MistyRose3'=>[205,183,181 ],'MistyRose4'=>[139,125,123 ],'NavajoWhite'=>[255,222,173 ],'NavajoWhite1'=>[255,222,173 ],'NavajoWhite2'=>[238,207,161 ],'NavajoWhite3'=>[205,179,139 ],'NavajoWhite4'=>[139,121,94 ],'OliveDrab'=>[107,142,35 ],'OliveDrab1'=>[192,255,62 ],'OliveDrab2'=>[179,238,58 ],'OliveDrab3'=>[154,205,50 ],'OliveDrab4'=>[105,139,34 ],'OrangeRed'=>[255,69,0 ],'OrangeRed1'=>[255,69,0 ],'OrangeRed2'=>[238,64,0 ],'OrangeRed3'=>[205,55,0 ],'OrangeRed4'=>[139,37,0 ],'PaleGreen'=>[152,251,152 ],'PaleTurquoise'=>[175,238,238 ],'PaleTurquoise1'=>[187,255,255 ],'PaleTurquoise2'=>[174,238,238 ],'PaleTurquoise3'=>[150,205,205 ],'PaleTurquoise4'=>[102,139,139 ],'PaleVioletRed'=>[219,112,147 ],'PaleVioletRed1'=>[255,130,171 ],'PaleVioletRed2'=>[238,121,159 ],'PaleVioletRed3'=>[205,104,137 ],'PaleVioletRed4'=>[139,71,93 ],'RosyBrown'=>[188,143,143 ],'RosyBrown1'=>[255,193,193 ],'RosyBrown2'=>[238,180,180 ],'RosyBrown3'=>[205,155,155 ],'RosyBrown4'=>[139,105,105 ],'RoyalBlue1'=>[72,118,255 ],'RoyalBlue2'=>[67,110,238 ],'RoyalBlue3'=>[58,95,205 ],'RoyalBlue4'=>[39,64,139 ],'SeaGreen'=>[46,139,87 ],'SeaGreen1'=>[84,255,159 ],'SeaGreen2'=>[78,238,148 ],'SeaGreen3'=>[67,205,128 ],'SeaGreen4'=>[46,139,87 ],'SkyBlue'=>[135,206,235 ],'SkyBlue1'=>[135,206,255 ],'SkyBlue2'=>[126,192,238 ],'SkyBlue3'=>[108,166,205 ],'SkyBlue4'=>[74,112,139 ],'SlateBlue1'=>[131,111,255 ],'SlateBlue2'=>[122,103,238 ],'SlateBlue3'=>[105,89,205 ],'SlateBlue4'=>[71,60,139 ],'SlateGray'=>[112,128,144 ],'SlateGray1'=>[198,226,255 ],'SlateGray2'=>[185,211,238 ],'SlateGray3'=>[159,182,205 ],'SlateGray4'=>[108,123,139 ],'SpringGreen'=>[0,255,127 ],'SpringGreen1'=>[0,255,127 ],'SpringGreen2'=>[0,238,118 ],'SpringGreen3'=>[0,205,102 ],'SpringGreen4'=>[0,139,69 ],'SteelBlue'=>[70,130,180 ],'SteelBlue1'=>[99,184,255 ],'SteelBlue2'=>[92,172,238 ],'SteelBlue3'=>[79,148,205 ],'SteelBlue4'=>[54,100,139 ],'VioletRed'=>[208,32,144 ],'VioletRed1'=>[255,62,150 ],'VioletRed2'=>[238,58,140 ],'VioletRed3'=>[205,50,120 ],'VioletRed4'=>[139,34,82 ],'aquamarine'=>[127,255,212 ],'aquamarine1'=>[127,255,212 ],'aquamarine2'=>[118,238,198 ],'aquamarine3'=>[102,205,170 ],'aquamarine4'=>[69,139,116 ],'azure'=>[240,255,255 ],'azure1'=>[240,255,255 ],'azure2'=>[224,238,238 ],'azure3'=>[193,205,205 ],'azure4'=>[131,139,139 ],'bisque'=>[255,228,196 ],'bisque1'=>[255,228,196 ],'bisque2'=>[238,213,183 ],'bisque3'=>[205,183,158 ],'bisque4'=>[139,125,107 ],'blue1'=>[0,0,255 ],'blue2'=>[0,0,238 ],'blue3'=>[0,0,205 ],'blue4'=>[0,0,139 ],'brown1'=>[255,64,64 ],'brown2'=>[238,59,59 ],'brown3'=>[205,51,51 ],'brown4'=>[139,35,35 ],'burlywood'=>[222,184,135 ],'burlywood1'=>[255,211,155 ],'burlywood2'=>[238,197,145 ],'burlywood3'=>[205,170,125 ],'burlywood4'=>[139,115,85 ],'chartreuse'=>[127,255,0 ],'chartreuse1'=>[127,255,0 ],'chartreuse2'=>[118,238,0 ],'chartreuse3'=>[102,205,0 ],'chartreuse4'=>[69,139,0 ],'chocolate'=>[210,105,30 ],'coral'=>[255,127,80 ],'coral1'=>[255,114,86 ],'coral2'=>[238,106,80 ],'coral3'=>[205,91,69 ],'coral4'=>[139,62,47 ],'cornsilk'=>[255,248,220 ],'cornsilk1'=>[255,248,220 ],'cornsilk2'=>[238,232,205 ],'cornsilk3'=>[205,200,177 ],'cornsilk4'=>[139,136,120 ],'cyan'=>[0,255,255 ],'cyan1'=>[0,255,255 ],'cyan2'=>[0,238,238 ],'cyan3'=>[0,205,205 ],'cyan4'=>[0,139,139 ],'firebrick'=>[178,34,34 ],'firebrick1'=>[255,48,48 ],'firebrick2'=>[238,44,44 ],'firebrick3'=>[205,38,38 ],'firebrick4'=>[139,26,26 ],'gold'=>[255,215,0 ],'gold1'=>[255,215,0 ],'gold2'=>[238,201,0 ],'gold3'=>[205,173,0 ],'gold4'=>[139,117,0 ],'goldenrod'=>[218,165,32 ],'goldenrod1'=>[255,193,37 ],'goldenrod2'=>[238,180,34 ],'goldenrod3'=>[205,155,29 ],'goldenrod4'=>[139,105,20 ],'gray'=>[190,190,190 ],'gray1'=>[3,3,3 ],'gray2'=>[5,5,5 ],'gray3'=>[8,8,8 ],'gray4'=>[10,10,10 ],'green1'=>[0,255,0 ],'green2'=>[0,238,0 ],'green3'=>[0,205,0 ],'green4'=>[0,139,0 ],'grey1'=>[3,3,3 ],'grey2'=>[5,5,5 ],'grey3'=>[8,8,8 ],'grey4'=>[10,10,10 ],'honeydew'=>[240,255,240 ],'honeydew1'=>[240,255,240 ],'honeydew2'=>[224,238,224 ],'honeydew3'=>[193,205,193 ],'honeydew4'=>[131,139,131 ],'ivory'=>[255,255,240 ],'ivory1'=>[255,255,240 ],'ivory2'=>[238,238,224 ],'ivory3'=>[205,205,193 ],'ivory4'=>[139,139,131 ],'khaki'=>[240,230,140 ],'khaki1'=>[255,246,143 ],'khaki2'=>[238,230,133 ],'khaki3'=>[205,198,115 ],'khaki4'=>[139,134,78 ],'magenta'=>[255,0,255 ],'magenta1'=>[255,0,255 ],'magenta2'=>[238,0,238 ],'magenta3'=>[205,0,205 ],'magenta4'=>[139,0,139 ],'maroon'=>[176,48,96 ],'maroon1'=>[255,52,179 ],'maroon2'=>[238,48,167 ],'maroon3'=>[205,41,144 ],'maroon4'=>[139,28,98 ],'orange1'=>[255,165,0 ],'orchid'=>[218,112,214 ],'orchid1'=>[255,131,250 ],'orchid2'=>[238,122,233 ],'orchid3'=>[205,105,201 ],'orchid4'=>[139,71,137 ],'pink1'=>[255,181,197 ],'pink2'=>[238,169,184 ],'pink3'=>[205,145,158 ],'pink4'=>[139,99,108 ],'plum1'=>[255,187,255 ],'plum2'=>[238,174,238 ],'plum3'=>[205,150,205 ],'plum4'=>[139,102,139 ],'purple1'=>[155,48,255 ],'purple2'=>[145,44,238 ],'purple3'=>[125,38,205 ],'purple4'=>[85,26,139 ],'red1'=>[255,0,0 ],'red2'=>[238,0,0 ],'red3'=>[205,0,0 ],'red4'=>[139,0,0 ],'salmon'=>[250,128,114 ],'salmon1'=>[255,140,105 ],'salmon2'=>[238,130,98 ],'salmon3'=>[205,112,84 ],'salmon4'=>[139,76,57 ],'seashell'=>[255,245,238 ],'seashell1'=>[255,245,238 ],'seashell2'=>[238,229,222 ],'seashell3'=>[205,197,191 ],'seashell4'=>[139,134,130 ],'sienna'=>[160,82,45 ],'sienna1'=>[255,130,71 ],'sienna2'=>[238,121,66 ],'sienna3'=>[205,104,57 ],'sienna4'=>[139,71,38 ],'snow'=>[255,250,250 ],'snow1'=>[255,250,250 ],'snow2'=>[238,233,233 ],'snow3'=>[205,201,201 ],'snow4'=>[139,137,137 ],'tan'=>[210,180,140 ],'tan1'=>[255,165,79 ],'tan2'=>[238,154,73 ],'tan3'=>[205,133,63 ],'tan4'=>[139,90,43 ],'thistle'=>[216,191,216 ],'thistle1'=>[255,225,255 ],'thistle2'=>[238,210,238 ],'thistle3'=>[205,181,205 ],'thistle4'=>[139,123,139 ],'tomato'=>[255,99,71 ],'tomato1'=>[255,99,71 ],'tomato2'=>[238,92,66 ],'tomato3'=>[205,79,57 ],'tomato4'=>[139,54,38 ],'turquoise1'=>[0,245,255 ],'turquoise2'=>[0,229,238 ],'turquoise3'=>[0,197,205 ],'turquoise4'=>[0,134,139 ],'wheat'=>[245,222,179 ],'wheat1'=>[255,231,186 ],'wheat2'=>[238,216,174 ],'wheat3'=>[205,186,150 ],'wheat4'=>[139,126,102 ],'yellow1'=>[255,255,0 ],'yellow2'=>[238,238,0 ],'yellow3'=>[205,205,0 ],'yellow4'=>[139,139,0 ],);sub _set_colors {my$self=shift;my$index=$self->_color_role_to_index('background');if ($self->true($self->{'transparent'})){$self->{'gd_obj'}->transparent($index)}return 1}sub _color_role_to_index {my$self=shift;my@result=map {my$role=$_;my$index=$self->{'color_table'}->{$role};unless (defined$index){my$spec=$self->{'colors'}->{$role}|| $self->{'colors_default_spec'}->{$role}|| $self->{'colors_default_spec'}->{$self->{'colors_default_role'}->{$role}};my@rgb=$self->_color_spec_to_rgb($role,$spec);my$string=sprintf " RGB(%d,%d,%d)",map {$_ + 0}@rgb;$index=$self->{'color_table'}->{$string};unless (defined$index){$index=$self->{'gd_obj'}->colorAllocate(@rgb);$self->{'color_table'}->{$string}=$index}$self->{'color_table'}->{$role}=$index}$index}@_;(wantarray && @_ > 1 ? @result : $result[0])}sub _color_spec_to_rgb {my$self=shift;my$role=shift;my$spec=shift;my@rgb;if (ref($spec)eq 'ARRAY'){@rgb=@{$spec};croak "Invalid color RGB array (" .join(',',@rgb).") for $role\n" unless@rgb==3 && grep(!m/^\d+$/ || $_ > 255,@rgb)==0}elsif (!ref($spec)){croak "Unknown named color ($spec) for $role\n" unless$named_colors{$spec};@rgb=@{$named_colors{$spec}}}else {croak "Unrecognized color for $role\n"}@rgb}sub _brushStyles_of_roles {my$self=shift;my@roles=@_;my@results=();for my$role (@roles){my$brushStyle=$self->{'brushStyles'}->{$role};if (!defined($brushStyle)){$brushStyle=$self->{'brushStyle'}}push(@results,$brushStyle)}@results}sub _draw_title {my$self=shift;my$font=$self->{'title_font'};my$color;my ($h,$w,@lines,$x,$y);if (defined$self->{'colors'}{'title'}){$color=$self->_color_role_to_index('title')}else {$color=$self->_color_role_to_index('text')}unless ((ref$font)eq 'GD::Font'){croak "The title font you specified isn\'t a GD Font object"}($h,$w)=($font->height,$font->width);@lines=split(/\\n/,$self->{'title'});$x=($self->{'curr_x_max'}- $self->{'curr_x_min'})/ 2 + $self->{'curr_x_min'}- (length($lines[0])* $w)/ 2;$y=$self->{'curr_y_min'}+ $self->{'text_space'};$self->{'gd_obj'}->string($font,$x,$y,$lines[0],$color);if ($w > 1){$w--}if ($h > 1){$h--}for (1 .. $#lines){$self->{'curr_y_min'}+= $self->{'text_space'}+ $h;$x=($self->{'curr_x_max'}- $self->{'curr_x_min'})/ 2 + $self->{'curr_x_min'}- (length($lines[$_])* $w)/ 2;$y=$self->{'curr_y_min'}+ $self->{'text_space'};$self->{'gd_obj'}->string($font,$x,$y,$lines[$_],$color)}$self->{'curr_y_min'}+= 2 * $self->{'text_space'}+ $h;return 1}sub _draw_sub_title {my$self=shift;my$font=$self->{'sub_title_font'};my$text=$self->{'sub_title'};return 1 if length($text)==0;my$color;if (defined$self->{'colors'}{'title'}){$color=$self->_color_role_to_index('title')}else {$color=$self->_color_role_to_index('text')}my ($h,$w,$x,$y);unless ((ref($font))eq 'GD::Font'){croak "The subtitle font you specified isn\'t a GD Font object"}($h,$w)=($font->height,$font->width);if ($h > 1 && $w > 1){$h--,$w--}$x=($self->{'curr_x_max'}- $self->{'curr_x_min'})/ 2 + $self->{'curr_x_min'}- (length($text)* $w)/ 2;$y=$self->{'curr_y_min'};$self->{'gd_obj'}->string($font,$x,$y,$text,$color);$self->{'curr_y_min'}+= $self->{'text_space'}+ $h;return 1}sub _sort_data {my$self=shift;my$data_ref=$self->{'dataref'};my@data=@{$self->{'dataref'}};my@sort_index;@sort_index=sort {$data[0][$a]<=> $data[0][$b]}(0 .. scalar(@{$data[1]})- 1);for (1 .. $#data){@{$self->{'dataref'}->[$_]}=@{$self->{'dataref'}->[$_]}[@sort_index]}@{$data_ref->[0]}=sort {$a <=> $b}@{$data_ref->[0]};return 1}sub _find_x_scale {my$self=shift;my@data=@{$self->{'dataref'}};my ($i,$j);my ($d_min,$d_max);my ($p_min,$p_max,$f_min,$f_max);my ($tickInterval,$tickCount,$skip);my@tickLabels;my$maxtickLabelLen=0;for$i (0 .. ($self->{'num_datasets'})){for$j (0 .. ($self->{'num_datapoints'}- 1)){if (defined$data[$i][$j]and $data[$i][$j]!~ m/^[\+\-]?((\.\d+)|(\d+\.?\d*))([eE][+-]?\d+)?[fFdD]?$/){croak "<$data[$i][$j]> You should give me numbers for drawing a xy plot!\n"}}}($d_min,$d_max)=$self->_find_x_range();if ($self->true($self->{'include_zero'})){if (($d_min * $d_max)> 0){if ($d_min > 0){$d_min=0}else {$d_max=0}}}my$d_width=$d_max - $d_min;if (0==$d_width){$d_min--,$d_max++,$d_width=2}my ($rangeExponent,$rangeMantisa)=$self->_sepFP($d_width);my$rangeMuliplier=10**$rangeExponent;($tickInterval,$tickCount,$p_min,$p_max)=$self->_calcXTickInterval($d_min / $rangeMuliplier,$d_max / $rangeMuliplier,$f_min,$f_max,$self->{'min_x_ticks'},$self->{'max_x_ticks'});$_ *= $rangeMuliplier foreach ($tickInterval,$p_min,$p_max);my$precision=$self->{'precision'};for (my$labelNum=$p_min ;$labelNum < $p_max + $tickInterval / 2 ;$labelNum += $tickInterval ){my$labelText;if (defined$self->{f_y_tick}){if ($self->{f_y_tick}==\&_default_f_tick){$labelText=sprintf("%." .$precision ."f",$labelNum)}else {$labelText=$self->{f_y_tick}->($labelNum)}}else {$labelText=sprintf("%." .$precision ."f",$labelNum)}push@tickLabels,$labelText;$maxtickLabelLen=length$labelText if$maxtickLabelLen < length$labelText}$self->{'x_min_val'}=$p_min,$self->{'x_max_val'}=$p_max,$self->{'x_tick_labels'}=\@tickLabels,$self->{'x_tick_label_length'}=$maxtickLabelLen,$self->{'x_number_ticks'}=$tickCount;return 1}sub _find_y_scale {my$self=shift;my ($d_min,$d_max);my ($p_min,$p_max);my ($tickInterval,$tickCount,$skip);my@tickLabels;my$maxtickLabelLen=0;my$prec_test=0;my$temp_rangeExponent;my$flag_all_integers=1;($d_min,$d_max,$flag_all_integers)=$self->_find_y_range();if ($self->true($self->{'include_zero'})){if (($d_min * $d_max)> 0){if ($d_min > 0){$d_min=0}else {$d_max=0}}}if ($self->true($self->{'integer_ticks_only'})){my$f_min=0;if (defined$self->{'min_val'}){$f_min=1}$d_min=$self->{'min_val'}if$f_min;my$f_max=0;if (defined$self->{'max_val'}){$f_max=1}$d_max=$self->{'max_val'}if$f_max;if (!defined$d_min ||!defined$d_max){croak "No min_val or max_val is defined"}if ($d_min > $d_max){croak "The specified 'min_val' & 'max_val' values are reversed (min > max: $d_min>$d_max)"}$skip=$self->{skip_int_ticks};$skip=1 if$skip < 1;$p_min=$self->_round2Tick($d_min,1,-1);$p_max=$self->_round2Tick($d_max,1,1);if (($p_max - $p_min)==0){$p_max++ if ($f_max!=1);$p_min-- if ($f_min!=1);$p_max++ if (($p_max - $p_min)==0)}$tickInterval=$skip;$tickCount=($p_max - $p_min)/ $skip + 1;for (my$labelNum=$p_min ;$labelNum < $p_max + $tickInterval / 3 ;$labelNum += $tickInterval ){my$labelText;if (defined$self->{f_y_tick}){if ($self->{f_y_tick}==\&_default_f_tick){$labelText=sprintf("%d",$labelNum)}else {$labelText=$self->{f_y_tick}->($labelNum)}}else {$labelText=sprintf("%d",$labelNum)}push@tickLabels,$labelText;$maxtickLabelLen=length$labelText if$maxtickLabelLen < length$labelText}}else {my$f_min=0;if (defined$self->{'min_val'}){$f_min=1}$d_min=$self->{'min_val'}if$f_min;my$f_max=0;if (defined$self->{'max_val'}){$f_max=1}$d_max=$self->{'max_val'}if$f_max;if (!defined$d_min ||!defined$d_max){croak "No min_val or max_val is defined"}if ($d_min > $d_max){croak "The the specified 'min_val' & 'max_val' values are reversed (min > max: $d_min>$d_max)"}my$d_width=$d_max - $d_min;if ($d_width==0){$d_min--,$d_max++,$d_width=2}my ($rangeExponent,$rangeMantisa)=$self->_sepFP($d_width);my$rangeMuliplier=10**$rangeExponent;($tickInterval,$tickCount,$p_min,$p_max)=$self->_calcTickInterval($d_min / $rangeMuliplier,$d_max / $rangeMuliplier,$f_min,$f_max,$self->{'min_y_ticks'},$self->{'max_y_ticks'});$_ *= $rangeMuliplier foreach ($tickInterval,$p_min,$p_max);if ($rangeExponent < 0){$temp_rangeExponent=-$rangeExponent}else {$temp_rangeExponent=$rangeExponent}my$precision=$self->{'precision'};if ($temp_rangeExponent!=0 && $rangeExponent < 0 && $temp_rangeExponent > $precision){$prec_test=1}for (my$labelNum=$p_min ;$labelNum < $p_max + $tickInterval / 2 ;$labelNum += $tickInterval ){my$labelText;if (defined$self->{f_y_tick}){if (($self->{f_y_tick}==\&_default_f_tick)&& ($prec_test==0)){$labelText=sprintf("%." .$precision ."f",$labelNum)}elsif (($self->{f_y_tick}==\&_default_f_tick)&& ($prec_test==1)){$labelText=$self->{f_y_tick}->($labelNum)}else {$labelText=$self->{f_y_tick}->($labelNum)}}else {$labelText=sprintf("%." .$precision ."f",$labelNum)}push@tickLabels,$labelText;$maxtickLabelLen=length$labelText if$maxtickLabelLen < length$labelText}}$self->{'min_val'}=$p_min,$self->{'max_val'}=$p_max,$self->{'y_ticks'}=$tickCount,$self->{'y_tick_labels'}=\@tickLabels,$self->{'y_tick_label_length'}=$maxtickLabelLen;return 1}sub _calcTickInterval {my$self=shift;my ($dataset_min,$dataset_max,$flag_fixed_min,$flag_fixed_max,$minTicks,$maxTicks,)=@_;if ($minTicks < 2){$minTicks=2}if ($maxTicks < 5 * $minTicks){$maxTicks=5 * $minTicks}my$width=$dataset_max - $dataset_min;my@divisorList;for (my$baseMul=1 ;;$baseMul *= 10 ){TRY: foreach my$tryMul (1,2,5){my$divisor=$baseMul * $tryMul;my ($tickCount,$pMin,$pMax)=$self->_countTicks($dataset_min,$dataset_max,1 / $divisor);if ($maxTicks < $tickCount){$divisor=pop@divisorList;if (!defined($divisor)|| $divisor==0){$divisor=1}($tickCount,$pMin,$pMax)=$self->_countTicks($dataset_min,$dataset_max,1 / $divisor);return (1 / $divisor,$tickCount,$pMin,$pMax)}elsif ($minTicks > $tickCount){next TRY}else {push@divisorList,$divisor;next TRY if ($flag_fixed_min && (int($dataset_min * $divisor)!=($dataset_min * $divisor)));next TRY if ($flag_fixed_max && (int($dataset_max * $divisor)!=($dataset_max * $divisor)));return (1 / $divisor,$tickCount,$pMin,$pMax)}}}die "can't happen!"}sub _calcXTickInterval {my$self=shift;my ($min,$max,$minF,$maxF,$minTicks,$maxTicks,)=@_;if ($minTicks < 2){$minTicks=2}if ($maxTicks < 5 * $minTicks){$maxTicks=5 * $minTicks}my$width=$max - $min;my@divisorList;for (my$baseMul=1 ;;$baseMul *= 10 ){TRY: foreach my$tryMul (1,2,5){my$divisor=$baseMul * $tryMul;my ($tickCount,$pMin,$pMax)=$self->_countTicks($min,$max,1 / $divisor);if ($maxTicks < $tickCount){$divisor=pop@divisorList;if (!defined($divisor)|| $divisor==0){$divisor=1}($tickCount,$pMin,$pMax)=$self->_countTicks($min,$max,1 / $divisor);return (1 / $divisor,$tickCount,$pMin,$pMax)}elsif ($minTicks > $tickCount){next TRY}else {push@divisorList,$divisor;next TRY if ($minF && (int($min * $divisor)!=($min * $divisor)));next TRY if ($maxF && (int($max * $divisor)!=($max * $divisor)));return (1 / $divisor,$tickCount,$pMin,$pMax)}}}croak "can't happen!"}sub _countTicks {my$self=shift;my ($min,$max,$interval)=@_;my$minR=$self->_round2Tick($min,$interval,-1);my$maxR=$self->_round2Tick($max,$interval,1);my$tickCount=($maxR / $interval)- ($minR / $interval)+ 1;return ($tickCount,$minR,$maxR)}sub _round2Tick {my$self=shift;my ($input,$interval,$roundUP)=@_;return$input if$interval==0;die unless 1==$roundUP * $roundUP;my$intN=int($input / $interval);my$fracN=($input / $interval)- $intN;my$retN=((0==$fracN)|| (($roundUP * $fracN)< 0))? $intN : $intN + $roundUP;return$retN * $interval}sub _sepFP {my$self=shift;my ($num)=@_;return (0,0)if$num==0;my$sign=($num > 0)? 1 : -1;$num *= $sign;my$exponent=int(log($num)/ log(10));my$mantisa=$sign * ($num / (10**$exponent));return ($exponent,$mantisa)}sub _find_y_range {my$self=shift;my$data=$self->{'dataref'};my$max=undef;my$min=undef;my$flag_all_integers=1;for my$dataset (@$data[1 .. $#$data ]){for my$datum (@$dataset){if (defined$datum){if ($flag_all_integers){if ($datum !~ /^[\-\+]?\d+$/){$flag_all_integers=0}}if ($datum =~ /^[\-\+]?\s*[\d\.eE\-\+]+/){if (defined$max && $max =~ /^[\-\+]{0,}\s*[\d\.eE\-\+]+/){if ($datum > $max){$max=$datum}elsif (!defined$min){$min=$datum}elsif ($datum < $min){$min=$datum}}else {$min=$max=$datum}}}}}($min,$max,$flag_all_integers)}sub _find_x_range {my$self=shift;my$data=$self->{'dataref'};my$max=undef;my$min=undef;for my$datum (@{$data->[0]}){if (defined$datum && $datum =~ /^[\-\+]{0,1}\s*[\d\.eE\-\+]+/){if (defined$max && $max =~ /^[\-\+]{0,1}\s*[\d\.eE\-\+]+/){if ($datum > $max){$max=$datum}elsif ($datum < $min){$min=$datum}}else {$min=$max=$datum}}}return ($min,$max)}sub _plot {my$self=shift;$self->_draw_legend();$self->{'curr_x_min'}+= $self->{'graph_border'};$self->{'curr_x_max'}-= $self->{'graph_border'};$self->{'curr_y_min'}+= $self->{'graph_border'};$self->{'curr_y_max'}-= $self->{'graph_border'};$self->_draw_x_label if$self->{'x_label'};$self->_draw_y_label('left')if$self->{'y_label'};$self->_draw_y_label('right')if$self->{'y_label2'};$self->_draw_ticks();$self->_grey_background if ($self->true($self->{'grey_background'}));if ($self->true($self->{'grey_background'})&& $self->isa("Chart::Direction")){$self->_draw_ticks}$self->_draw_grid_lines if ($self->true($self->{'grid_lines'}));$self->_draw_x_grid_lines if ($self->true($self->{'x_grid_lines'}));$self->_draw_y_grid_lines if ($self->true($self->{'y_grid_lines'}));$self->_draw_y2_grid_lines if ($self->true($self->{'y2_grid_lines'}));$self->_draw_data();return 1}sub _draw_legend {my$self=shift;my$length;if ($self->{'legend'}=~ /^none$/ || length($self->{'legend'})==0){return 1}if (($#{$self->{'legend_labels'}}>= 0)&& ((scalar(@{$self->{'legend_labels'}}))!=$self->{'num_datasets'})){carp "The number of legend labels and datasets doesn\'t match"}unless ($self->{'max_legend_label'}){$self->{'max_legend_label'}=0}for (1 .. $self->{'num_datasets'}){unless ($self->{'legend_labels'}[$_ - 1 ]){$self->{'legend_labels'}[$_ - 1 ]="Dataset $_"}$length=length($self->{'legend_labels'}[$_ - 1 ]);if ($length > $self->{'max_legend_label'}){$self->{'max_legend_label'}=$length}}if ($self->{'legend'}eq 'bottom'){$self->_draw_bottom_legend}elsif ($self->{'legend'}eq 'right'){$self->_draw_right_legend}elsif ($self->{'legend'}eq 'left'){$self->_draw_left_legend}elsif ($self->{'legend'}eq 'top'){$self->_draw_top_legend}elsif ($self->{'legend'}eq 'none' || length($self->{'legend'})==0){$self->_draw_none_legend}else {carp "I can't put a legend there (at " .$self->{'legend'}.")\n"}return 1}sub _draw_bottom_legend {my$self=shift;my@labels=@{$self->{'legend_labels'}};my ($x1,$y1,$x2,$x3,$y2);my ($empty_width,$max_label_width,$cols,$rows,$color,$brush);my ($col_width,$row_height,$r,$c,$index,$x,$y,$w,$h,$axes_space);my$font=$self->{'legend_font'};unless ((ref($font))eq 'GD::Font'){croak "The font you specified isn\'t a GD Font object"}($h,$w)=($font->height,$font->width);$axes_space=($self->{'y_tick_label_length'}* $self->{'tick_label_font'}->width)+ $self->{'tick_len'}+ (3 * $self->{'text_space'});$x1=$self->{'curr_x_min'}+ $self->{'graph_border'};$x2=$self->{'curr_x_max'}- $self->{'graph_border'};if ($self->{'y_axes'}=~ /^right$/i){$x2 -= $axes_space}elsif ($self->{'y_axes'}=~ /^both$/i){$x2 -= $axes_space;$x1 += $axes_space}if ($self->{'y_label'}){$x1 += $self->{'label_font'}->height + 2 * $self->{'text_space'}}if ($self->{'y_label2'}){$x2 -= $self->{'label_font'}->height + 2 * $self->{'text_space'}}$empty_width=($x2 - $x1)- (2 * $self->{'legend_space'});$max_label_width=$self->{'max_legend_label'}* $w + (4 * $self->{'text_space'})+ $self->{'legend_example_size'};$cols=int($empty_width / $max_label_width);unless ($cols){$cols=1}$col_width=$empty_width / $cols;$rows=int($self->{'num_datasets'}/ $cols);unless (($self->{'num_datasets'}% $cols)==0){$rows++}unless ($rows){$rows=1}$row_height=$h + $self->{'text_space'};$y1=$self->{'curr_y_max'}- $self->{'text_space'}- ($rows * $row_height)- (2 * $self->{'legend_space'});$y2=$self->{'curr_y_max'};$self->{'gd_obj'}->rectangle($x1,$y1,$x2,$y2,$self->_color_role_to_index('misc'));$x1 += $self->{'legend_space'}+ $self->{'text_space'};$x2 -= $self->{'legend_space'};$y1 += $self->{'legend_space'}+ $self->{'text_space'};$y2 -= $self->{'legend_space'}+ $self->{'text_space'};for$r (0 .. $rows - 1){for$c (0 .. $cols - 1){$index=($r * $cols)+ $c;if ($labels[$index]){$color=$self->_color_role_to_index('dataset' .$index);$x=$x1 + ($col_width * $c);$y=$y1 + ($row_height * $r)+ $h / 2;$self->{'gd_obj'}->line($x,$y,$x + $self->{'legend_example_size'},$y,$color);$brush=$self->_prepare_brush($color,'point','dataset' .$index);$self->{'gd_obj'}->setBrush($brush);$x3=int($x + $self->{'legend_example_size'}/ 2);$self->{'gd_obj'}->line($x3,$y,$x3,$y,gdBrushed);$x += $self->{'legend_example_size'}+ (2 * $self->{'text_space'});$y=$y1 + ($row_height * $r);$self->{'gd_obj'}->string($font,$x,$y,$labels[$index],$color)}}}$self->{'curr_y_max'}-= $rows * $row_height + 2 * $self->{'text_space'}+ 2 * $self->{'legend_space'};return 1}sub _draw_right_legend {my$self=shift;my@labels=@{$self->{'legend_labels'}};my ($x1,$x2,$x3,$y1,$y2,$width,$color,$misccolor,$w,$h,$brush);my$font=$self->{'legend_font'};unless ((ref($font))eq 'GD::Font'){croak "The subtitle font you specified isn\'t a GD Font object"}($h,$w)=($font->height,$font->width);$misccolor=$self->_color_role_to_index('misc');$width=(2 * $self->{'text_space'})+ ($self->{'max_legend_label'}* $w)+ $self->{'legend_example_size'}+ (2 * $self->{'legend_space'});$x1=$self->{'curr_x_max'}- $width;$x2=$self->{'curr_x_max'};$y1=$self->{'curr_y_min'}+ $self->{'graph_border'};$y2=$self->{'curr_y_min'}+ $self->{'graph_border'}+ $self->{'text_space'}+ ($self->{'num_datasets'}* ($h + $self->{'text_space'}))+ (2 * $self->{'legend_space'});$self->{'gd_obj'}->rectangle($x1,$y1,$x2,$y2,$misccolor);$x1 += $self->{'legend_space'};$y1 += $self->{'legend_space'}+ $self->{'text_space'};for (0 .. $#labels){my$c=$self->{'num_datasets'}- $_ - 1;$color=$self->_color_role_to_index('dataset' .$_);$x2=$x1;$x3=$x2 + $self->{'legend_example_size'};$y2=$y1 + ($_ * ($self->{'text_space'}+ $h))+ $h / 2;$self->{'gd_obj'}->line($x2,$y2,$x3,$y2,$color);my$offset=0;($brush,$offset)=$self->_prepare_brush($color,'point','dataset' .$_);$self->{'gd_obj'}->setBrush($brush);$self->{'gd_obj'}->line(int(($x3 + $x2)/ 2),$y2,int(($x3 + $x2)/ 2),$y2,gdBrushed);$x2=$x3 + (2 * $self->{'text_space'});$y2 -= $h / 2;$self->{'gd_obj'}->string($font,$x2,$y2,$labels[$_],$color)}$self->{'curr_x_max'}-= $width;return 1}sub _draw_top_legend {my$self=shift;my@labels=@{$self->{'legend_labels'}};my ($x1,$y1,$x2,$x3,$y2,$empty_width,$max_label_width);my ($cols,$rows,$color,$brush);my ($col_width,$row_height,$r,$c,$index,$x,$y,$w,$h,$axes_space);my$font=$self->{'legend_font'};unless ((ref($font))eq 'GD::Font'){croak "The subtitle font you specified isn\'t a GD Font object"}($h,$w)=($font->height,$font->width);$axes_space=($self->{'y_tick_label_length'}* $self->{'tick_label_font'}->width)+ $self->{'tick_len'}+ (3 * $self->{'text_space'});$x1=$self->{'curr_x_min'}+ $self->{'graph_border'};$x2=$self->{'curr_x_max'}- $self->{'graph_border'};if ($self->{'y_axes'}=~ /^right$/i){$x2 -= $axes_space}elsif ($self->{'y_axes'}=~ /^both$/i){$x2 -= $axes_space;$x1 += $axes_space}$empty_width=($x2 - $x1)- (2 * $self->{'legend_space'});$max_label_width=(4 * $self->{'text_space'})+ ($self->{'max_legend_label'}* $w)+ $self->{'legend_example_size'};$cols=int($empty_width / $max_label_width);unless ($cols){$cols=1}$col_width=$empty_width / $cols;$rows=int($self->{'num_datasets'}/ $cols);unless (($self->{'num_datasets'}% $cols)==0){$rows++}unless ($rows){$rows=1}$row_height=$h + $self->{'text_space'};$y1=$self->{'curr_y_min'};$y2=$self->{'curr_y_min'}+ $self->{'text_space'}+ ($rows * $row_height)+ (2 * $self->{'legend_space'});$self->{'gd_obj'}->rectangle($x1,$y1,$x2,$y2,$self->_color_role_to_index('misc'));$x1 += $self->{'legend_space'}+ $self->{'text_space'};$x2 -= $self->{'legend_space'};$y1 += $self->{'legend_space'}+ $self->{'text_space'};$y2 -= $self->{'legend_space'}+ $self->{'text_space'};for$r (0 .. $rows - 1){for$c (0 .. $cols - 1){$index=($r * $cols)+ $c;if ($labels[$index]){$color=$self->_color_role_to_index('dataset' .$index);$x=$x1 + ($col_width * $c);$y=$y1 + ($row_height * $r)+ $h / 2;$self->{'gd_obj'}->line($x,$y,$x + $self->{'legend_example_size'},$y,$color);$brush=$self->_prepare_brush($color,'point','dataset' .$index);$self->{'gd_obj'}->setBrush($brush);$x3=int($x + $self->{'legend_example_size'}/ 2);$self->{'gd_obj'}->line($x3,$y,$x3,$y,gdBrushed);$x += $self->{'legend_example_size'}+ (2 * $self->{'text_space'});$y -= $h / 2;$self->{'gd_obj'}->string($font,$x,$y,$labels[$index],$color)}}}$self->{'curr_y_min'}+= ($rows * $row_height)+ $self->{'text_space'}+ 2 * $self->{'legend_space'};return 1}sub _draw_left_legend {my$self=shift;my@labels=@{$self->{'legend_labels'}};my ($x1,$x2,$x3,$y1,$y2,$width,$color,$misccolor,$w,$h,$brush);my$font=$self->{'legend_font'};unless ((ref($font))eq 'GD::Font'){croak "The subtitle font you specified isn\'t a GD Font object"}($h,$w)=($font->height,$font->width);$misccolor=$self->_color_role_to_index('misc');$width=(2 * $self->{'text_space'})+ ($self->{'max_legend_label'}* $w)+ $self->{'legend_example_size'}+ (2 * $self->{'legend_space'});$x1=$self->{'curr_x_min'};$x2=$self->{'curr_x_min'}+ $width;$y1=$self->{'curr_y_min'}+ $self->{'graph_border'};$y2=$self->{'curr_y_min'}+ $self->{'graph_border'}+ $self->{'text_space'}+ ($self->{'num_datasets'}* ($h + $self->{'text_space'}))+ (2 * $self->{'legend_space'});$self->{'gd_obj'}->rectangle($x1,$y1,$x2,$y2,$misccolor);$x1 += $self->{'legend_space'};$y1 += $self->{'legend_space'}+ $self->{'text_space'};for (0 .. $#labels){my$c=$self->{'num_datasets'}- $_ - 1;$color=$self->_color_role_to_index('dataset' .$_);$x2=$x1;$x3=$x2 + $self->{'legend_example_size'};$y2=$y1 + ($_ * ($self->{'text_space'}+ $h))+ $h / 2;$self->{'gd_obj'}->line($x2,$y2,$x3,$y2,$color);$brush=$self->_prepare_brush($color,'point','dataset' .$_);$self->{'gd_obj'}->setBrush($brush);$self->{'gd_obj'}->line(int(($x3 + $x2)/ 2),$y2,int(($x3 + $x2)/ 2),$y2,gdBrushed);$x2=$x3 + (2 * $self->{'text_space'});$y2 -= $h / 2;$self->{'gd_obj'}->string($font,$x2,$y2,$labels[$_],$color)}$self->{'curr_x_min'}+= $width;return 1}sub _draw_none_legend {my$self=shift;my$status=1;return$status}sub _draw_x_label {my$self=shift;my$label=$self->{'x_label'};my$font=$self->{'label_font'};my$color;my ($h,$w,$x,$y);if (defined$self->{'colors'}->{'x_label'}){$color=$self->_color_role_to_index('x_label')}else {$color=$self->_color_role_to_index('text')}unless ((ref($font))eq 'GD::Font'){croak "The x-axis label font you specified isn\'t a GD Font object"}($h,$w)=($font->height,$font->width);$x=($self->{'curr_x_max'}- $self->{'curr_x_min'})/ 2 + $self->{'curr_x_min'}- (length($label)* $w)/ 2;$y=$self->{'curr_y_max'}- ($self->{'text_space'}+ $h);$self->{'gd_obj'}->string($font,$x,$y,$label,$color);$self->{'curr_y_max'}-= $h + 2 * $self->{'text_space'};return 1}sub _draw_y_label {my$self=shift;my$side=shift;my$font=$self->{'label_font'};my ($label,$h,$w,$x,$y,$color);if ($side eq 'left'){$label=$self->{'y_label'};$color=$self->_color_role_to_index('y_label')}elsif ($side eq 'right'){$label=$self->{'y_label2'};$color=$self->_color_role_to_index('y_label2')}unless ((ref($font))eq 'GD::Font'){croak "The x-axis label font you specified isn\'t a GD Font object"}($h,$w)=($font->height,$font->width);if ($side eq 'left'){$x=$self->{'curr_x_min'}+ $self->{'text_space'}}elsif ($side eq 'right'){$x=$self->{'curr_x_max'}- $self->{'text_space'}- $h}$y=($self->{'curr_y_max'}- $self->{'curr_y_min'})/ 2 + $self->{'curr_y_min'}+ (length($label)* $w)/ 2;$self->{'gd_obj'}->stringUp($font,$x,$y,$label,$color);if ($side eq 'left'){$self->{'curr_x_min'}+= $h + 2 * $self->{'text_space'}}elsif ($side eq 'right'){$self->{'curr_x_max'}-= $h + 2 * $self->{'text_space'}}return 1}sub _draw_ticks {my$self=shift;if ($self->true($self->{'xy_plot'})&& ($self->isa('Chart::Lines')|| $self->isa('Chart::Points')|| $self->isa('Chart::LinesPoints')|| $self->isa('Chart::Split')|| $self->isa('Chart::ErrorBars'))){$self->_draw_x_number_ticks}else {$self->_draw_x_ticks}$self->_draw_y_ticks($self->{'y_axes'});return 1}sub _draw_x_number_ticks {my$self=shift;my$data=$self->{'dataref'};my$font=$self->{'tick_label_font'};my$textcolor=$self->_color_role_to_index('text');my$misccolor=$self->_color_role_to_index('misc');my ($h,$w,$x1,$y1,$y2,$x2,$delta,$width,$label);my@labels=@{$self->{'x_tick_labels'}};$self->{'grid_data'}->{'x'}=[];unless ((ref$font)eq 'GD::Font'){croak "The tick label font you specified isn't a GD font object"}($h,$w)=($font->height,$font->width);$self->{'temp_x_min'}=$self->{'curr_x_min'};$self->{'temp_x_max'}=$self->{'curr_x_max'};$self->{'temp_y_max'}=$self->{'curr_y_max'};$self->{'temp_y_min'}=$self->{'curr_y_min'};if ($self->{'y_axes'}=~ /^right$/i){$x1=$self->{'curr_x_min'};$width=$self->{'curr_x_max'}- $x1 - ($w * $self->{'y_tick_label_length'})- 3 * $self->{'text_space'}- $self->{'tick_len'}}elsif ($self->{'y_axes'}=~ /^both$/i){$x1=$self->{'curr_x_min'}+ ($w * $self->{'y_tick_label_length'})+ 3 * $self->{'text_space'}+ $self->{'tick_len'};$width=$self->{'curr_x_max'}- $x1 - ($w * $self->{'y_tick_label_length'})- (3 * $self->{'text_space'})- $self->{'tick_len'}}else {$x1=$self->{'curr_x_min'}+ ($w * $self->{'y_tick_label_length'})+ 3 * $self->{'text_space'}+ $self->{'tick_len'};$width=$self->{'curr_x_max'}- $x1}$delta=$width / ($self->{'x_number_ticks'}- 1);$y2=$y1;if ($self->{'x_ticks'}=~ /^normal/i){$y1=$self->{'curr_y_max'}- 2 * $self->{'text_space'}- $h - $self->{'tick_len'};$y2=$y1 + $self->{'tick_len'}+ $self->{'text_space'};if ($self->{'xlabels'}){unless ($self->{'xrange'}){croak "Base.pm: xrange must be specified with xlabels!\n"}my$xmin=$self->{'xrange'}[0];my$xmax=$self->{'xrange'}[1];my@labels=@{$self->{'xlabels'}[0]};my@vals=@{$self->{'xlabels'}[1]};my$delta=$width / ($xmax - $xmin);for (0 .. $#labels){my$label=$labels[$_];my$val=$vals[$_];$x2=$x1 + ($delta * ($val - $xmin))- (0.5 * $w * length($label));$self->{'gd_obj'}->string($font,$x2,$y2,$label,$textcolor)}}else {my$last_x='undefined';for (0 .. $#labels){$label=$self->{f_x_tick}->($self->{'x_tick_labels'}[$_]);$x2=$x1 + ($delta * $_)- (0.5 * $w * length($label));if ($last_x eq 'undefined' or $last_x < $x2){$self->{'gd_obj'}->string($font,$x2,$y2,$label,$textcolor);$last_x=$x2 + ($w * length($label))}}}}elsif ($self->{'x_ticks'}=~ /^staggered/i){$y1=$self->{'curr_y_max'}- 3 * $self->{'text_space'}- 2 * $h - $self->{'tick_len'};if ($self->{'xlabels'}){unless ($self->{'xrange'}){croak "Base.pm: xrange must be specified with xlabels!\n"}my$xmin=$self->{'xrange'}[0];my$xmax=$self->{'xrange'}[1];my@labels=@{$self->{'xlabels'}[0]};my@vals=@{$self->{'xlabels'}[1]};my$delta=$width / ($xmax - $xmin);for (0 .. $#labels){my$label=$labels[$_];my$val=$vals[$_];$x2=$x1 + ($delta * ($val - $xmin))- (0.5 * $w * length($label));unless ($_ % 2){$y2=$y1 + $self->{'text_space'}+ $self->{'tick_len'}}else {$y2=$y1 + $h + 2 * $self->{'text_space'}+ $self->{'tick_len'}}$self->{'gd_obj'}->string($font,$x2,$y2,$label,$textcolor)}}else {for (0 .. $#labels){$label=$self->{f_x_tick}->($self->{'x_tick_labels'}[$_]);$x2=$x1 + ($delta * $_)- (0.5 * $w * length($label));unless ($_ % 2){$y2=$y1 + $self->{'text_space'}+ $self->{'tick_len'}}else {$y2=$y1 + $h + 2 * $self->{'text_space'}+ $self->{'tick_len'}}$self->{'gd_obj'}->string($font,$x2,$y2,$label,$textcolor)}}}elsif ($self->{'x_ticks'}=~ /^vertical/i){$y1=$self->{'curr_y_max'}- 2 * $self->{'text_space'}- $w * $self->{'x_tick_label_length'}- $self->{'tick_len'};if ($self->{'xlabels'}){unless ($self->{'xrange'}){croak "Base.pm: xrange must be specified with xlabels!\n"}my$xmin=$self->{'xrange'}[0];my$xmax=$self->{'xrange'}[1];my@labels=@{$self->{'xlabels'}[0]};my@vals=@{$self->{'xlabels'}[1]};my$delta=$width / ($xmax - $xmin);for (0 .. $#labels){my$label=$labels[$_];my$val=$vals[$_];$y2=$y1 + $self->{'tick_len'}+ $w * length($label)+ $self->{'text_space'};$x2=$x1 + ($delta * ($val - $xmin))- ($h / 2);$self->{'gd_obj'}->stringUp($font,$x2,$y2,$label,$textcolor)}}else {for (0 .. $#labels){$label=$self->{f_x_tick}->($self->{'x_tick_labels'}[$_]);$y2=$y1 + $self->{'tick_len'}+ $w * length($label)+ $self->{'text_space'};$x2=$x1 + ($delta * $_)- ($h / 2);$self->{'gd_obj'}->stringUp($font,$x2,$y2,$label,$textcolor)}}}else {croak "I don't understand the type of x-ticks you specified\n" ."x-ticks must be one of 'normal', 'staggered' or 'vertical' but not of '" .$self->{'x_ticks'}."'."}$self->{'curr_y_max'}=$y1;$y1=$self->{'curr_y_max'};$y2=$self->{'curr_y_max'}+ $self->{'tick_len'};if ($self->{'xlabels'}){unless ($self->{'xrange'}){croak "Base.pm: xrange must be specified with xlabels!\n"}my$xmin=$self->{'xrange'}[0];my$xmax=$self->{'xrange'}[1];my@vals=@{$self->{'xlabels'}[1]};my$delta=$width / ($xmax - $xmin);for (0 .. $#vals){my$val=$vals[$_];$x2=($x1)+ ($delta * ($val - $xmin));$self->{'gd_obj'}->line($x2,$y1,$x2,$y2,$misccolor);if ($self->true($self->{'grid_lines'})or $self->true($self->{'x_grid_lines'})){$self->{'grid_data'}->{'x'}->[$_]=$x2}}}else {for (0 .. $#labels){$x2=$x1 + ($delta * $_);$self->{'gd_obj'}->line($x2,$y1,$x2,$y2,$misccolor);if (($self->true($self->{'grid_lines'}))or ($self->true($self->{'x_grid_lines'}))){$self->{'grid_data'}->{'x'}->[$_]=$x2}}}return 1}sub _draw_x_ticks {my$self=shift;my$data=$self->{'dataref'};my$font=$self->{'tick_label_font'};my$textcolor=$self->_color_role_to_index('text');my$misccolor=$self->_color_role_to_index('misc');my$label;my ($h,$w);my ($x1,$x2,$y1,$y2);my ($width,$delta);my ($stag);$self->{'grid_data'}->{'x'}=[];unless ((ref$font)eq 'GD::Font'){croak "The tick label font you specified isn\'t a GD Font object"}($h,$w)=($font->height,$font->width);$self->{'temp_x_min'}=$self->{'curr_x_min'};$self->{'temp_x_max'}=$self->{'curr_x_max'};$self->{'temp_y_min'}=$self->{'curr_y_min'};$self->{'temp_y_max'}=$self->{'curr_y_max'};if ($self->{'y_axes'}=~ /^right$/i){$x1=$self->{'curr_x_min'};$width=$self->{'curr_x_max'}- $x1 - ($w * $self->{'y_tick_label_length'})- 3 * $self->{'text_space'}- $self->{'tick_len'}}elsif ($self->{'y_axes'}=~ /^both$/i){$x1=$self->{'curr_x_min'}+ ($w * $self->{'y_tick_label_length'})+ 3 * $self->{'text_space'}+ $self->{'tick_len'};$width=$self->{'curr_x_max'}- $x1 - ($w * $self->{'y_tick_label_length'})- 3 * $self->{'text_space'}- $self->{'tick_len'}}else {$x1=$self->{'curr_x_min'}+ ($w * $self->{'y_tick_label_length'})+ 3 * $self->{'text_space'}+ $self->{'tick_len'};$width=$self->{'curr_x_max'}- $x1}$y1=$self->{'curr_y_max'}- $h - $self->{'text_space'};$delta=$width / ($self->{'num_datapoints'}> 0 ? $self->{'num_datapoints'}: 1);if (!defined($self->{'skip_x_ticks'})){$self->{'skip_x_ticks'}=1}elsif ($self->{'skip_x_ticks'}==0){$self->{'skip_x_ticks'}=1}if ($delta <= ($self->{'x_tick_label_length'}* $w)/ $self->{'skip_x_ticks'}){if ($self->{'x_ticks'}=~ /^normal$/i){$self->{'x_ticks'}='staggered'}}if ($self->{'x_ticks'}=~ /^normal$/i){if ($self->{'skip_x_ticks'}> 1){for (0 .. int(($self->{'num_datapoints'}- 1)/ $self->{'skip_x_ticks'})){if (defined($data->[0][$_ * $self->{'skip_x_ticks'}])){$label=$self->{f_x_tick}->($data->[0][$_ * $self->{'skip_x_ticks'}]);$x2=$x1 + ($delta / 2)+ ($delta * ($_ * $self->{'skip_x_ticks'}))- ($w * length($label))/ 2;$self->{'gd_obj'}->string($font,$x2,$y1,$label,$textcolor)}}}elsif ($self->{'custom_x_ticks'}){for (@{$self->{'custom_x_ticks'}}){if (defined($_)){$label=$self->{f_x_tick}->($data->[0][$_]);$x2=$x1 + ($delta / 2)+ ($delta * $_)- ($w * length($label))/ 2;$self->{'gd_obj'}->string($font,$x2,$y1,$label,$textcolor)}}}else {for (0 .. $self->{'num_datapoints'}- 1){if (defined($_)){$label=$self->{f_x_tick}->($data->[0][$_]);$x2=$x1 + ($delta / 2)+ ($delta * $_)- ($w * length($label))/ 2;$self->{'gd_obj'}->string($font,$x2,$y1,$label,$textcolor)}}}}elsif ($self->{'x_ticks'}=~ /^staggered$/i){if ($self->{'skip_x_ticks'}> 1){$stag=0;for (0 .. int(($self->{'num_datapoints'}- 1)/ $self->{'skip_x_ticks'})){if (defined($data->[0][$_ * $self->{'skip_x_ticks'}])){$x2=$x1 + ($delta / 2)+ ($delta * ($_ * $self->{'skip_x_ticks'}))- ($w * length($self->{f_x_tick}->($data->[0][$_ * $self->{'skip_x_ticks'}])))/ 2;if (($stag % 2)==1){$y1 -= $self->{'text_space'}+ $h}$self->{'gd_obj'}->string($font,$x2,$y1,$self->{f_x_tick}->($data->[0][$_ * $self->{'skip_x_ticks'}]),$textcolor);if (($stag % 2)==1){$y1 += $self->{'text_space'}+ $h}$stag++}}}elsif ($self->{'custom_x_ticks'}){$stag=0;for (sort (@{$self->{'custom_x_ticks'}})){if (defined($_)){$x2=$x1 + ($delta / 2)+ ($delta * $_)- ($w * length($self->{f_x_tick}->($data->[0][$_])))/ 2;if (($stag % 2)==1){$y1 -= $self->{'text_space'}+ $h}$self->{'gd_obj'}->string($font,$x2,$y1,$self->{f_x_tick}->($data->[0][$_]),$textcolor);if (($stag % 2)==1){$y1 += $self->{'text_space'}+ $h}$stag++}}}else {for (0 .. $self->{'num_datapoints'}- 1){if (defined($self->{f_x_tick}->($data->[0][$_]))){$x2=$x1 + ($delta / 2)+ ($delta * $_)- ($w * length($self->{f_x_tick}->($data->[0][$_])))/ 2;if (($_ % 2)==1){$y1 -= $self->{'text_space'}+ $h}$self->{'gd_obj'}->string($font,$x2,$y1,$self->{f_x_tick}->($data->[0][$_]),$textcolor);if (($_ % 2)==1){$y1 += $self->{'text_space'}+ $h}}}}}elsif ($self->{'x_ticks'}=~ /^vertical$/i){$y1=$self->{'curr_y_max'}- $self->{'text_space'};if ($self->{'skip_x_ticks'}> 1){for (0 .. int(($self->{'num_datapoints'}- 1)/ $self->{'skip_x_ticks'})){if (defined($_)){$x2=$x1 + ($delta / 2)+ ($delta * ($_ * $self->{'skip_x_ticks'}))- $h / 2;$y2=$y1 - (($self->{'x_tick_label_length'}- length($self->{f_x_tick}->($data->[0][$_ * $self->{'skip_x_ticks'}])))* $w);$self->{'gd_obj'}->stringUp($font,$x2,$y2,$self->{f_x_tick}->($data->[0][$_ * $self->{'skip_x_ticks'}]),$textcolor)}}}elsif ($self->{'custom_x_ticks'}){for (@{$self->{'custom_x_ticks'}}){if (defined($_)){$x2=$x1 + ($delta / 2)+ ($delta * $_)- $h / 2;$y2=$y1 - (($self->{'x_tick_label_length'}- length($self->{f_x_tick}->($data->[0][$_])))* $w);$self->{'gd_obj'}->stringUp($font,$x2,$y2,$self->{f_x_tick}->($data->[0][$_]),$textcolor)}}}else {for (0 .. $self->{'num_datapoints'}- 1){if (defined($_)){$x2=$x1 + ($delta / 2)+ ($delta * $_)- $h / 2;$y2=$y1 - (($self->{'x_tick_label_length'}- length($self->{f_x_tick}->($data->[0][$_])))* $w);$self->{'gd_obj'}->stringUp($font,$x2,$y2,$self->{f_x_tick}->($data->[0][$_]),$textcolor)}}}}else {carp "I don't understand the type of x-ticks you specified"}if ($self->{'x_ticks'}=~ /^normal$/i){$self->{'curr_y_max'}-= $h + (2 * $self->{'text_space'})}elsif ($self->{'x_ticks'}=~ /^staggered$/i){$self->{'curr_y_max'}-= (2 * $h)+ (3 * $self->{'text_space'})}elsif ($self->{'x_ticks'}=~ /^vertical$/i){$self->{'curr_y_max'}-= ($w * $self->{'x_tick_label_length'})+ (2 * $self->{'text_space'})}$y1=$self->{'curr_y_max'};$y2=$self->{'curr_y_max'}- $self->{'tick_len'};if ($self->{'skip_x_ticks'}> 1){for (0 .. int(($self->{'num_datapoints'}- 1)/ $self->{'skip_x_ticks'})){$x2=$x1 + ($delta / 2)+ ($delta * ($_ * $self->{'skip_x_ticks'}));$self->{'gd_obj'}->line($x2,$y1,$x2,$y2,$misccolor);if ($self->true($self->{'grid_lines'})or $self->true($self->{'x_grid_lines'})){$self->{'grid_data'}->{'x'}->[$_]=$x2}}}elsif ($self->{'custom_x_ticks'}){for (@{$self->{'custom_x_ticks'}}){$x2=$x1 + ($delta / 2)+ ($delta * $_);$self->{'gd_obj'}->line($x2,$y1,$x2,$y2,$misccolor);if ($self->true($self->{'grid_lines'})or $self->true($self->{'x_grid_lines'})){$self->{'grid_data'}->{'x'}->[$_]=$x2}}}else {for (0 .. $self->{'num_datapoints'}- 1){$x2=$x1 + ($delta / 2)+ ($delta * $_);$self->{'gd_obj'}->line($x2,$y1,$x2,$y2,$misccolor);if ($self->true($self->{'grid_lines'})or $self->true($self->{'x_grid_lines'})){$self->{'grid_data'}->{'x'}->[$_]=$x2}}}$self->{'curr_y_max'}-= $self->{'tick_len'}}sub _draw_y_ticks {my$self=shift;my$side=shift || 'left';my$data=$self->{'dataref'};my$font=$self->{'tick_label_font'};my$textcolor=$self->_color_role_to_index('text');my$misccolor=$self->_color_role_to_index('misc');my@labels=@{$self->{'y_tick_labels'}};my ($w,$h);my ($x1,$x2,$y1,$y2);my ($height,$delta,$label);my ($s,$f);$self->{grid_data}->{'y'}=[];$self->{grid_data}->{'y2'}=[];unless ((ref$font)eq 'GD::Font'){croak "The tick label font you specified isn\'t a GD Font object"}($w,$h)=($font->width,$font->height);if ($self->{'min_val'}>= 0){$s=1;$f=$#labels}elsif ($self->{'max_val'}<= 0){$s=0;$f=$#labels}else {$s=0;$f=$#labels}if ($side eq 'right'){$x1=$self->{'curr_x_max'}- $self->{'tick_len'}- (3 * $self->{'text_space'})- ($w * $self->{'y_tick_label_length'});$y1=$self->{'curr_y_max'};$height=$self->{'curr_y_max'}- $self->{'curr_y_min'};$self->{'y_ticks'}=2 if$self->{'y_ticks'}< 2;$delta=$height / ($self->{'y_ticks'}- 1);$self->{'curr_x_max'}=$x1;$x2=$x1 + $self->{'tick_len'};for ($s .. $f){$y2=$y1 - ($delta * $_);$self->{'gd_obj'}->line($x1,$y2,$x2,$y2,$misccolor);if ($self->true($self->{'grid_lines'})or $self->true($self->{'y2_grid_lines'})){$self->{'grid_data'}->{'y2'}->[$_]=$y2}}$x1 += $self->{'tick_len'}+ (2 * $self->{'text_space'});$y1 -= $h / 2;for (0 .. $#labels){$y2=$y1 - ($delta * $_);$self->{'gd_obj'}->string($font,$x1,$y2,$self->{'y_tick_labels'}[$_],$textcolor)}}elsif ($side eq 'both'){$x1=$self->{'curr_x_min'}+ $self->{'text_space'};$y1=$self->{'curr_y_max'}- $h / 2;$height=$self->{'curr_y_max'}- $self->{'curr_y_min'};$delta=$height / ($self->{'y_ticks'}- 1);for (0 .. $#labels){$label=$self->{'y_tick_labels'}[$_];$y2=$y1 - ($delta * $_);$x2=$x1 + ($w * $self->{'y_tick_label_length'})- ($w * length($label));$self->{'gd_obj'}->string($font,$x2,$y2,$label,$textcolor)}$self->{'curr_x_min'}+= (3 * $self->{'text_space'})+ ($w * $self->{'y_tick_label_length'});$x1=$self->{'curr_x_min'};$x2=$self->{'curr_x_min'}+ $self->{'tick_len'};$y1 += $h / 2;for ($s .. $f){$y2=$y1 - ($delta * $_);$self->{'gd_obj'}->line($x1,$y2,$x2,$y2,$misccolor);if ($self->true($self->{grid_lines})or $self->true($self->{'y_grid_lines'})){$self->{'grid_data'}->{'y'}->[$_]=$y2}}$self->{'curr_x_min'}+= $self->{'tick_len'};$x1=$self->{'curr_x_max'}- $self->{'tick_len'}- (3 * $self->{'text_space'})- ($w * $self->{'y_tick_label_length'});$y1=$self->{'curr_y_max'};$height=$self->{'curr_y_max'}- $self->{'curr_y_min'};$delta=$height / ($self->{'y_ticks'}- 1);$self->{'curr_x_max'}=$x1;$x2=$x1 + $self->{'tick_len'};for ($s .. $f){$y2=$y1 - ($delta * $_);$self->{'gd_obj'}->line($x1,$y2,$x2,$y2,$misccolor);if ($self->true($self->{grid_lines})or $self->true($self->{'y2_grid_lines'})){$self->{'grid_data'}->{'y2'}->[$_]=$y2}}$x1 += $self->{'tick_len'}+ (2 * $self->{'text_space'});$y1 -= $h / 2;for (0 .. $#labels){$y2=$y1 - ($delta * $_);$self->{'gd_obj'}->string($font,$x1,$y2,$self->{'y_tick_labels'}[$_],$textcolor)}}else {$x1=$self->{'curr_x_min'}+ $self->{'text_space'};$y1=$self->{'curr_y_max'}- $h / 2;$height=$self->{'curr_y_max'}- $self->{'curr_y_min'};$self->{'y_ticks'}=2 if$self->{'y_ticks'}< 2;$delta=$height / ($self->{'y_ticks'}- 1);for (0 .. $#labels){$label=$self->{'y_tick_labels'}[$_];$y2=$y1 - ($delta * $_);$x2=$x1 + ($w * $self->{'y_tick_label_length'})- ($w * length($label));$self->{'gd_obj'}->string($font,$x2,$y2,$label,$textcolor)}$self->{'curr_x_min'}+= (3 * $self->{'text_space'})+ ($w * $self->{'y_tick_label_length'});$x1=$self->{'curr_x_min'};$x2=$self->{'curr_x_min'}+ $self->{'tick_len'};$y1 += $h / 2;for ($s .. $f){$y2=$y1 - ($delta * $_);$self->{'gd_obj'}->line($x1,$y2,$x2,$y2,$misccolor);if ($self->true($self->{'grid_lines'})or $self->true($self->{'y_grid_lines'})){$self->{'grid_data'}->{'y'}->[$_]=$y2}}$self->{'curr_x_min'}+= $self->{'tick_len'}}return 1}sub _grey_background {my$self=shift;$self->{'gd_obj'}->filledRectangle($self->{'curr_x_min'},$self->{'curr_y_min'},$self->{'curr_x_max'},$self->{'curr_y_max'},$self->_color_role_to_index('grey_background'));return 1}sub _draw_grid_lines {my$self=shift;$self->_draw_x_grid_lines();$self->_draw_y_grid_lines();$self->_draw_y2_grid_lines();return 1}sub _draw_x_grid_lines {my$self=shift;my$grid_role=shift || 'x_grid_lines';my$gridcolor=$self->_color_role_to_index($grid_role);my ($x,$y,$i);for$x (@{$self->{grid_data}->{'x'}}){if (defined$x){$self->{gd_obj}->line(($x,$self->{'curr_y_min'}+ 1),$x,($self->{'curr_y_max'}- 1),$gridcolor)}}return 1}sub _draw_y_grid_lines {my$self=shift;my$grid_role=shift || 'y_grid_lines';my$gridcolor=$self->_color_role_to_index($grid_role);my ($x,$y,$i);if ($self->isa('Chart::HorizontalBars')){for ($i=0 ;$i < ($#{$self->{grid_data}->{'y'}})+ 1 ;$i++ ){$y=$self->{grid_data}->{'y'}->[$i];$self->{gd_obj}->line(($self->{'curr_x_min'}+ 1),$y,($self->{'curr_x_max'}- 1),$y,$gridcolor)}}else {for ($i=1 ;$i < ($#{$self->{grid_data}->{'y'}})+ 1 ;$i++ ){$y=$self->{grid_data}->{'y'}->[$i];$self->{gd_obj}->line(($self->{'curr_x_min'}+ 1),$y,($self->{'curr_x_max'}- 1),$y,$gridcolor)}}return 1}sub _draw_y2_grid_lines {my$self=shift;my$grid_role=shift || 'y2_grid_lines';my$gridcolor=$self->_color_role_to_index($grid_role);my ($x,$y,$i);if ($self->isa('Chart::HorizontalBars')){for ($i=0 ;$i < ($#{$self->{grid_data}->{'y'}})+ 1 ;$i++ ){$y=$self->{grid_data}->{'y'}->[$i];$self->{gd_obj}->line(($self->{'curr_x_min'}+ 1),$y,($self->{'curr_x_max'}- 1),$y,$gridcolor)}}else {for ($i=1 ;$i < $#{$self->{grid_data}->{'y2'}};$i++ ){$y=$self->{grid_data}->{'y2'}->[$i];$self->{gd_obj}->line(($self->{'curr_x_min'}+ 1),$y,($self->{'curr_x_max'}- 1),$y,$gridcolor)}}return 1}sub _prepare_brush {my$self=shift;my$color=shift;my$type=shift;my$role=shift || 'default';my$brushStyle=$self->{'brushStyle'};if (defined$role){my (@brushStyles)=$self->_brushStyles_of_roles($role);$brushStyle=$brushStyles[0]}if (!defined($type)){$type='point'}if ((!length($type))|| (!grep {$type eq $_}('line','point'))){$brushStyle=$self->{'brushStyle'};$type='line' if ref$self eq 'Chart::Lines';$type='point' if ref$self eq 'Chart::Points'}my ($radius,@rgb,$brush,$white,$newcolor);@rgb=$self->{'gd_obj'}->rgb($color);if ($type eq 'line'){$radius=$self->{'brush_size'}/ 2}elsif ($type eq 'point'){$radius=$self->{'pt_size'}/ 2}$brush=GD::Image->new($radius * 2,$radius * 2);$white=$brush->colorAllocate(255,255,255);$newcolor=$brush->colorAllocate(@rgb);$brush->transparent($white);if ($type eq 'line'){$brush->arc($radius - 1,$radius - 1,$radius,$radius,0,360,$newcolor);$brush->fill($radius - 1,$radius - 1,$newcolor)}if ($type eq 'point'){$brushStyle=$self->{'brushStyle'}unless grep {$brushStyle eq $_}('FilledCircle','circle','donut','OpenCircle','triangle','upsidedownTriangle','square','hollowSquare','OpenRectangle','fatPlus','Star','OpenStar','FilledDiamond','OpenDiamond');my ($xc,$yc)=($radius,$radius);if (grep {$brushStyle eq $_}('default','circle','donut','OpenCircle','FilledCircle')){$brush->arc($xc,$yc,$radius,$radius,0,360,$newcolor);$brush->fill($xc,$yc,$newcolor);if ($brushStyle eq 'donut' || $brushStyle eq 'OpenCircle'){$brush->arc($xc,$yc,int($radius / 2),int($radius / 2),0,360,$white);$brush->fill($xc,$yc,$white)}}if (grep {$brushStyle eq $_}('triangle','upsidedownTriangle')){my$poly=new GD::Polygon;my$sign=($brushStyle eq 'triangle')? 1 : (-1);my$z=int(0.8 * $radius);$poly->addPt($xc,$yc - ($z * $sign));$poly->addPt($xc + int((sqrt(3)* $z)/ 2),$yc + (int($z / 2)* $sign));$poly->addPt($xc - int((sqrt(3)* $z)/ 2),$yc + (int($z / 2)* $sign));$brush->filledPolygon($poly,$newcolor)}if ($brushStyle eq 'fatPlus'){my$poly=new GD::Polygon;my$z=int(0.3 * $radius);$poly->addPt($xc + $z,$yc + $z);$poly->addPt($xc + 2 * $z,$yc + $z);$poly->addPt($xc + 2 * $z,$yc - $z);$poly->addPt($xc + $z,$yc - $z);$poly->addPt($xc + $z,$yc - 2 * $z);$poly->addPt($xc - $z,$yc - 2 * $z);$poly->addPt($xc - $z,$yc - $z);$poly->addPt($xc - 2 * $z,$yc - $z);$poly->addPt($xc - 2 * $z,$yc + $z);$poly->addPt($xc - $z,$yc + $z);$poly->addPt($xc - $z,$yc + 2 * $z);$poly->addPt($xc + $z,$yc + 2 * $z);$brush->filledPolygon($poly,$newcolor)}if ($brushStyle eq 'Star' || $brushStyle eq 'OpenStar'){my$poly=new GD::Polygon;my$z=int($radius);my$sz=int($z / 3 * 1.75);my$x1=int($xc + $z);my$y1=int($yc);my ($x2,$y2);my$xyRatio=$self->_xyRatio();$poly->addPt($x1,$y1);$x2=$xc + int($sz * 0.5);$y2=$yc - int($sz * 0.5);$poly->addPt($x2,$y2);$x2=$xc;$y2=$yc - $z;$poly->addPt($x2,$y2);$x2=$xc - int($sz * 0.5);$y2=$yc - int($sz * 0.5);$poly->addPt($x2,$y2);$x2=$xc - $z;$y2=$yc;$poly->addPt($x2,$y2);$x2=$xc - int($sz * 0.5);$y2=$yc + int($sz * 0.5);$poly->addPt($x2,$y2);$x2=$xc;$y2=$yc + $z;$poly->addPt($x2,$y2);$x2=$xc + int($sz * 0.5);$y2=$yc + int($sz * 0.5);$poly->addPt($x2,$y2);if ($brushStyle eq 'OpenStar'){$brush->polygon($poly,$newcolor)}else {$brush->filledPolygon($poly,$newcolor)}}if (grep {$brushStyle eq $_}('square','hollowSquare','OpenRectangle')){my$z=int(0.5 * $radius);$brush->filledRectangle($xc - $z,$yc - $z,$xc + $z,$yc + $z,$newcolor);if ($brushStyle eq 'hollowSquare' || $brushStyle eq 'OpenRectangle'){$z=int($z / 2);$brush->filledRectangle($xc - $z,$yc - $z,$xc + $z,$yc + $z,$white)}}if (grep {$brushStyle eq $_}('FilledDiamond','OpenDiamond')){my$z=int(0.75 * $radius);$brush->line($xc + $z,$yc,$xc,$yc + $z,$newcolor);$brush->line($xc,$yc + $z,$xc - $z,$yc,$newcolor);$brush->line($xc - $z,$yc,$xc,$yc - $z,$newcolor);$brush->line($xc,$yc - $z,$xc + $z,$yc,$newcolor);if ($brushStyle eq 'FilledDiamond'){$brush->fill($radius - 1,$radius - 1,$newcolor)}}}return$brush}sub _default_f_tick {my$label=shift;return$label}sub _xyRatio {my$self=shift;my$width_x=$self->{'curr_x_max'}- $self->{'curr_x_min'}+ 1;my$width_y=$self->{'curr_y_max'}- $self->{'curr_y_min'}+ 1;my$ratio=$width_x / $width_y;return$ratio}sub _xPixelInReal {my$self=shift;my$width_x=$self->{'curr_x_max'}- $self->{'curr_x_min'}+ 1;my ($min,$max)=$self->_find_x_range();my$xRealWidth=$max - $min;my$ratio=$xRealWidth / $width_x;return$ratio}sub _yPixelInReal {my$self=shift;my$width_y=$self->{'curr_y_max'}- $self->{'curr_y_min'}+ 1;my ($min,$max,$flag_all_integers)=$self->_find_y_range();my$yRealWidth=$max - $min;my$ratio=$yRealWidth / $width_y;return$ratio}1;
CHART_BASE

$fatpacked{"Chart/BrushStyles.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CHART_BRUSHSTYLES';
  package Chart::BrushStyles;use Chart::Base '2.4.10';use GD;use Carp;use strict;use Chart::Constants;@Chart::BrushStyles::ISA=qw(Chart::Base);$Chart::BrushStyles::VERSION='2.4.10';sub OpenCircle {my$self=shift;my$rbrush=shift;my$radius=shift;my$color=shift;if ($radius < 2){$radius=2}$$rbrush->arc($radius,$radius,$radius,$radius,0,360,$color)}sub FilledCircle {my$self=shift;my$rbrush=shift;my$radius=shift;my$color=shift;if ($radius < 2){$radius=2}$$rbrush->arc($radius,$radius,$radius,$radius,0,360,$color);$$rbrush->fill($radius,$radius,$color)}sub Star {my$self=shift;my$rbrush=shift;my$radius=shift;my$color=shift;my$R=$self->maximum(2,int($radius + 0.5));my$r=$self->maximum(1,int($R / 3 + 0.5));my$lRadius=$R;my$x1=$lRadius + $R;my$y1=$R;my ($x2,$y2);for (my$iAngleCounter=1 ;$iAngleCounter < 16 ;$iAngleCounter++ ){my$phi=$iAngleCounter * Chart::Constants::PI / 8;$lRadius=(($iAngleCounter & 1)==0)? $R : $r;$x2=$lRadius * cos($phi);$y2=$lRadius * sin($phi);$x2 += $R;$y2 += $R;$$rbrush->line($x1,$y1,$x2,$y2,$color);$x1=$x2;$y1=$y2}$x2=$R + $R;$y2=$R;$$rbrush->line($x1,$y1,$x2,$y2,$color)}sub FilledDiamond {my$self=shift;my$rbrush=shift;my$radius=shift;my$color=shift;my$R=$self->maximum(2,int($radius + 0.5));my$R2=$R * 2;$$rbrush->line($R,1,$R2 - 1,$R,$color);$$rbrush->line($R2,$R,$R,$R2 - 1,$color);$$rbrush->line($R,$R2 - 1,1,$R,$color);$$rbrush->line(1,$R,$R,1,$color);$$rbrush->fill($radius - 1,$radius - 1,$color)}sub OpenDiamond {my$self=shift;my$rbrush=shift;my$radius=shift;my$color=shift;my$R=$self->maximum(2,int($radius + 0.5));my$R2=$R * 2;$$rbrush->line($R,1,$R2 - 1,$R,$color);$$rbrush->line($R2,$R,$R,$R2 - 1,$color);$$rbrush->line($R,$R2 - 1,1,$R,$color);$$rbrush->line(1,$R,$R,1,$color)}sub OpenRectangle {my$self=shift;my$rbrush=shift;my$radius=shift;my$color=shift;if ($radius < 2){$radius=2}my$height=$radius;my$width=$radius / 2;if ($width < 1){$width=1}$$rbrush->line(-$width,-$height,$width,-$height,$color)}1;
CHART_BRUSHSTYLES

$fatpacked{"Chart/Composite.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CHART_COMPOSITE';
  package Chart::Composite;use Chart::Base '2.4.10';use GD;use Carp;use strict;@Chart::Composite::ISA=qw(Chart::Base);$Chart::Composite::VERSION='2.4.10';sub set {my$self=shift;my%opts=@_;unless ($#_ % 2){carp "Whoops, some option to be set didn't have a value.\n","You might want to look at that.\n"}unless ($self->{'opts'}){$self->{'opts'}={}}for (keys%opts){$self->{$_}=$opts{$_};$self->{'opts'}{$_}=$opts{$_}}return}sub imagemap_dump {my$self=shift;my ($i,$j);my@map;my$dataset_count=0;unless (($self->true($self->{'imagemap'}))&& $self->{'imagemap_data'}){croak "You need to set the imagemap option to true, and then call the png method, before you can get the imagemap data"}for$i (1 .. $#{$self->{'sub_0'}->{'imagemap_data'}}){for$j (0 .. $#{$self->{'sub_0'}->{'imagemap_data'}->[$i]}){$map[$i][$j]=\@{$self->{'sub_0'}->{'imagemap_data'}->[$i][$j]}}$dataset_count++}for$i (1 .. $#{$self->{'sub_1'}->{'imagemap_data'}}){for$j (0 .. $#{$self->{'sub_1'}->{'imagemap_data'}->[$i]}){$map[$i + $dataset_count ][$j]=\@{$self->{'sub_1'}->{'imagemap_data'}->[$i][$j]}}}return \@map}sub __print_array {my@a=@_;my$i;my$li=$#a;$li++;print STDERR "Anzahl der Elemente = $li\n";$li--;for ($i=0 ;$i <= $li ;$i++ ){print STDERR "\t$i\t$a[$i]\n"}}sub _check_data {my$self=shift;my$length=0;unless (($self->{'composite_info'})&& ($#{$self->{'composite_info'}}==1)){croak "Chart::Composite needs to be told what kind of components to use"}if ($self->{'y_ticks'}==1){$self->{'y_ticks'}=2;carp "The number of y_ticks displayed must be at least 2"}$self->{'num_datasets'}=$#{$self->{'dataref'}};$self->{'num_datapoints'}=0;for (0 .. $self->{'num_datasets'}){if (scalar(@{$self->{'dataref'}[$_]})> $self->{'num_datapoints'}){$self->{'num_datapoints'}=scalar(@{$self->{'dataref'}[$_]})}}for (@{$self->{'dataref'}[0]}){if (length($_)> $length){$length=length($_)}}$self->{'x_tick_label_length'}=$length;$self->_split_data;return}sub _split_data {my$self=shift;my@types=($self->{'composite_info'}[0][0],$self->{'composite_info'}[1][0]);my ($ref,$i,$j);require "Chart/" .$types[0].".pm";require "Chart/" .$types[1].".pm";$self->{'sub_0'}=("Chart::" .$types[0])->new();$self->{'sub_1'}=("Chart::" .$types[1])->new();$self->{'sub_0'}->set(%{$self->{'opts'}});$self->{'sub_1'}->set(%{$self->{'opts'}});if (defined($self->{'opts'}{'min_val1'})){$self->{'sub_0'}->set('min_val'=>$self->{'opts'}{'min_val1'})}if (defined($self->{'opts'}{'max_val1'})){$self->{'sub_0'}->set('max_val'=>$self->{'opts'}{'max_val1'})}if (defined($self->{'opts'}{'min_val2'})){$self->{'sub_1'}->set('min_val'=>$self->{'opts'}{'min_val2'})}if (defined($self->{'opts'}{'max_val2'})){$self->{'sub_1'}->set('max_val'=>$self->{'opts'}{'max_val2'})}if ($self->{'opts'}{'y_ticks1'}){$self->{'sub_0'}->set('y_ticks'=>$self->{'opts'}{'y_ticks1'})}if ($self->{'opts'}{'y_ticks2'}){$self->{'sub_1'}->set('y_ticks'=>$self->{'opts'}{'y_ticks2'})}if ($self->{'opts'}{'brush_size1'}){$self->{'sub_0'}->set('brush_size'=>$self->{'opts'}{'brush_size1'})}if ($self->{'opts'}{'brush_size2'}){$self->{'sub_1'}->set('brush_size'=>$self->{'opts'}{'brush_size2'})}if ($self->{'opts'}{'brushStyle1'}){$self->{'sub_0'}->set('brushStyle'=>$self->{'opts'}{'brushStyle1'})}if ($self->{'opts'}{'brushStyle2'}){$self->{'sub_1'}->set('brushStyle'=>$self->{'opts'}{'brushStyle2'})}if (defined($self->{'opts'}{'f_y_tick1'})){$self->{'sub_0'}->set('f_y_tick'=>$self->{'opts'}{'f_y_tick1'})}if (defined($self->{'opts'}{'f_y_tick2'})){$self->{'sub_1'}->set('f_y_tick'=>$self->{'opts'}{'f_y_tick2'})}$self->{'sub_0'}->{'gd_obj'}=$self->{'gd_obj'};$self->{'sub_1'}->{'gd_obj'}=$self->{'gd_obj'};$self->{'sub_0'}->{'component'}='true';$self->{'sub_1'}->{'component'}='true';$self->{'component_datasets'}=[];for$i (0 .. 1){$ref=[];$self->{'component_datasets'}[$i]=$self->{'composite_info'}[$i][1];push @{$ref},$self->{'dataref'}[0];for$j (@{$self->{'composite_info'}[$i][1]}){$self->_color_role_to_index('dataset' .($j - 1));push @{$ref},$self->{'dataref'}[$j]}$self->{'sub_' .$i }->_copy_data($ref)}$self->{'sub_0'}->_check_data;$self->{'sub_1'}->_check_data;if ($self->true($self->{'same_y_axes'})){if ($self->{'sub_0'}{'min_val'}< $self->{'sub_1'}{'min_val'}){$self->{'sub_1'}{'min_val'}=$self->{'sub_0'}{'min_val'}}else {$self->{'sub_0'}{'min_val'}=$self->{'sub_1'}{'min_val'}}if ($self->{'sub_0'}{'max_val'}> $self->{'sub_1'}{'max_val'}){$self->{'sub_1'}{'max_val'}=$self->{'sub_0'}{'max_val'}}else {$self->{'sub_0'}{'max_val'}=$self->{'sub_1'}{'max_val'}}$self->{'sub_0'}->_check_data;$self->{'sub_1'}->_check_data}$self->{'y_tick_label_length1'}=$self->{'sub_0'}->{'y_tick_label_length'};$self->{'y_tick_label_length2'}=$self->{'sub_1'}->{'y_tick_label_length'};return}sub _draw_legend {my$self=shift;my ($length);if (($#{$self->{'legend_labels'}}>= 0)&& ((scalar(@{$self->{'legend_labels'}}))!=$self->{'num_datasets'})){carp "The number of legend labels and datasets doesn\'t match"}unless ($self->{'max_legend_label'}){$self->{'max_legend_label'}=0}for (1 .. $self->{'num_datasets'}){unless ($self->{'legend_labels'}[$_ - 1 ]){$self->{'legend_labels'}[$_ - 1 ]="Dataset $_"}$length=length($self->{'legend_labels'}[$_ - 1 ]);if ($length > $self->{'max_legend_label'}){$self->{'max_legend_label'}=$length}}if ($self->{'legend'}eq 'bottom'){$self->_draw_bottom_legend}elsif ($self->{'legend'}eq 'right'){$self->_draw_right_legend}elsif ($self->{'legend'}eq 'left'){$self->_draw_left_legend}elsif ($self->{'legend'}eq 'top'){$self->_draw_top_legend}elsif ($self->{'legend'}eq 'none'){$self->_draw_none_legend}else {carp "I can't put a legend there\n"}return 1}sub _draw_top_legend {my$self=shift;my@labels=@{$self->{'legend_labels'}};my ($x1,$y1,$x2,$y2,$empty_width,$max_label_width);my ($cols,$rows,$color);my ($col_width,$row_height,$i,$j,$r,$c,$index,$x,$y,$sub,$w,$h);my ($yh,$yi);my$font=$self->{'legend_font'};my (%colors,@datasets);my$max_legend_example=0;$yh=0;$self->_sub_update;$self->_legend_example_height_init;my ($n0,$n1)=map {scalar @{$self->{'composite_info'}[$_][1]}}0 .. 1;for (0 .. $n1 - 1){$self->{'sub_1'}{'color_table'}{'dataset' .$_ }=$self->{'color_table'}{'dataset' .($_ + $n0)}}@datasets=@{$self->{'composite_info'}[0][1]};$i=0;for (0 .. $#datasets){$colors{$datasets[$_]- 1 }=$self->{'color_table'}{'dataset' .($i)};$i++}@datasets=@{$self->{'composite_info'}[1][1]};$i=0;for (0 .. $#datasets){$colors{$datasets[$_]- 1 }=$self->{'color_table'}{'dataset' .($i + $n0)};$i++}unless ((ref($font))eq 'GD::Font'){croak "The subtitle font you specified isn\'t a GD Font object"}($h,$w)=($font->height,$font->width);$x1=$self->{'curr_x_min'}+ $self->{'graph_border'}+ $self->{'y_tick_label_length1'}* $self->{'tick_label_font'}->width + $self->{'tick_len'}+ (3 * $self->{'text_space'});$x2=$self->{'curr_x_max'}- $self->{'graph_border'}- $self->{'y_tick_label_length2'}* $self->{'tick_label_font'}->width - $self->{'tick_len'}- (3 * $self->{'text_space'});if ($self->{'y_label'}){$x1 += $self->{'label_font'}->height + 2 * $self->{'text_space'}}if ($self->{'y_label2'}){$x2 -= $self->{'label_font'}->height + 2 * $self->{'text_space'}}$empty_width=$x2 - $x1 - (2 * $self->{'legend_space'});$max_label_width=$self->{'max_legend_label'}* $self->{'legend_font'}->width + 4 * $self->{'text_space'}+ $self->{'legend_example_size'};$cols=int($empty_width / $max_label_width);unless ($cols){$cols=1}$col_width=$empty_width / $cols;$rows=int($self->{'num_datasets'}/ $cols);unless (($self->{'num_datasets'}% $cols)==0){$rows++}unless ($rows){$rows=1}$row_height=$h + $self->{'text_space'};$y1=$self->{'curr_y_min'};$y2=$self->{'curr_y_min'}+ $self->{'text_space'}+ ($rows * $row_height)+ (2 * $self->{'legend_space'});$self->{'gd_obj'}->rectangle($x1,$y1,$x2,$y2,$self->_color_role_to_index('misc'));$max_legend_example=$y2 - $y1;$x1 += $self->{'legend_space'}+ $self->{'text_space'};$x2 -= $self->{'legend_space'};$y1 += $self->{'legend_space'}+ $self->{'text_space'};$y2 -= $self->{'legend_space'}+ $self->{'text_space'};$r=0;$c=0;$yi=0;for$i (0 .. 1){for$j (0 .. $#{$self->{'component_datasets'}[$i]}){$color=$self->{'sub_' .$i }->{'color_table'}{'dataset' .$j };$index=$self->{'component_datasets'}[$i][$j]- 1;$x=$x1 + ($col_width * $c);$y=$y1 + ($row_height * $r)+ $h / 2;if ($rows==1){if ($self->{'legend_example_height' .$yi }< $max_legend_example){$yh=$self->{'legend_example_height' .$yi }}else {$yh=$max_legend_example}}else {if ($self->{'legend_example_height' .$yi }< $row_height){$yh=$self->{'legend_example_height' .$yi }}else {$yh=$row_height}}$yi++;if ($yh <= 1){$self->{'gd_obj'}->line($x,$y,$x + $self->{'legend_example_size'},$y,$color)}else {$yh=int($yh / 2);$self->{'gd_obj'}->filledRectangle($x,$y - $yh,$x + $self->{'legend_example_size'},$y + $yh,$color)}$x += $self->{'legend_example_size'}+ 2 * $self->{'text_space'};$y -= $h / 2;$self->{'gd_obj'}->string($font,$x,$y,$labels[$index],$color);$r=($r + 1)% $rows;if ($r==0){$c++}}}$self->{'curr_y_min'}+= $rows * $row_height + $self->{'text_space'}+ 2 * $self->{'legend_space'};return}sub _draw_right_legend {my$self=shift;my@labels=@{$self->{'legend_labels'}};my ($x1,$x2,$x3,$y1,$y2,$width,$color,$misccolor,$w,$h);my ($yh)=0;my$font=$self->{'legend_font'};my (%colors,@datasets,$i);my$max_legend_example=0;$self->_sub_update;$self->_legend_example_height_init;my ($n0,$n1)=map {scalar @{$self->{'composite_info'}[$_][1]}}0 .. 1;for (0 .. $n1 - 1){$self->{'sub_1'}{'color_table'}{'dataset' .$_ }=$self->{'color_table'}{'dataset' .($_ + $n0)}}@datasets=@{$self->{'composite_info'}[0][1]};$i=0;for (0 .. $#datasets){$colors{$datasets[$_]- 1 }=$self->{'color_table'}{'dataset' .($_)};$i++}@datasets=@{$self->{'composite_info'}[1][1]};$i=0;for (0 .. $#datasets){$colors{$datasets[$_]- 1 }=$self->{'color_table'}{'dataset' .($i + $n0)};$i++}unless ((ref($font))eq 'GD::Font'){croak "The subtitle font you specified isn\'t a GD Font object"}($h,$w)=($font->height,$font->width);$misccolor=$self->_color_role_to_index('misc');$width=(2 * $self->{'text_space'})+ ($self->{'max_legend_label'}* $w)+ $self->{'legend_example_size'}+ (2 * $self->{'legend_space'});$x1=$self->{'curr_x_max'}- $width;$x2=$self->{'curr_x_max'};$y1=$self->{'curr_y_min'}+ $self->{'graph_border'};$y2=$self->{'curr_y_min'}+ $self->{'graph_border'}+ $self->{'text_space'}+ ($self->{'num_datasets'}* ($h + $self->{'text_space'}))+ (2 * $self->{'legend_space'});$self->{'gd_obj'}->rectangle($x1,$y1,$x2,$y2,$misccolor);$x1 += $self->{'legend_space'};$y1 += $self->{'legend_space'}+ $self->{'text_space'};for (0 .. $#labels){$color=$colors{$_};$max_legend_example=$self->{'legend_space'}+ $h;$x2=$x1;$x3=$x2 + $self->{'legend_example_size'};$y2=$y1 + ($_ * ($self->{'text_space'}+ $h))+ $h / 2;if ($self->{'legend_example_height' .$_ }< $max_legend_example){$yh=$self->{'legend_example_height' .$_ }}else {$yh=$max_legend_example}if ($yh <= 1){$self->{'gd_obj'}->line($x2,$y2,$x3,$y2,$color)}else {$yh=int($yh / 2);$self->{'gd_obj'}->filledRectangle($x2,$y2 - $yh,$x3,$y2 + $yh,$color)}$x2=$x3 + (2 * $self->{'text_space'});$y2 -= $h / 2;$self->{'gd_obj'}->string($font,$x2,$y2,$labels[$_],$color)}$self->{'curr_x_max'}-= $width;return}sub _draw_left_legend {my$self=shift;my@labels=@{$self->{'legend_labels'}};my ($x1,$x2,$x3,$y1,$y2,$width,$color,$misccolor,$w,$h);my$yh;my$font=$self->{'legend_font'};my (%colors,@datasets,$i);my$max_legend_example=0;$self->_sub_update;$self->_legend_example_height_init;my ($n0,$n1)=map {scalar @{$self->{'composite_info'}[$_][1]}}0 .. 1;for (0 .. $n1 - 1){$self->{'sub_1'}{'color_table'}{'dataset' .$_ }=$self->{'color_table'}{'dataset' .($_ + $n0)}}@datasets=@{$self->{'composite_info'}[0][1]};$i=0;for (0 .. $#datasets){$colors{$datasets[$_]- 1 }=$self->{'color_table'}{'dataset' .($i)};$i++}@datasets=@{$self->{'composite_info'}[1][1]};$i=0;for (0 .. $#datasets){$colors{$datasets[$_]- 1 }=$self->{'color_table'}{'dataset' .($i + $n0)};$i++}unless ((ref($font))eq 'GD::Font'){croak "The subtitle font you specified isn\'t a GD Font object"}($h,$w)=($font->height,$font->width);$misccolor=$self->_color_role_to_index('misc');$width=(2 * $self->{'text_space'})+ ($self->{'max_legend_label'}* $w)+ $self->{'legend_example_size'}+ (2 * $self->{'legend_space'});$x1=$self->{'curr_x_min'};$x2=$self->{'curr_x_min'}+ $width;$y1=$self->{'curr_y_min'}+ $self->{'graph_border'};$y2=$self->{'curr_y_min'}+ $self->{'graph_border'}+ $self->{'text_space'}+ ($self->{'num_datasets'}* ($h + $self->{'text_space'}))+ (2 * $self->{'legend_space'});$self->{'gd_obj'}->rectangle($x1,$y1,$x2,$y2,$misccolor);$x1 += $self->{'legend_space'};$y1 += $self->{'legend_space'}+ $self->{'text_space'};for (0 .. $#labels){$color=$colors{$_};$max_legend_example=$self->{'legend_space'}+ $h;$x2=$x1;$x3=$x2 + $self->{'legend_example_size'};$y2=$y1 + ($_ * ($self->{'text_space'}+ $h))+ $h / 2;if ($self->{'legend_example_height' .$_ }< $max_legend_example){$yh=$self->{'legend_example_height' .$_ }}else {$yh=$max_legend_example}if ($yh <= 1){$self->{'gd_obj'}->line($x2,$y2,$x3,$y2,$color)}else {$yh=int($yh / 2);$self->{'gd_obj'}->filledRectangle($x2,$y2 - $yh,$x3,$y2 + $yh,$color)}$x2=$x3 + (2 * $self->{'text_space'});$y2 -= $h / 2;$self->{'gd_obj'}->string($font,$x2,$y2,$labels[$_],$color)}$self->{'curr_x_min'}+= $width;return 1}sub _draw_bottom_legend {my$self=shift;my@labels=@{$self->{'legend_labels'}};my ($x1,$y1,$x2,$y2,$empty_width,$max_label_width,$cols,$rows,$color);my ($col_width,$row_height,$i,$j,$r,$c,$index,$x,$y,$sub,$w,$h);my ($yh,$yi);my$font=$self->{'legend_font'};my (%colors,@datasets);my$max_legend_example=0;$yh=0;$self->_sub_update;$self->_legend_example_height_init;my ($n0,$n1)=map {scalar @{$self->{'composite_info'}[$_][1]}}0 .. 1;for (0 .. $n1 - 1){$self->{'sub_1'}{'color_table'}{'dataset' .$_ }=$self->{'color_table'}{'dataset' .($_ + $n0)}}@datasets=@{$self->{'composite_info'}[0][1]};$i=0;for (0 .. $#datasets){$colors{$datasets[$_]- 1 }=$self->{'color_table'}{'dataset' .($i)};$i++}@datasets=@{$self->{'composite_info'}[1][1]};$i=0;for (0 .. $#datasets){$colors{$datasets[$_]- 1 }=$self->{'color_table'}{'dataset' .($i + $n0)};$i++}unless ((ref($font))eq 'GD::Font'){croak "The subtitle font you specified isn\'t a GD Font object"}($h,$w)=($font->height,$font->width);$x1=$self->{'curr_x_min'}+ $self->{'graph_border'}+ $self->{'y_tick_label_length1'}* $self->{'tick_label_font'}->width + $self->{'tick_len'}+ (3 * $self->{'text_space'});$x2=$self->{'curr_x_max'}- $self->{'graph_border'}- $self->{'y_tick_label_length2'}* $self->{'tick_label_font'}->width - $self->{'tick_len'}- (3 * $self->{'text_space'});if ($self->{'y_label'}){$x1 += $self->{'label_font'}->height + 2 * $self->{'text_space'}}if ($self->{'y_label2'}){$x2 -= $self->{'label_font'}->height + 2 * $self->{'text_space'}}$empty_width=$x2 - $x1 - (2 * $self->{'legend_space'});$max_label_width=$self->{'max_legend_label'}* $self->{'legend_font'}->width + 4 * $self->{'text_space'}+ $self->{'legend_example_size'};$cols=int($empty_width / $max_label_width);unless ($cols){$cols=1}$col_width=$empty_width / $cols;$rows=int($self->{'num_datasets'}/ $cols);unless (($self->{'num_datasets'}% $cols)==0){$rows++}unless ($rows){$rows=1}$row_height=$h + $self->{'text_space'};$y1=$self->{'curr_y_max'}- $self->{'text_space'}- ($rows * $row_height)- (2 * $self->{'legend_space'});$y2=$self->{'curr_y_max'};$self->{'gd_obj'}->rectangle($x1,$y1,$x2,$y2,$self->_color_role_to_index('misc'));$max_legend_example=$y2 - $y1;$x1 += $self->{'legend_space'}+ $self->{'text_space'};$x2 -= $self->{'legend_space'};$y1 += $self->{'legend_space'}+ $self->{'text_space'};$y2 -= $self->{'legend_space'}+ $self->{'text_space'};$r=0;$c=0;$yi=0;for$i (0 .. 1){for$j (0 .. $#{$self->{'component_datasets'}[$i]}){$color=$self->{'sub_' .$i }->{'color_table'}{'dataset' .$j };$index=$self->{'component_datasets'}[$i][$j]- 1;$x=$x1 + ($col_width * $c);$y=$y1 + ($row_height * $r)+ $h / 2;if ($rows==1){if ($self->{'legend_example_height' .$yi }< $max_legend_example){$yh=$self->{'legend_example_height' .$yi }}else {$yh=$max_legend_example}}else {if ($self->{'legend_example_height' .$yi }< $row_height){$yh=$self->{'legend_example_height' .$yi }}else {$yh=$row_height}}$yi++;if ($yh <= 1){$self->{'gd_obj'}->line($x,$y,$x + $self->{'legend_example_size'},$y,$color)}else {$yh=int($yh / 2);$self->{'gd_obj'}->filledRectangle($x,$y - $yh,$x + $self->{'legend_example_size'},$y + $yh,$color)}$x += $self->{'legend_example_size'}+ 2 * $self->{'text_space'};$y -= $h / 2;$self->{'gd_obj'}->string($font,$x,$y,$labels[$index],$color);$r=($r + 1)% $rows;if ($r==0){$c++}}}$self->{'curr_y_max'}-= ($rows * $row_height)+ 2 * $self->{'text_space'}+ 2 * $self->{'legend_space'};return}sub _draw_none_legend {my$self=shift;my$status=1;$self->_sub_update();my ($n0,$n1)=map {scalar @{$self->{'composite_info'}[$_][1]}}0 .. 1;for (0 .. $n1 - 1){$self->{'sub_1'}{'color_table'}{'dataset' .$_ }=$self->{'color_table'}{'dataset' .($_ + $n0)}}return$status}sub _draw_ticks {my$self=shift;if ($self->true($self->{'xy_plot'})){$self->_find_x_scale;$self->{'y_tick_label_length'}=$self->{'y_tick_label_length1'};$self->_draw_x_number_ticks}else {$self->_draw_x_ticks}$self->_boundary_update($self,$self->{'sub_0'});$self->_boundary_update($self,$self->{'sub_1'});$self->_draw_y_ticks;return}sub _draw_x_ticks {my$self=shift;my$data=$self->{'dataref'};my$font=$self->{'tick_label_font'};my$textcolor=$self->_color_role_to_index('text');my$misccolor=$self->_color_role_to_index('misc');my ($h,$w);my ($x1,$x2,$y1,$y2);my ($width,$delta);my ($stag);$self->{'grid_data'}->{'x'}=[];unless ((ref$font)eq 'GD::Font'){croak "The tick label font you specified isn\'t a GD Font object"}($h,$w)=($font->height,$font->width);$x1=$self->{'curr_x_min'}+ ($w * $self->{'y_tick_label_length1'})+ (3 * $self->{'text_space'})+ $self->{'tick_len'};$x2=$self->{'curr_x_max'}- ($w * $self->{'y_tick_label_length2'})- (3 * $self->{'text_space'})- $self->{'tick_len'};$y1=$self->{'curr_y_max'}- $h - $self->{'text_space'};$width=$x2 - $x1;$delta=$width / ($self->{'num_datapoints'}> 0 ? $self->{'num_datapoints'}: 1);if ($delta <= ($self->{'x_tick_label_length'}* $w)){unless ($self->{'x_ticks'}=~ /^vertical$/i){$self->{'x_ticks'}='staggered'}}if ($self->{'x_ticks'}=~ /^normal$/i){if ($self->{'skip_x_ticks'}){for (0 .. int(($self->{'num_datapoints'}- 1)/ $self->{'skip_x_ticks'})){$x2=$x1 + ($delta / 2)+ ($delta * ($_ * $self->{'skip_x_ticks'}))- ($w * length($self->{'f_x_tick'}->($data->[0][$_ * $self->{'skip_x_ticks'}])))/ 2;$self->{'gd_obj'}->string($font,$x2,$y1,$self->{'f_x_tick'}->($data->[0][$_ * $self->{'skip_x_ticks'}]),$textcolor)}}elsif ($self->{'custom_x_ticks'}){for (@{$self->{'custom_x_ticks'}}){$x2=$x1 + ($delta / 2)+ ($delta * $_)- ($w * length($self->{'f_x_tick'}->($data->[0][$_])))/ 2;$self->{'gd_obj'}->string($font,$x2,$y1,$self->{'f_x_tick'}->($data->[0][$_]),$textcolor)}}else {for (0 .. $self->{'num_datapoints'}- 1){$x2=$x1 + ($delta / 2)+ ($delta * $_)- ($w * length($self->{'f_x_tick'}->($data->[0][$_])))/ 2;$self->{'gd_obj'}->string($font,$x2,$y1,$self->{'f_x_tick'}->($data->[0][$_]),$textcolor)}}}elsif ($self->{'x_ticks'}=~ /^staggered$/i){if ($self->{'skip_x_ticks'}){$stag=0;for (0 .. int(($self->{'num_datapoints'}- 1)/ $self->{'skip_x_ticks'})){$x2=$x1 + ($delta / 2)+ ($delta * ($_ * $self->{'skip_x_ticks'}))- ($w * length($self->{'f_x_tick'}->($data->[0][$_ * $self->{'skip_x_ticks'}])))/ 2;if (($stag % 2)==1){$y1 -= $self->{'text_space'}+ $h}$self->{'gd_obj'}->string($font,$x2,$y1,$self->{'f_x_tick'}->($data->[0][$_ * $self->{'skip_x_ticks'}]),$textcolor);if (($stag % 2)==1){$y1 += $self->{'text_space'}+ $h}$stag++}}elsif ($self->{'custom_x_ticks'}){$stag=0;for (sort (@{$self->{'custom_x_ticks'}})){$x2=$x1 + ($delta / 2)+ ($delta * $_)- ($w * length($self->{'f_x_tick'}->($data->[0][$_])))/ 2;if (($stag % 2)==1){$y1 -= $self->{'text_space'}+ $h}$self->{'gd_obj'}->string($font,$x2,$y1,$self->{'f_x_tick'}->($data->[0][$_]),$textcolor);if (($stag % 2)==1){$y1 += $self->{'text_space'}+ $h}$stag++}}else {for (0 .. $self->{'num_datapoints'}- 1){$x2=$x1 + ($delta / 2)+ ($delta * $_)- ($w * length($self->{'f_x_tick'}->($data->[0][$_])))/ 2;if (($_ % 2)==1){$y1 -= $self->{'text_space'}+ $h}$self->{'gd_obj'}->string($font,$x2,$y1,$self->{'f_x_tick'}->($data->[0][$_]),$textcolor);if (($_ % 2)==1){$y1 += $self->{'text_space'}+ $h}}}}elsif ($self->{'x_ticks'}=~ /^vertical$/i){$y1=$self->{'curr_y_max'}- $self->{'text_space'};if (defined($self->{'skip_x_ticks'})&& $self->{'skip_x_ticks'}> 1){for (0 .. int(($self->{'num_datapoints'}- 1)/ $self->{'skip_x_ticks'})){$x2=$x1 + ($delta / 2)+ ($delta * ($_ * $self->{'skip_x_ticks'}))- $h / 2;$y2=$y1 - (($self->{'x_tick_label_length'}- length($self->{'f_x_tick'}->($data->[0][$_ * $self->{'skip_x_ticks'}])))* $w);$self->{'gd_obj'}->stringUp($font,$x2,$y2,$self->{'f_x_tick'}->($data->[0][$_ * $self->{'skip_x_ticks'}]),$textcolor)}}elsif ($self->{'custom_x_ticks'}){for (@{$self->{'custom_x_ticks'}}){$x2=$x1 + ($delta / 2)+ ($delta * $_)- $h / 2;$y2=$y1 - (($self->{'x_tick_label_length'}- length($self->{'f_x_tick'}->($data->[0][$_])))* $w);$self->{'gd_obj'}->stringUp($font,$x2,$y2,$self->{'f_x_tick'}->($data->[0][$_]),$textcolor)}}else {for (0 .. $self->{'num_datapoints'}- 1){$x2=$x1 + ($delta / 2)+ ($delta * $_)- $h / 2;$y2=$y1 - (($self->{'x_tick_label_length'}- length($self->{'f_x_tick'}->($data->[0][$_])))* $w);$self->{'gd_obj'}->stringUp($font,$x2,$y2,$self->{'f_x_tick'}->($data->[0][$_]),$textcolor)}}}else {carp "I don't understand the type of x-ticks you specified"}if ($self->{'x_ticks'}=~ /^normal$/i){$self->{'curr_y_max'}-= $h + (2 * $self->{'text_space'})}elsif ($self->{'x_ticks'}=~ /^staggered$/i){$self->{'curr_y_max'}-= (2 * $h)+ (3 * $self->{'text_space'})}elsif ($self->{'x_ticks'}=~ /^vertical$/i){$self->{'curr_y_max'}-= ($w * $self->{'x_tick_label_length'})+ (2 * $self->{'text_space'})}$y1=$self->{'curr_y_max'};$y2=$self->{'curr_y_max'}- $self->{'tick_len'};if ($self->{'skip_x_ticks'}){for (0 .. int(($self->{'num_datapoints'}- 1)/ $self->{'skip_x_ticks'})){$x2=$x1 + ($delta / 2)+ ($delta * ($_ * $self->{'skip_x_ticks'}));$self->{'gd_obj'}->line($x2,$y1,$x2,$y2,$misccolor);if ($self->true($self->{'grid_lines'})or $self->true($self->{'x_grid_lines'})){$self->{'grid_data'}->{'x'}->[$_]=$x2}}}elsif ($self->{'custom_x_ticks'}){for (@{$self->{'custom_x_ticks'}}){$x2=$x1 + ($delta / 2)+ ($delta * $_);$self->{'gd_obj'}->line($x2,$y1,$x2,$y2,$misccolor);if ($self->true($self->{'grid_lines'})or $self->true($self->{'x_grid_lines'})){$self->{'grid_data'}->{'x'}->[$_]=$x2}}}else {for (0 .. $self->{'num_datapoints'}- 1){$x2=$x1 + ($delta / 2)+ ($delta * $_);$self->{'gd_obj'}->line($x2,$y1,$x2,$y2,$misccolor);if ($self->true($self->{'grid_lines'})or $self->true($self->{'x_grid_lines'})){$self->{'grid_data'}->{'x'}->[$_]=$x2}}}$self->{'curr_y_max'}-= $self->{'tick_len'};return}sub _draw_y_ticks {my$self=shift;$self->{'sub_0'}->_draw_y_ticks('left');$self->_boundary_update($self->{'sub_0'},$self);$self->_boundary_update($self->{'sub_0'},$self->{'sub_1'});$self->{'sub_1'}->_draw_y_ticks('right');$self->_boundary_update($self->{'sub_1'},$self);$self->_boundary_update($self->{'sub_1'},$self->{'sub_0'});return}sub _draw_data {my$self=shift;if ($self->true($self->{'grey_background'})){$self->_grey_background;$self->{'sub_0'}->{'grey_background'}='false';$self->{'sub_1'}->{'grey_background'}='false'}unless (!$self->true($self->{grey_background})){$self->_draw_grid_lines if ($self->true($self->{grid_lines}));$self->_draw_x_grid_lines if ($self->true($self->{x_grid_lines}));$self->_draw_y_grid_lines if ($self->true($self->{y_grid_lines}));$self->_draw_y2_grid_lines if ($self->true($self->{y2_grid_lines}))}$self->_boundary_update($self,$self->{'sub_0'});$self->_boundary_update($self,$self->{'sub_1'});if ($self->true($self->{'imagemap'})){$self->{'imagemap_data'}=[]}$self->{'sub_0'}->_draw_data;$self->{'sub_1'}->_draw_data;return}sub _sub_update {my$self=shift;my$sub0=$self->{'sub_0'};my$sub1=$self->{'sub_1'};$self->_boundary_update($self,$sub0);$self->_boundary_update($self,$sub1);$sub0->{'color_table'}={%{$self->{'color_table'}}};$sub1->{'color_table'}={%{$self->{'color_table'}}};return}sub _boundary_update {my$self=shift;my$from=shift;my$to=shift;$to->{'curr_x_min'}=$from->{'curr_x_min'};$to->{'curr_x_max'}=$from->{'curr_x_max'};$to->{'curr_y_min'}=$from->{'curr_y_min'};$to->{'curr_y_max'}=$from->{'curr_y_max'};return}sub _draw_y_grid_lines {my ($self)=shift;$self->{'sub_0'}->_draw_y_grid_lines();return}sub _draw_y2_grid_lines {my ($self)=shift;$self->{'sub_1'}->_draw_y2_grid_lines();return}sub _legend_example_height_init {my$self=shift;my$a=$self->{'num_datasets'};my ($b,$e)=(0,0);my$bis='..';if ($self->false($self->{'legend_example_height'})){for my$i (0 .. $a){$self->{'legend_example_height' .$i }=1}}if ($self->true($self->{'legend_example_height'})){for my$i (0 .. $a){if (defined($self->{'legend_example_height' .$i })){}else {($self->{'legend_example_height' .$i })=1}}for$b (0 .. $a){for$e (0 .. $a){my$anh=sprintf($b .$bis .$e);if (defined($self->{'legend_example_height' .$anh })){if ($b > $e){croak "Please reverse the datasetnumber in legend_example_height\n"}for (my$n=$b ;$n <= $e ;$n++ ){$self->{'legend_example_height' .$n }=$self->{'legend_example_height' .$anh }}}}}}}1;
CHART_COMPOSITE

$fatpacked{"Chart/Constants.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CHART_CONSTANTS';
  package Chart::Constants;use strict;use constant PI=>4 * atan2(1,1);1;
CHART_CONSTANTS

$fatpacked{"Chart/Direction.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CHART_DIRECTION';
  package Chart::Direction;use Chart::Base '2.4.10';use GD;use Carp;use strict;use POSIX;@Chart::Direction::ISA=qw(Chart::Base);$Chart::Direction::VERSION='2.4.10';sub set {my$self=shift;my%opts=@_;unless ($#_ % 2){carp "Whoops, some option to be set didn't have a value.\n","You might want to look at that.\n"}for (keys%opts){$self->{$_}=$opts{$_};if ($_ =~ /^colors$/){my%hash=%{$opts{$_}};for my$key (sort keys%hash){if ($key =~ /^grid_lines$/){$self->{'colors'}{'y_grid_lines'}=$hash{'grid_lines'};$self->{'colors'}{'x_grid_lines'}=$hash{'grid_lines'};$self->{'colors'}{'y2_grid_lines'}=$hash{'grid_lines'}}}}}if ($self->false($self->{'polar'})&& (defined$self->{'croak'})){carp "New data set to be added has an incorrect number of points"}return 1}sub add_dataset {my$self=shift;my@data=@_;if ($self->{'dataref'}&& ($#{$self->{'dataref'}->[0]}!=$#data)){$self->{'croak'}='true'}push @{$self->{'dataref'}},[@data];return 1}sub _find_y_scale {my$self=shift;my ($d_min,$d_max);my ($p_min,$p_max);my ($tickInterval,$tickCount,$skip);my@tickLabels;my$maxtickLabelLen=0;($d_min,$d_max)=$self->_find_y_range();if ($self->true($self->{'include_zero'})){if (($d_min * $d_max)> 0){if ($d_min > 0){$d_min=0}else {$d_max=0}}}my$f_min=defined$self->{'min_val'};$d_min=$self->{'min_val'}if$f_min;my$f_max=defined$self->{'max_val'};$d_max=$self->{'max_val'}if$f_max;if ($d_min > $d_max){croak "The the specified 'min_val' & 'max_val' values are reversed (min > max: $d_min>$d_max)"}my$d_width=$d_max - $d_min;if (0==$d_width){$d_min--;$d_max++;$d_width=2}my ($rangeExponent,$rangeMantisa)=$self->_sepFP($d_width);my$rangeMuliplier=10**$rangeExponent;($tickInterval,$tickCount,$p_min,$p_max)=$self->_calcTickInterval($d_min / $rangeMuliplier,$d_max / $rangeMuliplier,$f_min,$f_max,$self->{'min_circles'}+ 1,$self->{'max_circles'}+ 1);$_ *= $rangeMuliplier foreach ($tickInterval,$p_min,$p_max);my$precision=$self->{'precision'};if ($self->false($self->{'polar'})){for (my$labelNum=$p_min ;$labelNum <= $p_max ;$labelNum += $tickInterval ){my$labelText;if (defined$self->{f_y_tick}){if ($self->{f_y_tick}==\&Chart::Base::_default_f_tick){$labelText=sprintf("%." .$precision ."f",$labelNum)}else {$labelText=$self->{f_y_tick}->($labelNum)}}else {$labelText=sprintf("%." .$precision ."f",$labelNum)}push@tickLabels,$labelText;$maxtickLabelLen=length$labelText if$maxtickLabelLen < length$labelText}}else {for (my$labelNum=$p_max ;$labelNum >= $p_min ;$labelNum -= $tickInterval ){my$labelText;if (defined$self->{f_y_tick}){if ($self->{f_y_tick}==\&Chart::Base::_default_f_tick){$labelText=sprintf("%." .$precision ."f",$labelNum)}else {$labelText=$self->{f_y_tick}->($labelNum)}}else {$labelText=sprintf("%." .$precision ."f",$labelNum)}push@tickLabels,$labelText;$maxtickLabelLen=length$labelText if$maxtickLabelLen < length$labelText}}$self->{'min_val'}=$p_min,$self->{'max_val'}=$p_max,$self->{'y_ticks'}=$tickCount,$self->{'y_tick_labels'}=\@tickLabels,$self->{'y_tick_label_length'}=$maxtickLabelLen;return 1}sub _calcTickInterval {my$self=shift;my ($min,$max,$minF,$maxF,$minTicks,$maxTicks,)=@_;if ($minTicks < 2){carp "Chart::Direction : Incorrect value for 'min_circles', too small.\n";$minTicks=2}if ($maxTicks < 5 * $minTicks){carp "Chart::Direction : Incorrect value for 'max_circles', too small.\n";$maxTicks=5 * $minTicks}my$width=$max - $min;my@divisorList;for (my$baseMul=1 ;;$baseMul *= 10 ){TRY: foreach my$tryMul (1,2,5){my$divisor=$baseMul * $tryMul;my ($tickCount,$pMin,$pMax)=$self->_countTicks($min,$max,1 / $divisor);if ($maxTicks < $tickCount){$divisor=pop@divisorList;if (!defined($divisor)|| $divisor==0){$divisor=1}($tickCount,$pMin,$pMax)=$self->_countTicks($min,$max,1 / $divisor);carp "Chart::Direction : Caution: Tick limit of $maxTicks exceeded. Backing of to an interval of " .1 / $divisor ." which plots $tickCount ticks\n";return (1 / $divisor,$tickCount,$pMin,$pMax)}elsif ($minTicks > $tickCount){next TRY}else {push@divisorList,$divisor;next TRY if ($minF && (int($min * $divisor)!=($min * $divisor)));next TRY if ($maxF && (int($max * $divisor)!=($max * $divisor)));return (1 / $divisor,$tickCount,$pMin,$pMax)}}}die "can't happen!"}sub _draw_y_ticks {my$self=shift;my$data=$self->{'dataref'};my$misccolor=$self->_color_role_to_index('misc');my$textcolor=$self->_color_role_to_index('text');my$background=$self->_color_role_to_index('background');my@labels=@{$self->{'y_tick_labels'}};my ($width,$height,$centerX,$centerY,$diameter);my ($pi,$font,$fontW,$fontH,$labelX,$labelY,$label_offset);my ($dia_delta,$dia,$x,$y,@label_degrees,$arc,$angle_interval);$pi=3.14159265358979323846,$font=$self->{'legend_font'},$fontW=$self->{'legend_font'}->width,$fontH=$self->{'legend_font'}->height,$angle_interval=$self->{'angle_interval'};if ($self->true($self->{'grey_background'})){$background=$self->_color_role_to_index('grey_background')}if ($self->true($self->{'imagemap'})){$self->{'imagemap_data'}=[]}$width=$self->{'curr_x_max'}- $self->{'curr_x_min'};$height=$self->{'curr_y_max'}- $self->{'curr_y_min'};$centerX=int($width / 2 + $self->{'curr_x_min'});$centerY=int($height / 2 + $self->{'curr_y_min'});if ($width < $height){$diameter=$width - 110}else {$diameter=$height - 80}$dia_delta=ceil($diameter / ($self->{'y_ticks'}- 1));$self->{'centerX'}=$centerX;$self->{'centerY'}=$centerY;$self->{'diameter'}=$diameter;if ($angle_interval==0){@label_degrees=()}elsif ($angle_interval <= 5 && $angle_interval > 0){@label_degrees=qw(180 175 170 165 160 155 150 145 140 135 130 125 120 115 110 105 100 95 90 85 80 75 70 65 60 55 50 45 40 35 30 25 20 15 10 5 0 355 350 345 340 335 330 325 320 315 310 305 300 295 290 285 280 275 270 265 260 255 250 245 240 235 230 225 220 215 210 205 200 195 190 185);$angle_interval=5}elsif ($angle_interval <= 10 && $angle_interval > 5){@label_degrees=qw(180 170 160 150 140 130 120 110 100 90 80 70 60 50 40 30 20 10 0 350 340 330 320 310 300 290 280 270 260 250 240 230 220 210 200 190);$angle_interval=10}elsif ($angle_interval <= 15 && $angle_interval > 10){@label_degrees=qw(180 165 150 135 120 105 90 75 60 45 30 15 0 345 330 315 300 285 270 255 240 225 210 195);$angle_interval=15}elsif ($angle_interval <= 20 && $angle_interval > 15){@label_degrees=qw(180 160 140 120 100 80 60 40 20 0 340 320 300 280 260 240 220 200);$angle_interval=20}elsif ($angle_interval <= 30 && $angle_interval > 20){@label_degrees=qw(180 150 120 90 60 30 0 330 300 270 240 210);$angle_interval=30}elsif ($angle_interval <= 45 && $angle_interval > 30){@label_degrees=qw(180 135 90 45 0 315 270 225);$angle_interval=45}elsif ($angle_interval <= 90 && $angle_interval > 45){@label_degrees=qw(180 90 0 270);$angle_interval=90}else {carp "The angle_interval must be between 0 and 90!\nCorrected value: 30";@label_degrees=qw(180 150 120 90 60 30 0 330 300 270 240 210);$angle_interval=30}$arc=0;for (@label_degrees){$x=sin($arc)* ($diameter / 2 + 10)+ $centerX;$y=cos($arc)* ($diameter / 2 + 10)+ $centerY;if ($_=='270'){$y++}$self->{'gd_obj'}->line($centerX,$centerY,$x,$y,$misccolor);$x=sin($arc)* ($diameter / 2 + 30)+ $centerX - 8;$y=cos($arc)* ($diameter / 2 + 28)+ $centerY - 6;$self->{'gd_obj'}->string($font,$x,$y,$_ .'',$textcolor);$arc += (($angle_interval)/ 360)* 2 * $pi}$dia=0;for (@labels){$self->{'gd_obj'}->arc($centerX,$centerY,$dia,$dia,0,360,$misccolor);$dia += $dia_delta}$self->{'gd_obj'}->filledRectangle($centerX - length($labels[0])/ 2 * $fontW - 2,$centerY + 2,$centerX + 2 + $diameter / 2,$centerY + $fontH + 2,$background);$dia=0;for (@labels){$self->{'gd_obj'}->string($font,$centerX + $dia / 2 - length($_)/ 2 * $fontW,$centerY + 2,$_,$textcolor);$dia += $dia_delta}return 1}sub _draw_x_ticks {my$self=shift;return 1}sub _draw_data {my$self=shift;my$data=$self->{'dataref'};my$misccolor=$self->_color_role_to_index('misc');my$textcolor=$self->_color_role_to_index('text');my$background=$self->_color_role_to_index('background');my ($width,$height,$centerX,$centerY,$diameter);my ($mod,$map,$i,$j,$brush,$color,$x,$y,$winkel,$first_x,$first_y);my ($arrow_x,$arrow_y,$m);$color=1;my$pi=3.14159265358979323846;my$len=10;my$alpha=1;my$last_x=undef;my$last_y=undef;my$diff;my$n=0;if ($self->true($self->{'pairs'})){my$a=$self->{'num_datasets'}/ 2;my$b=ceil($a);my$c=$b - $a;if ($c==0){croak "Wrong number of datasets for 'pairs'"}}if ($self->true($self->{'imagemap'})){$self->{'imagemap_data'}=[]}$width=$self->{'curr_x_max'}- $self->{'curr_x_min'};$height=$self->{'curr_y_max'}- $self->{'curr_y_min'};if ($self->false($self->{'polar'})){$mod=$self->{'min_val'}}else {$mod=$self->{'max_val'}}$centerX=$self->{'centerX'};$centerY=$self->{'centerY'};$diameter=$self->{'diameter'};$diff=$self->{'max_val'}- $self->{'min_val'};$diff=1 if$diff < 1;$map=$diameter / 2 / $diff;$brush=$self->_prepare_brush($color,'point');$self->{'gd_obj'}->setBrush($brush);if ($self->false($self->{'pairs'})){for$j (1 .. $self->{'num_datasets'}){$color=$self->_color_role_to_index('dataset' .($j - 1));for$i (0 .. $self->{'num_datapoints'}- 1){if (defined($data->[$j][$i])&& $data->[$j][$i]<= $self->{'max_val'}&& $data->[$j][$i]>= $self->{'min_val'}){$winkel=(180 - ($data->[0][$i]% 360))/ 360 * 2 * $pi;if ($self->false($self->{'polar'})){$x=ceil($centerX + sin($winkel)* ($data->[$j][$i]- $mod)* $map);$y=ceil($centerY + cos($winkel)* ($data->[$j][$i]- $mod)* $map)}else {$x=ceil($centerX + sin($winkel)* ($mod - $data->[$j][$i])* $map);$y=ceil($centerY + cos($winkel)* ($mod - $data->[$j][$i])* $map)}if ($i==0){$first_x=$x;$first_y=$y;$last_x=$x;$last_y=$y}if ($self->true($self->{'point'})){$brush=$self->_prepare_brush($color,'point');$self->{'gd_obj'}->setBrush($brush);$self->{'gd_obj'}->line($x + 1,$y,$x,$y,gdBrushed)}if ($self->true($self->{'line'})){$brush=$self->_prepare_brush($color,'line');$self->{'gd_obj'}->setBrush($brush);if (defined$last_x){$self->{'gd_obj'}->line($x,$y,$last_x,$last_y,gdBrushed)}}if ($self->true($self->{'arrow'})){$brush=$self->_prepare_brush($color,'line');$self->{'gd_obj'}->setBrush($brush);if ($data->[$j][$i]> $self->{'min_val'}){$self->{'gd_obj'}->line($x,$y,$centerX,$centerY,gdBrushed);$arrow_x=$x - cos($winkel - $alpha)* $len;$arrow_y=$y + sin($winkel - $alpha)* $len;$self->{'gd_obj'}->line($x,$y,$arrow_x,$arrow_y,gdBrushed);$arrow_x=$x + sin($pi / 2 - $winkel - $alpha)* $len;$arrow_y=$y - cos($pi / 2 - $winkel - $alpha)* $len;$self->{'gd_obj'}->line($x,$y,$arrow_x,$arrow_y,gdBrushed)}}$last_x=$x;$last_y=$y;if ($self->true($self->{'imagemap'})){$self->{'imagemap_data'}->[$j][$i]=[$x,$y ]}}else {if ($self->true($self->{'imagemap'})){$self->{'imagemap_data'}->[$j][$i]=[undef(),undef()]}}}if ($self->true($self->{'line'})){$self->{'gd_obj'}->line($x,$y,$first_x,$first_y,gdBrushed)}}}if ($self->true($self->{'pairs'})){for ($j=1 ;$j <= $self->{'num_datasets'};$j += 2 ){if ($j==1){$color=$self->_color_role_to_index('dataset' .($j - 1))}else {$color=$self->_color_role_to_index('dataset' .($j / 2 - 0.5))}for$i (0 .. $self->{'num_datapoints'}- 1){if (defined($data->[$j][$i])&& $data->[$j][$i]<= $self->{'max_val'}&& $data->[$j][$i]>= $self->{'min_val'}){$winkel=(180 - ($data->[$n][$i]% 360))/ 360 * 2 * $pi;if ($self->false($self->{'polar'})){$x=ceil($centerX + sin($winkel)* ($data->[$j][$i]- $mod)* $map);$y=ceil($centerY + cos($winkel)* ($data->[$j][$i]- $mod)* $map)}else {$x=ceil($centerX + sin($winkel)* ($mod - $data->[$j][$i])* $map);$y=ceil($centerY + cos($winkel)* ($mod - $data->[$j][$i])* $map)}if ($i==0){$first_x=$x;$first_y=$y;$last_x=$x;$last_y=$y}if ($self->true($self->{'point'})){$brush=$self->_prepare_brush($color,'point');$self->{'gd_obj'}->setBrush($brush);$self->{'gd_obj'}->line($x + 1,$y,$x,$y,gdBrushed)}if ($self->true($self->{'line'})){$brush=$self->_prepare_brush($color,'line');$self->{'gd_obj'}->setBrush($brush);if (defined$last_x){$self->{'gd_obj'}->line($x,$y,$last_x,$last_y,gdBrushed)}else {}}if ($self->true($self->{'arrow'})){$brush=$self->_prepare_brush($color,'line');$self->{'gd_obj'}->setBrush($brush);if ($data->[$j][$i]> $self->{'min_val'}){$self->{'gd_obj'}->line($x,$y,$centerX,$centerY,gdBrushed);$arrow_x=$x - cos($winkel - $alpha)* $len;$arrow_y=$y + sin($winkel - $alpha)* $len;$self->{'gd_obj'}->line($x,$y,$arrow_x,$arrow_y,gdBrushed);$arrow_x=$x + sin($pi / 2 - $winkel - $alpha)* $len;$arrow_y=$y - cos($pi / 2 - $winkel - $alpha)* $len;$self->{'gd_obj'}->line($x,$y,$arrow_x,$arrow_y,gdBrushed)}}$last_x=$x;$last_y=$y;if ($self->true($self->{'imagemap'})){$self->{'imagemap_data'}->[$j][$i]=[$x,$y ]}}else {if ($self->true($self->{'imagemap'})){$self->{'imagemap_data'}->[$j][$i]=[undef(),undef()]}}}if ($self->true($self->{'line'})){$self->{'gd_obj'}->line($x,$y,$first_x,$first_y,gdBrushed)}$n += 2}}$self->{'gd_obj'}->rectangle($self->{'curr_x_min'},$self->{'curr_y_min'},$self->{'curr_x_max'},$self->{'curr_y_max'},$misccolor);return}sub _prepare_brush {my$self=shift;my$color=shift;my$type=shift;my ($radius,@rgb,$brush,$white,$newcolor);@rgb=$self->{'gd_obj'}->rgb($color);if ($type eq 'line'){$radius=$self->{'brush_size'}/ 2}elsif ($type eq 'point'){$radius=$self->{'pt_size'}/ 2}$brush=GD::Image->new($radius * 2,$radius * 2);$white=$brush->colorAllocate(255,255,255);$newcolor=$brush->colorAllocate(@rgb);$brush->transparent($white);$brush->arc($radius - 1,$radius - 1,$radius,$radius,0,360,$newcolor);$brush->fill($radius - 1,$radius - 1,$newcolor);return$brush}sub _draw_legend {my$self=shift;my$length;if ($self->{'legend'}=~ /^none$/){return 1}if (($#{$self->{'legend_labels'}}>= 0)&& ((scalar(@{$self->{'legend_labels'}}))!=$self->{'num_datasets'})){carp "The number of legend labels and datasets doesn\'t match"}unless ($self->{'max_legend_label'}){$self->{'max_legend_label'}=0}if ($self->false($self->{'pairs'})){for (1 .. $self->{'num_datasets'}){unless ($self->{'legend_labels'}[$_ - 1 ]){$self->{'legend_labels'}[$_ - 1 ]="Dataset $_"}$length=length($self->{'legend_labels'}[$_ - 1 ]);if ($length > $self->{'max_legend_label'}){$self->{'max_legend_label'}=$length}}}if ($self->true($self->{'pairs'})){for (1 .. ceil($self->{'num_datasets'}/ 2)){unless ($self->{'legend_labels'}[$_ - 1 ]){$self->{'legend_labels'}[$_ - 1 ]="Dataset $_"}$length=length($self->{'legend_labels'}[$_ - 1 ]);if ($length > $self->{'max_legend_label'}){$self->{'max_legend_label'}=$length}}}if ($self->{'legend'}eq 'bottom'){$self->_draw_bottom_legend}elsif ($self->{'legend'}eq 'right'){$self->_draw_right_legend}elsif ($self->{'legend'}eq 'left'){$self->_draw_left_legend}elsif ($self->{'legend'}eq 'top'){$self->_draw_top_legend}else {carp "I can't put a legend there (at " .$self->{'legend'}.")\n"}return 1}sub _find_y_range {my$self=shift;my$data=$self->{'dataref'};my$max=undef;my$min=undef;my$k=1;my$dataset=1;my$datum;if ($self->false($self->{'pairs'})){for$dataset (@$data[1 .. $#$data ]){for$datum (@$dataset){if (defined$datum){if (defined$max){if ($datum > $max){$max=$datum}elsif ($datum < $min){$min=$datum}}else {$min=$max=$datum}}}}}if ($self->true($self->{'pairs'})){for$dataset (@$data[$k]){for$datum (@$dataset){if (defined$datum){if (defined$max){if ($datum > $max){$max=$datum}elsif ($datum < $min){$min=$datum}}else {$min=$max=$datum}}}$k += 2}}($min,$max)}1;
CHART_DIRECTION

$fatpacked{"Chart/ErrorBars.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CHART_ERRORBARS';
  package Chart::ErrorBars;use Chart::Base '2.4.10';use GD;use Carp;use strict;@Chart::ErrorBars::ISA=qw(Chart::Base);$Chart::ErrorBars::VERSION='2.4.10';sub _draw_data {my$self=shift;my$data=$self->{'dataref'};my$misccolor=$self->_color_role_to_index('misc');my ($x1,$x2,$x3,$y1,$y2,$y3,$mod,$y_error_up,$y_error_down);my ($width,$height,$delta,$map,$delta_num,$zero_offset,$flag);my ($i,$j,$color,$brush);my$dataset=0;my$diff;if ($self->true($self->{'imagemap'})){$self->{'imagemap_data'}=[]}$width=$self->{'curr_x_max'}- $self->{'curr_x_min'};$height=$self->{'curr_y_max'}- $self->{'curr_y_min'};$delta=$width / ($self->{'num_datapoints'}> 0 ? $self->{'num_datapoints'}: 1);$diff=$self->{'max_val'}- $self->{'min_val'};$diff=1 if$diff==0;$map=$height / $diff;if ($self->true($self->{'xy_plot'})){$diff=$self->{'x_max_val'}- $self->{'x_min_val'};$diff=1 if$diff==0;$delta_num=$width / $diff;if ($self->{'x_min_val'}<= 0 && $self->{'x_max_val'}>= 0){$zero_offset=abs($self->{'x_min_val'})* abs($delta_num)}elsif ($self->{'x_min_val'}> 0 || $self->{'x_max_val'}< 0){$zero_offset=-$self->{'x_min_val'}* $delta_num}else {$zero_offset=0}}if ($self->false($self->{'xy_plot'})){$x1=$self->{'curr_x_min'}+ ($delta / 2)}else {$x1=$self->{'curr_x_min'}}if ($self->{'min_val'}>= 0){$y1=$self->{'curr_y_max'};$mod=$self->{'min_val'}}elsif ($self->{'max_val'}<= 0){$y1=$self->{'curr_y_min'};$mod=$self->{'max_val'}}else {$y1=$self->{'curr_y_min'}+ ($map * $self->{'max_val'});$mod=0;$self->{'gd_obj'}->line($self->{'curr_x_min'},$y1,$self->{'curr_x_max'},$y1,$misccolor)}$self->{'gd_obj'}->rectangle($self->{'curr_x_min'},$self->{'curr_y_min'},$self->{'curr_x_max'},$self->{'curr_y_max'},$misccolor);for$i (1 .. $self->{'num_datasets'}){if ($self->false($self->{'same_error'})){$color=$self->_color_role_to_index('dataset' .($dataset));$dataset++ if (($i - 1)% 3==0);for$j (0 .. $self->{'num_datapoints'}){$brush=$self->_prepare_brush($color,'point');$self->{'gd_obj'}->setBrush($brush);if (($i - 1)% 3==0){if (defined($data->[$i][$j])){if ($self->true($self->{'xy_plot'})){$x2=$x1 + $delta_num * $data->[0][$j]+ $zero_offset + 1;$x3=$x2}else {$x2=$x1 + ($delta * $j)+ 1;$x3=$x2}$y2=$y1 - (($data->[$i][$j]- $mod)* $map);$y3=$y2;$y_error_up=$y2 - abs($data->[$i + 1 ][$j])* $map;$y_error_down=$y2 + abs($data->[$i + 2 ][$j])* $map;if ($data->[$i][$j]<= $self->{'max_val'}&& $data->[$i][$j]>= $self->{'min_val'}){$self->{'gd_obj'}->line($x2,$y2,$x3,$y3,gdBrushed);$flag='true'}$brush=$self->_prepare_brush($color,'line');$self->{'gd_obj'}->setBrush($brush);if ($self->true($flag)){$self->{'gd_obj'}->line($x2,$y2,$x3,$y_error_up,gdBrushed);$self->{'gd_obj'}->line($x2 - 3,$y_error_up,$x3 + 3,$y_error_up,gdBrushed);$self->{'gd_obj'}->line($x2,$y2,$x3,$y_error_down,gdBrushed);$self->{'gd_obj'}->line($x2 - 3,$y_error_down,$x3 + 3,$y_error_down,gdBrushed);$flag='false'}if ($self->true($self->{'imagemap'})){$self->{'imagemap_data'}->[$i][$j]=[$x2,$y2 ]}}}}}else {$color=$self->_color_role_to_index('dataset' .($dataset));$dataset++ if (($i - 1)% 2==0);for$j (0 .. $self->{'num_datapoints'}){$brush=$self->_prepare_brush($color,'point');$self->{'gd_obj'}->setBrush($brush);if (($i - 1)% 2==0){if (defined($data->[$i][$j])){if ($self->true($self->{'xy_plot'})){$x2=$x1 + $delta_num * $data->[0][$j]+ $zero_offset;$x3=$x2}else {$x2=$x1 + ($delta * $j);$x3=$x2}$y2=$y1 - (($data->[$i][$j]- $mod)* $map);$y3=$y2;$y_error_up=$y2 - abs($data->[$i + 1 ][$j])* $map;$y_error_down=$y2 + abs($data->[$i + 1 ][$j])* $map;if ($data->[$i][$j]<= $self->{'max_val'}&& $data->[$i][$j]>= $self->{'min_val'}){$self->{'gd_obj'}->line($x2,$y2,$x3,$y3,gdBrushed);$flag='true'}$brush=$self->_prepare_brush($color,'line');$self->{'gd_obj'}->setBrush($brush);if ($self->true($flag)){$self->{'gd_obj'}->line($x2,$y2,$x3,$y_error_up,gdBrushed);$self->{'gd_obj'}->line($x2 - 3,$y_error_up,$x3 + 3,$y_error_up,gdBrushed);$self->{'gd_obj'}->line($x2,$y2,$x3,$y_error_down,gdBrushed);$self->{'gd_obj'}->line($x2 - 3,$y_error_down,$x3 + 3,$y_error_down,gdBrushed);$flag='false'}if ($self->true($self->{'imagemap'})){$self->{'imagemap_data'}->[$i][$j]=[$x2,$y2 ]}}}}}}return 1}sub _prepare_brush {my$self=shift;my$color=shift;my$type=shift;my ($radius,@rgb,$brush,$white,$newcolor);@rgb=$self->{'gd_obj'}->rgb($color);if ($type eq 'line'){$radius=$self->{'brush_size'}/ 2}elsif ($type eq 'point'){$radius=$self->{'pt_size'}/ 2}$brush=GD::Image->new($radius * 2,$radius * 2);$white=$brush->colorAllocate(255,255,255);$newcolor=$brush->colorAllocate(@rgb);$brush->transparent($white);$brush->arc($radius - 1,$radius - 1,$radius,$radius,0,360,$newcolor);$brush->fill($radius - 1,$radius - 1,$newcolor);return$brush}sub _draw_legend {my$self=shift;my ($length,$step,$temp,$post_length);my$j=0;if ($self->{'legend'}=~ /^none$/){return 1}if ($#{$self->{'legend_labels'}}>= 0){$post_length=scalar(@{$self->{'legend_labels'}})}if ($self->false($self->{'same_error'})){$step=3}else {$step=2}unless ($self->{'max_legend_label'}){$self->{'max_legend_label'}=0}for (my$i=1 ;$i < $self->{'num_datasets'};$i += $step ){my$label=$j + 1;unless ($self->{'legend_labels'}[$j]){$self->{'legend_labels'}[$j]="Dataset $label"}$length=length($self->{'legend_labels'}[$j]);if ($length > $self->{'max_legend_label'}){$self->{'max_legend_label'}=$length}$j++}$temp=$self->{'num_datasets'};$self->{'num_datasets'}=$j;if (($post_length > 0)&& ($post_length!=$j)){carp "The number of legend labels and datasets doesn\'t match"}if ($self->{'legend'}eq 'bottom'){$self->_draw_bottom_legend}elsif ($self->{'legend'}eq 'right'){$self->_draw_right_legend}elsif ($self->{'legend'}eq 'left'){$self->_draw_left_legend}elsif ($self->{'legend'}eq 'top'){$self->_draw_top_legend}else {carp "I can't put a legend there (at " .$self->{'legend'}.")\n"}$self->{'num_datasets'}=$temp;return 1}sub _find_y_range {my$self=shift;my$data=$self->{'dataref'};my$max=undef;my$min=undef;if ($self->false($self->{'same_error'})){for my$i (1 .. $self->{'num_datasets'}){if (($i - 1)% 3==0){for my$j (0 .. $self->{'num_datapoints'}){if (defined($data->[$i][$j])&& defined($data->[$i + 1 ][$j])&& defined($data->[$i + 2 ][$j])){if (defined$max){if (($data->[$i][$j]+ abs($data->[$i + 1 ][$j]))> $max){$max=$data->[$i][$j]+ abs($data->[$i + 1 ][$j])}if (($data->[$i][$j]- abs($data->[$i + 2 ][$j]))< $min){$min=$data->[$i][$j]- abs($data->[$i + 2 ][$j])}}else {$min=$max=$data->[$i][$j]}}}}}return ($min,$max)}else {for my$i (1 .. $self->{'num_datasets'}){if (($i - 1)% 2==0){for my$j (0 .. $self->{'num_datapoints'}){if (defined($data->[$i][$j])&& defined($data->[$i + 1 ][$j])){if (defined$max){if (($data->[$i][$j]+ $data->[$i + 1 ][$j])> $max){$max=$data->[$i][$j]+ $data->[$i + 1 ][$j]}if (($data->[$i][$j]- $data->[$i + 1 ][$j])< $min){$min=$data->[$i][$j]- $data->[$i + 1 ][$j]}}else {$min=$max=$data->[$i][$j]}}}}}return ($min,$max)}}1;
CHART_ERRORBARS

$fatpacked{"Chart/HorizontalBars.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CHART_HORIZONTALBARS';
  package Chart::HorizontalBars;use Chart::Base '2.4.10';use GD;use Carp;use strict;@Chart::HorizontalBars::ISA=qw(Chart::Base);$Chart::HorizontalBars::VERSION='2.4.10';sub _draw_x_ticks {my$self=shift;my$data=$self->{'dataref'};my$font=$self->{'tick_label_font'};my$textcolor=$self->_color_role_to_index('text');my$misccolor=$self->_color_role_to_index('misc');my ($h,$w,$x1,$y1,$y2,$x2,$delta,$width,$label);my@labels=@{$self->{'y_tick_labels'}};$self->{'grid_data'}->{'x'}=[];unless ((ref$font)eq 'GD::Font'){croak "The tick label font you specified isn't a GD font object"}($h,$w)=($font->height,$font->width);if ($self->{'y_axes'}=~ /^right$/i){$x1=$self->{'curr_x_min'};$width=$self->{'curr_x_max'}- $x1 - $self->{'tick_len'}- $self->{'text_space'}- $w * $self->{'x_tick_label_length'}}elsif ($self->{'y_axes'}=~ /^both$/i){$x1=$self->{'curr_x_min'}+ $self->{'text_space'}+ $w * $self->{'x_tick_label_length'}+ $self->{'tick_len'};$width=$self->{'curr_x_max'}- $x1 - $self->{'tick_len'}- $self->{'text_space'}- $w * $self->{'x_tick_label_length'}}else {$x1=$self->{'curr_x_min'}+ $self->{'text_space'}+ $w * $self->{'x_tick_label_length'}+ $self->{'tick_len'};$width=$self->{'curr_x_max'}- $x1}$delta=$width / ($self->{'y_ticks'}- 1);$y2=$y1;if ($self->{'x_ticks'}=~ /^normal/i){$y1=$self->{'curr_y_max'}- 2 * $self->{'text_space'}- $h - $self->{'tick_len'};$y2=$y1 + $self->{'tick_len'}+ $self->{'text_space'};for (0 .. $#labels){$label=$self->{'y_tick_labels'}[$_];$x2=$x1 + ($delta * $_)- ($w * length($label)/ 2);$self->{'gd_obj'}->string($font,$x2,$y2,$label,$textcolor)}}elsif ($self->{'x_ticks'}=~ /^staggered/i){$y1=$self->{'curr_y_max'}- 3 * $self->{'text_space'}- 2 * $h - $self->{'tick_len'};for (0 .. $#labels){$label=$self->{'y_tick_labels'}[$_];$x2=$x1 + ($delta * $_)- ($w * length($label)/ 2);unless ($_ % 2){$y2=$y1 + $self->{'text_space'}+ $self->{'tick_len'};$self->{'gd_obj'}->string($font,$x2,$y2,$label,$textcolor)}else {$y2=$y1 + $h + 2 * $self->{'text_space'}+ $self->{'tick_len'};$self->{'gd_obj'}->string($font,$x2,$y2,$label,$textcolor)}}}elsif ($self->{'x_ticks'}=~ /^vertical/i){$y1=$self->{'curr_y_max'}- 2 * $self->{'text_space'}- $w * $self->{'y_tick_label_length'}- $self->{'tick_len'};for (0 .. $#labels){$label=$self->{'y_tick_labels'}[$_];$y2=$y1 + $self->{'tick_len'}+ $w * length($label)+ $self->{'text_space'};$x2=$x1 + ($delta * $_)- ($h / 2);$self->{'gd_obj'}->stringUp($font,$x2,$y2,$label,$textcolor)}}else {carp "I don't understand the type of x-ticks you specified"}$self->{'curr_y_max'}=$y1;$self->{'curr_x_max'}=$x1 + $width;$y1=$self->{'curr_y_max'};$y2=$self->{'curr_y_max'}+ $self->{'tick_len'};for (0 .. $#labels){$x2=$x1 + ($delta * $_);$self->{'gd_obj'}->line($x2,$y1,$x2,$y2,$misccolor);if ($self->true($self->{'grid_lines'})or $self->true($self->{'x_grid_lines'})){$self->{'grid_data'}->{'x'}->[$_]=$x2}}return 1}sub _draw_y_ticks {my$self=shift;my$side=shift || 'left';my$data=$self->{'dataref'};my$font=$self->{'tick_label_font'};my$textcolor=$self->_color_role_to_index('text');my$misccolor=$self->_color_role_to_index('misc');my ($h,$w,$x1,$x2,$y1,$y2);my ($width,$height,$delta);$self->{'grid_data'}->{'y'}=[];unless ((ref$font)eq 'GD::Font'){croak "The tick label font isn't a GD Font object!"}($h,$w)=($font->height,$font->width);if ($side =~ /^right$/i){$x1=$self->{'curr_x_max'};$y1=$self->{'curr_y_max'}- $h / 2;$height=$self->{'curr_y_max'}- $self->{'curr_y_min'};$delta=($height)/ ($self->{'num_datapoints'}> 0 ? $self->{'num_datapoints'}: 1);$y1 -= ($delta / 2);if (!defined($self->{'skip_y_ticks'})){$self->{'skip_y_ticks'}=1}for (0 .. int(($self->{'num_datapoints'}- 1)/ $self->{'skip_y_ticks'})){$y2=$y1 - ($delta)* ($_ * $self->{'skip_y_ticks'});$x2=$x1 + $self->{'tick_len'}+ $self->{'text_space'};$self->{'gd_obj'}->string($font,$x2,$y2,$self->{f_y_tick}->($data->[0][$_ * $self->{'skip_y_ticks'}]),$textcolor)}$x1=$self->{'curr_x_max'};$x2=$self->{'curr_x_max'}+ $self->{'tick_len'};$y1 += $h / 2;for (0 .. ($self->{'num_datapoints'}- 1 / $self->{'skip_y_ticks'})){$y2=$y1 - ($delta * $_);$self->{'gd_obj'}->line($x1,$y2,$x2,$y2,$misccolor);if ($self->true($self->{'grid_lines'})or $self->true($self->{'x_grid_lines'})){$self->{'grid_data'}->{'y'}->[$_]=$y2}}}elsif ($side =~ /^both$/i){$x1=$self->{'curr_x_max'};$y1=$self->{'curr_y_max'}- $h / 2;$height=$self->{'curr_y_max'}- $self->{'curr_y_min'};$delta=($height)/ ($self->{'num_datapoints'}> 0 ? $self->{'num_datapoints'}: 1);$y1 -= ($delta / 2);if (!defined($self->{'skip_y_ticks'})){$self->{'skip_y_ticks'}=1}for (0 .. int(($self->{'num_datapoints'}- 1)/ $self->{'skip_y_ticks'})){$y2=$y1 - ($delta)* ($_ * $self->{'skip_y_ticks'});$x2=$x1 + $self->{'tick_len'}+ $self->{'text_space'};$self->{'gd_obj'}->string($font,$x2,$y2,$self->{f_y_tick}->($data->[0][$_ * $self->{'skip_y_ticks'}]),$textcolor)}$x1=$self->{'curr_x_max'};$x2=$self->{'curr_x_max'}+ $self->{'tick_len'};$y1 += $h / 2;for (0 .. ($self->{'num_datapoints'}- 1 / $self->{'skip_y_ticks'})){$y2=$y1 - ($delta * $_);$self->{'gd_obj'}->line($x1,$y2,$x2,$y2,$misccolor);if ($self->true($self->{'grid_lines'})or $self->true($self->{'x_grid_lines'})){$self->{'grid_data'}->{'y'}->[$_]=$y2}}$x1=$self->{'curr_x_min'};$y1=$self->{'curr_y_max'}- $h / 2;$height=$self->{'curr_y_max'}- $self->{'curr_y_min'};$delta=($height)/ ($self->{'num_datapoints'}> 0 ? $self->{'num_datapoints'}: 1);$y1 -= ($delta / 2);for (0 .. int(($self->{'num_datapoints'}- 1)/ $self->{'skip_y_ticks'})){$y2=$y1 - ($delta)* ($_ * $self->{'skip_y_ticks'});$x2=$x1 - $w * length($self->{f_y_tick}->($data->[0][$_ * $self->{'skip_y_ticks'}]))+ $w * $self->{'x_tick_label_length'};$self->{'gd_obj'}->string($font,$x2,$y2,$self->{f_y_tick}->($data->[0][$_ * $self->{'skip_y_ticks'}]),$textcolor)}$self->{'curr_x_min'}=$x1 + $self->{'text_space'}+ $w * $self->{'x_tick_label_length'}+ $self->{'tick_len'};$x1=$self->{'curr_x_min'};$x2=$self->{'curr_x_min'}- $self->{'tick_len'};$y1 += $h / 2;for (0 .. ($self->{'num_datapoints'}- 1 / $self->{'skip_y_ticks'})){$y2=$y1 - ($delta * $_);$self->{'gd_obj'}->line($x1,$y2,$x2,$y2,$misccolor);if ($self->true($self->{'grid_lines'})or $self->true($self->{'x_grid_lines'})){$self->{'grid_data'}->{'y'}->[$_]=$y2}}}else {$x1=$self->{'curr_x_min'};$y1=$self->{'curr_y_max'}- $h / 2;$height=$self->{'curr_y_max'}- $self->{'curr_y_min'};$delta=($height)/ ($self->{'num_datapoints'}> 0 ? $self->{'num_datapoints'}: 1);$y1 -= ($delta / 2);if (!defined($self->{'skip_y_ticks'})){$self->{'skip_y_ticks'}=1}for (0 .. int(($self->{'num_datapoints'}- 1)/ $self->{'skip_y_ticks'})){$y2=$y1 - ($delta)* ($_ * $self->{'skip_y_ticks'});$x2=$x1 - $w * length($self->{f_y_tick}->($data->[0][$_ * $self->{'skip_y_ticks'}]))+ $w * $self->{'x_tick_label_length'};$self->{'gd_obj'}->string($font,$x2,$y2,$self->{f_y_tick}->($data->[0][$_ * $self->{'skip_y_ticks'}]),$textcolor)}$self->{'curr_x_min'}=$x1 + $self->{'text_space'}+ $w * $self->{'x_tick_label_length'}+ $self->{'tick_len'};$x1=$self->{'curr_x_min'};$x2=$self->{'curr_x_min'}- $self->{'tick_len'};$y1 += $h / 2;for (0 .. ($self->{'num_datapoints'}- 1 / $self->{'skip_y_ticks'})){$y2=$y1 - ($delta * $_);$self->{'gd_obj'}->line($x1,$y2,$x2,$y2,$misccolor);if ($self->true($self->{'grid_lines'})or $self->true($self->{'x_grid_lines'})){$self->{'grid_data'}->{'y'}->[$_]=$y2}}}return 1}sub _find_y_scale {my$self=shift;my ($d_min,$d_max);my ($p_min,$p_max);my ($tickInterval,$tickCount);my@tickLabels;my$maxtickLabelLen=0;($d_min,$d_max)=$self->_find_y_range();if ($self->true($self->{'include_zero'})){if (($d_min * $d_max)> 0){if ($d_min > 0){$d_min=0}else {$d_max=0}}}if ($self->{'integer_ticks_only'}=~ /^\d$/){if ($self->{'integer_ticks_only'}==1){$self->{'integer_ticks_only'}='true'}else {$self->{'integer_ticks_only'}='false'}}if ($self->true($self->{'integer_ticks_only'})){my$f_min=defined$self->{'min_val'};$d_min=$self->{'min_val'}if$f_min;my$f_max=defined$self->{'max_val'};$d_max=$self->{'max_val'}if$f_max;if ($d_min > $d_max){croak "The the specified 'min_val' & 'max_val' values are reversed (min > max: $d_min>$d_max)"}$p_min=$self->_round2Tick($d_min,1,-1);$p_max=$self->_round2Tick($d_max,1,1);my$skip=$self->{skip_int_ticks};$tickInterval=$skip;$tickCount=($p_max - $p_min)/ $skip + 1;for (my$labelNum=$p_min ;$labelNum <= $p_max ;$labelNum += $tickInterval ){my$labelText;if (defined$self->{f_x_tick}){if ($self->{f_x_tick}==\&_default_f_tick){$labelText=sprintf("%d",$labelNum)}else {$labelText=$self->{f_x_tick}->($labelNum)}}else {$labelText=sprintf("%d",$labelNum)}push@tickLabels,$labelText;$maxtickLabelLen=length$labelText if$maxtickLabelLen < length$labelText}}else {my$f_min=defined$self->{'min_val'};$d_min=$self->{'min_val'}if$f_min;my$f_max=defined$self->{'max_val'};$d_max=$self->{'max_val'}if$f_max;if ($d_min > $d_max){croak "The the specified 'min_val' & 'max_val' values are reversed (min > max: $d_min>$d_max)"}my$d_width=$d_max - $d_min;if (0==$d_width){$d_min--;$d_max++;$d_width=2}my ($rangeExponent,$rangeMantisa)=$self->_sepFP($d_width);my$rangeMuliplier=10**$rangeExponent;($tickInterval,$tickCount,$p_min,$p_max)=$self->_calcTickInterval($d_min / $rangeMuliplier,$d_max / $rangeMuliplier,$f_min,$f_max,$self->{'min_y_ticks'},$self->{'max_y_ticks'});$_ *= $rangeMuliplier foreach ($tickInterval,$p_min,$p_max);my$precision=$self->{'precision'};for (my$labelNum=$p_min ;$labelNum <= $p_max ;$labelNum += $tickInterval ){my$labelText;if (defined$self->{f_x_tick}){if ($self->{f_x_tick}==\&_default_f_tick){$labelText=sprintf("%." .$precision ."f",$labelNum)}else {$labelText=$self->{f_x_tick}->($labelNum)}}else {$labelText=sprintf("%." .$precision ."f",$labelNum)}push@tickLabels,$labelText;$maxtickLabelLen=length$labelText if$maxtickLabelLen < length$labelText}}$self->{'min_val'}=$p_min;$self->{'max_val'}=$p_max;$self->{'y_ticks'}=$tickCount;$self->{'y_tick_labels'}=\@tickLabels;$self->{'y_tick_label_length'}=$maxtickLabelLen;return 1}sub _draw_data {my$self=shift;my$data=$self->{'dataref'};my$misccolor=$self->_color_role_to_index('misc');my ($x1,$x2,$x3,$y1,$y2,$y3);my$cut=0;my ($width,$height,$delta1,$delta2,$map,$mod,$pink);my ($i,$j,$color);if ($self->true($self->{'imagemap'})){$self->{'imagemap_data'}=[]}$width=$self->{'curr_x_max'}- $self->{'curr_x_min'};$height=$self->{'curr_y_max'}- $self->{'curr_y_min'};$delta1=$height / ($self->{'num_datapoints'}> 0 ? $self->{'num_datapoints'}: 1);$map=$width / ($self->{'max_val'}- $self->{'min_val'});if ($self->true($self->{'spaced_bars'})){$delta2=$delta1 / ($self->{'num_datasets'}+ 2)}else {$delta2=$delta1 / $self->{'num_datasets'}}$y1=$self->{'curr_y_max'}- $delta2;if ($self->{'min_val'}>= 0){$x1=$self->{'curr_x_min'};$mod=$self->{'min_val'}}elsif ($self->{'max_val'}<= 0){$x1=$self->{'curr_x_max'};$mod=$self->{'max_val'}}else {$x1=$self->{'curr_x_min'}+ abs($map * $self->{'min_val'});$mod=0;$self->{'gd_obj'}->line($x1,$self->{'curr_y_min'},$x1,$self->{'curr_y_max'},$misccolor)}for$i (1 .. $self->{'num_datasets'}){$color=$self->_color_role_to_index('dataset' .($i - 1));for$j (0 .. $self->{'num_datapoints'}){if (defined($data->[$i][$j])){if ($self->true($self->{'spaced_bars'})){$y2=$y1 - ($j * $delta1)- ($self->{'num_datasets'}* $delta2)+ (($i - 1)* $delta2)}else {$y2=$y1 - ($j * $delta1)- ($self->{'num_datasets'}* $delta2)+ (($i)* $delta2)}$x2=$x1;$y3=$y2 + $delta2;if ($data->[$i][$j]> $self->{'max_val'}){$x3=$x1 + (($self->{'max_val'}- $mod)* $map)- 1;$cut=1}elsif ($data->[$i][$j]< $self->{'min_val'}){$x3=$x1 + (($self->{'min_val'}- $mod)* $map)+ 1;$cut=1}else {$x3=$x1 + (($data->[$i][$j]- $mod)* $map);$cut=0}if ($data->[$i][$j]< 0){$self->{'gd_obj'}->filledRectangle($x3,$y2,$x2,$y3,$color);if ($self->true($self->{'imagemap'})){$self->{'imagemap_data'}->[$i][$j]=[$x3,$y2,$x2,$y3 ]}$self->{'gd_obj'}->filledRectangle($x3,$y2,$x2,$y3,$color);if ($self->true($self->{'imagemap'})){$self->{'imagemap_data'}->[$i][$j]=[$x3,$y2,$x2,$y3 ]}}else {$self->{'gd_obj'}->filledRectangle($x2,$y2,$x3,$y3,$color);if ($self->true($self->{'imagemap'})){$self->{'imagemap_data'}->[$i][$j]=[$x2,$y2,$x3,$y3 ]}}unless ($cut){$self->{'gd_obj'}->rectangle($x2,$y3,$x3,$y2,$misccolor)}else {$pink=$self->{'gd_obj'}->colorAllocate(255,0,255);$self->{'gd_obj'}->rectangle($x2,$y3,$x3,$y2,$pink)}}else {if ($self->true($self->{'imagemap'})){$self->{'imagemap_data'}->[$i][$j]=[undef(),undef(),undef(),undef()]}}}}$self->{'gd_obj'}->rectangle($self->{'curr_x_min'},$self->{'curr_y_min'},$self->{'curr_x_max'},$self->{'curr_y_max'},$misccolor);return}1;
CHART_HORIZONTALBARS

$fatpacked{"Chart/Lines.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CHART_LINES';
  package Chart::Lines;use Chart::Base '2.4.10';use GD;use Carp;use strict;@Chart::Lines::ISA=qw(Chart::Base);$Chart::Lines::VERSION='2.4.10';sub _draw_data {my$self=shift;my$data=$self->{'dataref'};my$misccolor=$self->_color_role_to_index('misc');my ($x1,$x2,$x3,$y1,$y2,$y3,$mod,$abs_x_max,$abs_y_max,$tan_alpha);my ($width,$height,$delta,$delta_num,$map,$t_x_min,$t_x_max,$t_y_min,$t_y_max);my ($i,$j,$color,$brush,$zero_offset);my$repair_top_flag=0;my$repair_bottom_flag=0;if ($self->true($self->{'imagemap'})){$self->{'imagemap_data'}=[]}$width=$self->{'curr_x_max'}- $self->{'curr_x_min'};$height=$self->{'curr_y_max'}- $self->{'curr_y_min'};$delta=$width / ($self->{'num_datapoints'}> 0 ? $self->{'num_datapoints'}: 1);$map=$height / ($self->{'max_val'}- $self->{'min_val'});if ($self->true($self->{'xy_plot'})){$delta_num=$width / ($self->{'x_max_val'}- $self->{'x_min_val'});if ($self->{'x_min_val'}<= 0 && $self->{'x_max_val'}>= 0){$zero_offset=abs($self->{'x_min_val'})* abs($delta_num)}elsif ($self->{'x_min_val'}> 0 || $self->{'x_max_val'}< 0){$zero_offset=-$self->{'x_min_val'}* $delta_num}else {$zero_offset=0}}if ($self->true($self->{'xy_plot'})){$x1=$self->{'curr_x_min'}}else {$x1=$self->{'curr_x_min'}+ ($delta / 2)}if ($self->{'min_val'}>= 0){$y1=$self->{'curr_y_max'};$mod=$self->{'min_val'}}elsif ($self->{'max_val'}<= 0){$y1=$self->{'curr_y_min'};$mod=$self->{'max_val'}}else {$y1=$self->{'curr_y_min'}+ ($map * $self->{'max_val'});$mod=0;$self->{'gd_obj'}->line($self->{'curr_x_min'},$y1,$self->{'curr_x_max'},$y1,$misccolor)}for$i (1 .. $self->{'num_datasets'}){$color=$self->_color_role_to_index('dataset' .($i - 1));$brush=$self->_prepare_brush($color);$self->{'gd_obj'}->setBrush($brush);for$j (1 .. $self->{'num_datapoints'}- 1){if (defined($data->[$i][$j])and defined($data->[$i][$j - 1 ])){if ($self->true($self->{'xy_plot'})){$x2=$x1 + $delta_num * $data->[0][$j - 1 ]+ $zero_offset;$x3=$x1 + $delta_num * $data->[0][$j]+ $zero_offset}else {$x2=$x1 + ($delta * ($j - 1));$x3=$x1 + ($delta * $j)}$y2=$y1 - (($data->[$i][$j - 1 ]- $mod)* $map);$y3=$y1 - (($data->[$i][$j]- $mod)* $map);if ($self->true($self->{'stepline'})){if ($self->{'stepline_mode'}=~ /^begin$/i){$self->{'gd_obj'}->line($x2,$y2,$x3,$y2,gdBrushed);$self->{'gd_obj'}->line($x3,$y2,$x3,$y3,gdBrushed)}else {$self->{'gd_obj'}->line($x2,$y2,$x2,$y3,gdBrushed);$self->{'gd_obj'}->line($x2,$y3,$x3,$y3,gdBrushed)}}else {$self->{'gd_obj'}->line($x2,$y2,$x3,$y3,gdBrushed)}if (($data->[$i][$j]> $self->{'max_val'})|| ($data->[$i][$j - 1 ]> $self->{'max_val'})){$repair_top_flag=1}if (($self->{'max_val'}<= 0)&& (($data->[$i][$j]> $self->{'max_val'})|| ($data->[$i][$j - 1 ]> $self->{'max_val'}))){$repair_top_flag=1}if (($data->[$i][$j]< $self->{'min_val'})|| ($data->[$i][$j - 1 ]< $self->{'min_val'})){$repair_bottom_flag=1}if ($self->true($self->{'imagemap'})){$self->{'imagemap_data'}->[$i][$j - 1 ]=[$x2,$y2 ];$self->{'imagemap_data'}->[$i][$j]=[$x3,$y3 ]}}else {if ($self->true($self->{'imagemap'})){$self->{'imagemap_data'}->[$i][$j - 1 ]=[undef(),undef()];$self->{'imagemap_data'}->[$i][$j]=[undef(),undef()]}}}}$self->{'gd_obj'}->rectangle($self->{'curr_x_min'},$self->{'curr_y_min'},$self->{'curr_x_max'},$self->{'curr_y_max'},$misccolor);($abs_x_max,$abs_y_max)=$self->{'gd_obj'}->getBounds();if ($repair_top_flag){$self->{'gd_obj'}->filledRectangle($self->{'curr_x_min'}- ($self->{'brush_size'}/ 2),0,$self->{'curr_x_max'},$self->{'curr_y_min'}- 1,$self->_color_role_to_index('background'));$t_x_min=$self->{'curr_x_min'};$t_x_max=$self->{'curr_x_max'};$t_y_min=$self->{'curr_y_min'};$t_y_max=$self->{'curr_y_max'};$self->{'curr_x_min'}=0;$self->{'curr_y_min'}=0;$self->{'curr_x_max'}=$abs_x_max;$self->{'curr_y_max'}=$abs_y_max;if ($self->{'title'}){$self->_draw_title}if ($self->{'sub_title'}){$self->_draw_sub_title}if ($self->{'legend'}=~ /^top$/i){$self->_draw_top_legend}$self->{'curr_x_min'}=$t_x_min;$self->{'curr_x_max'}=$t_x_max;$self->{'curr_y_min'}=$t_y_min;$self->{'curr_y_max'}=$t_y_max}if ($repair_bottom_flag){$self->{'gd_obj'}->filledRectangle($self->{'curr_x_min'}- ($self->{'brush_size'}/ 2),$self->{'curr_y_max'}+ 1,$self->{'curr_x_max'},$abs_y_max,$self->_color_role_to_index('background'));$t_x_min=$self->{'curr_x_min'};$t_x_max=$self->{'curr_x_max'};$t_y_min=$self->{'curr_y_min'};$t_y_max=$self->{'curr_y_max'};$self->{'curr_x_min'}=0;$self->{'curr_y_min'}=0;$self->{'curr_x_max'}=$abs_x_max;$self->{'curr_y_max'}=$abs_y_max - 1;$self->{'curr_y_max'}-= 2 * $self->{'graph_border'};if ($self->{'legend'}=~ /^bottom$/i){$self->_draw_bottom_legend}if ($self->{'x_label'}){$self->_draw_x_label}$self->{'curr_x_min'}=$self->{'temp_x_min'};$self->{'curr_y_min'}=$self->{'temp_y_min'};$self->{'curr_x_max'}=$self->{'temp_x_max'};$self->{'curr_y_max'}=$self->{'temp_y_max'};if ($self->true($self->{'xy_plot'})){$self->_draw_x_number_ticks}else {$self->_draw_x_ticks}$self->{'curr_x_min'}=$t_x_min;$self->{'curr_x_max'}=$t_x_max;$self->{'curr_y_min'}=$t_y_min;$self->{'curr_y_max'}=$t_y_max}return}sub _prepare_brush {my$self=shift;my$color=shift;my$radius=$self->{'brush_size'}/ 2;my (@rgb,$brush,$white,$newcolor);@rgb=$self->{'gd_obj'}->rgb($color);$brush=GD::Image->new($radius * 2,$radius * 2);$white=$brush->colorAllocate(255,255,255);$newcolor=$brush->colorAllocate(@rgb);$brush->transparent($white);$brush->arc($radius - 1,$radius - 1,$radius,$radius,0,360,$newcolor);return$brush}1;
CHART_LINES

$fatpacked{"Chart/LinesPoints.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CHART_LINESPOINTS';
  package Chart::LinesPoints;use Chart::Base '2.4.10';use GD;use Carp;use strict;@Chart::LinesPoints::ISA=qw(Chart::Base);$Chart::LinesPoints::VERSION='2.4.10';sub _draw_data {my$self=shift;my$data=$self->{'dataref'};my$misccolor=$self->_color_role_to_index('misc');my ($x1,$x2,$x3,$y1,$y2,$y3,$mod,$abs_x_max,$abs_y_max);my ($width,$height,$delta,$map,$t_x_min,$t_x_max,$t_y_min,$t_y_max);my ($i,$j,$color,$brush,$zero_offset,$delta_num);my$repair_top_flag=0;my$repair_bottom_flag=0;my$diff;if ($self->true($self->{'imagemap'})){$self->{'imagemap_data'}=[]}$width=$self->{'curr_x_max'}- $self->{'curr_x_min'};$height=$self->{'curr_y_max'}- $self->{'curr_y_min'};$delta=$width / ($self->{'num_datapoints'}> 0 ? $self->{'num_datapoints'}: 1);$diff=($self->{'max_val'}- $self->{'min_val'});$diff=1 if$diff==0;$map=$height / $diff;if ($self->true($self->{'xy_plot'})){$x1=$self->{'curr_x_min'}}else {$x1=$self->{'curr_x_min'}+ ($delta / 2)}if ($self->{'min_val'}>= 0){$y1=$self->{'curr_y_max'};$mod=$self->{'min_val'}}elsif ($self->{'max_val'}<= 0){$y1=$self->{'curr_y_min'};$mod=$self->{'max_val'}}else {$y1=$self->{'curr_y_min'}+ ($map * $self->{'max_val'});$mod=0;$self->{'gd_obj'}->line($self->{'curr_x_min'},$y1,$self->{'curr_x_max'},$y1,$misccolor)}if ($self->true($self->{'xy_plot'})){my ($xmin,$xmax)=($self->{'x_min_val'},$self->{'x_max_val'});if ($self->{'xlabels'}){($xmin,$xmax)=@{$self->{'xrange'}}}$diff=$xmax - $xmin;$diff=1 if$diff==0;$delta_num=$width / $diff;if ($xmin <= 0 && $xmax >= 0){$zero_offset=abs($xmin)* abs($delta_num)}elsif ($xmin > 0 || $xmax < 0){$zero_offset=-$xmin * $delta_num}else {$zero_offset=0}}for$i (1 .. $self->{'num_datasets'}){$color=$self->_color_role_to_index('dataset' .($i - 1));$brush=$self->_prepare_brush($color,'line','dataset' .($i - 1));$self->{'gd_obj'}->setBrush($brush);for$j (1 .. $self->{'num_datapoints'}){if (defined($data->[$i][$j])and defined($data->[$i][$j - 1 ])){if ($self->true($self->{'xy_plot'})){$x2=$x1 + $delta_num * $data->[0][$j - 1 ]+ $zero_offset;$x3=$x1 + $delta_num * $data->[0][$j]+ $zero_offset}else {$x2=$x1 + ($delta * ($j - 1));$x3=$x1 + ($delta * $j)}$y2=$y1 - (($data->[$i][$j - 1 ]- $mod)* $map);$y3=$y1 - (($data->[$i][$j]- $mod)* $map);if (($data->[$i][$j]> $self->{'max_val'})|| ($data->[$i][$j - 1 ]> $self->{'max_val'})){$repair_top_flag=1}if (($self->{'max_val'}<= 0)&& (($data->[$i][$j]> $self->{'max_val'})|| ($data->[$i][$j - 1 ]> $self->{'max_val'}))){$repair_top_flag=1}if (($data->[$i][$j]< $self->{'min_val'})|| ($data->[$i][$j - 1 ]< $self->{'min_val'})){$repair_bottom_flag=1}if ($self->true($self->{'stepline'})){if ($self->{'stepline_mode'}=~ /^begin$/i){$self->{'gd_obj'}->line($x2,$y2,$x3,$y2,gdBrushed);$self->{'gd_obj'}->line($x3,$y2,$x3,$y3,gdBrushed)}else {$self->{'gd_obj'}->line($x2,$y2,$x2,$y3,gdBrushed);$self->{'gd_obj'}->line($x2,$y3,$x3,$y3,gdBrushed)}}else {$self->{'gd_obj'}->line($x2,$y2,$x3,$y3,gdBrushed)}}}$brush=$self->_prepare_brush($color,'point','dataset' .($i - 1));$self->{'gd_obj'}->setBrush($brush);for$j (0 .. $self->{'num_datapoints'}){if (defined($data->[$i][$j])){if ($self->true($self->{'xy_plot'})){$x2=$x1 + $delta_num * $data->[0][$j]+ $zero_offset;$x3=$x2}else {$x2=$x1 + ($delta * $j);$x3=$x2}$y2=$y1 - (($data->[$i][$j]- $mod)* $map);$y3=$y2;$self->{'gd_obj'}->line($x2,$y2,$x3,$y3,gdBrushed);if ($self->true($self->{'imagemap'})){$self->{'imagemap_data'}->[$i][$j]=[$x2,$y2 ]}}else {if ($self->true($self->{'imagemap'})){$self->{'imagemap_data'}->[$i][$j]=[undef(),undef()]}}}}$self->{'gd_obj'}->rectangle($self->{'curr_x_min'},$self->{'curr_y_min'},$self->{'curr_x_max'},$self->{'curr_y_max'},$misccolor);($abs_x_max,$abs_y_max)=$self->{'gd_obj'}->getBounds();if ($repair_top_flag){$self->{'gd_obj'}->filledRectangle($self->{'curr_x_min'}- ($self->{'brush_size'}/ 2),0,$self->{'curr_x_max'},$self->{'curr_y_min'}- 2,$self->_color_role_to_index('background'));$t_x_min=$self->{'curr_x_min'};$t_x_max=$self->{'curr_x_max'};$t_y_min=$self->{'curr_y_min'};$t_y_max=$self->{'curr_y_max'};$self->{'curr_x_min'}=0;$self->{'curr_y_min'}=0;$self->{'curr_x_max'}=$abs_x_max;$self->{'curr_y_max'}=$abs_y_max;if ($self->{'title'}){$self->_draw_title}if ($self->{'sub_title'}){$self->_draw_sub_title}if ($self->{'legend'}=~ /^top$/i){$self->_draw_top_legend}$self->{'curr_x_min'}=$t_x_min;$self->{'curr_x_max'}=$t_x_max;$self->{'curr_y_min'}=$t_y_min;$self->{'curr_y_max'}=$t_y_max}if ($repair_bottom_flag){$self->{'gd_obj'}->filledRectangle($self->{'curr_x_min'}- ($self->{'brush_size'}/ 2),$self->{'curr_y_max'}+ 1,$self->{'curr_x_max'},$abs_y_max,$self->_color_role_to_index('background'));$t_x_min=$self->{'curr_x_min'};$t_x_max=$self->{'curr_x_max'};$t_y_min=$self->{'curr_y_min'};$t_y_max=$self->{'curr_y_max'};$self->{'curr_x_min'}=0;$self->{'curr_y_min'}=0;$self->{'curr_x_max'}=$abs_x_max;$self->{'curr_y_max'}=$abs_y_max - 1;$self->{'curr_y_max'}-= 2 * $self->{'graph_border'};if ($self->{'legend'}=~ /^bottom$/i){$self->_draw_bottom_legend}if ($self->{'x_label'}){$self->_draw_x_label}$self->{'curr_x_min'}=$self->{'temp_x_min'};$self->{'curr_y_min'}=$self->{'temp_y_min'};$self->{'curr_x_max'}=$self->{'temp_x_max'};$self->{'curr_y_max'}=$self->{'temp_y_max'};$self->_draw_x_ticks;$self->{'curr_x_min'}=$t_x_min;$self->{'curr_x_max'}=$t_x_max;$self->{'curr_y_min'}=$t_y_min;$self->{'curr_y_max'}=$t_y_max}return}1;
CHART_LINESPOINTS

$fatpacked{"Chart/Mountain.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CHART_MOUNTAIN';
  package Chart::Mountain;use Chart::Base '2.4.10';use GD;use Carp;use strict;@Chart::Mountain::ISA=qw ( Chart::Base);$Chart::Mountain::VERSION='2.4.10';sub _find_y_range {my$self=shift;my$data=$self->{'dataref'};my$max=undef;for my$i (0 .. $#{$data->[0]}){my$y_sum=$data->[1]->[$i];if (defined$y_sum && $y_sum >= 0){for my$dataset (@$data[2 .. $#$data ]){my$datum=$dataset->[$i];if (defined$datum && $datum >= 0){$y_sum += $datum}else {$y_sum=undef;last}}}if (defined$y_sum){$max=$y_sum unless defined$max && $y_sum <= $max}}(0,$max)}sub _draw_data {my$self=shift;my$data=$self->{'dataref'};my@patterns=@{$self->{'patterns'}|| []};my$x_step=($self->{'curr_x_max'}- $self->{'curr_x_min'})/ ($self->{'num_datapoints'}> 0 ? $self->{'num_datapoints'}: 1);my$x_min=$self->{'curr_x_min'}+ $x_step / 2;my$x_max=$self->{'curr_x_max'}- $x_step / 2;my@x=map {$_ * $x_step + $x_min}0 .. $self->{'num_datapoints'}- 1;my ($t_x_min,$t_x_max,$t_y_min,$t_y_max,$abs_x_max,$abs_y_max);my$repair_top_flag=0;my$map=($self->{'max_val'})? ($self->{'curr_y_max'}- $self->{'curr_y_min'})/ $self->{'max_val'}: ($self->{'curr_y_max'}- $self->{'curr_y_min'})/ 10;my$y_max=$self->{'curr_y_max'};my@y;for my$j (0 .. $#{$data->[0]}){my$sum=0;for my$i (reverse 1 .. $#{$data}){my$datum=$data->[$i][$j];if (defined$datum && $datum > $self->{'max_val'}){$repair_top_flag=1}if (defined$datum && $datum >= 0){$sum += $datum;$y[$i - 1 ][$j]=$y_max - $map * $sum}else {for my$k (1 .. $#{$data}){$y[$k - 1 ][$j]=undef}last}}}my$x_begin=0;my$x_end=$self->{'num_datapoints'}- 1;while ($x_begin <= $x_end &&!defined$y[-1]->[$x_begin]){$x_begin++}while ($x_begin <= $x_end &&!defined$y[-1]->[$x_end]){$x_end--}if ($x_begin > $x_end){croak "Internal error: x_begin > x_end ($x_begin > $x_end)"}my$poly=GD::Polygon->new;$poly->addPt($x[$x_end],$y_max);$poly->addPt($x[$x_begin],$y_max);for my$dataset (reverse 0 .. @y - 1){my$y_ref=$y[$dataset];my$last_vertex_count=$poly->length;if ((@y - 1 - $dataset)% 2){for (reverse$x_begin .. $x_end){$poly->addPt($x[$_],$y_ref->[$_])if defined$y_ref->[$_]}}else {for ($x_begin .. $x_end){$poly->addPt($x[$_],$y_ref->[$_])if defined$y_ref->[$_]}}my$color=$self->_color_role_to_index('dataset' .$dataset);if ($patterns[$dataset]){$self->{'gd_obj'}->filledPolygon($poly,$color)if$patterns[$dataset]->transparent >= 0;$self->{'gd_obj'}->setTile($patterns[$dataset]);$self->{'gd_obj'}->filledPolygon($poly,gdTiled)}else {$self->{'gd_obj'}->filledPolygon($poly,$color)}unless ($dataset==0){while ($last_vertex_count){$poly->deletePt(0);$last_vertex_count--}}}$self->{'gd_obj'}->rectangle($self->{'curr_x_min'},$self->{'curr_y_min'},$self->{'curr_x_max'},$self->{'curr_y_max'},$self->_color_role_to_index('misc'));($abs_x_max,$abs_y_max)=$self->{'gd_obj'}->getBounds();if ($repair_top_flag){$self->{'gd_obj'}->filledRectangle($self->{'curr_x_min'},0,$self->{'curr_x_max'},$self->{'curr_y_min'}- 1,$self->_color_role_to_index('background'));$t_x_min=$self->{'curr_x_min'};$t_x_max=$self->{'curr_x_max'};$t_y_min=$self->{'curr_y_min'};$t_y_max=$self->{'curr_y_max'};$self->{'curr_x_min'}=0;$self->{'curr_y_min'}=0;$self->{'curr_x_max'}=$abs_x_max;$self->{'curr_y_max'}=$abs_y_max;if ($self->{'title'}){$self->_draw_title()}if ($self->{'sub_title'}){$self->_draw_sub_title()}if ($self->{'legend'}=~ /^top$/i){$self->_draw_top_legend()}$self->{'curr_x_min'}=$t_x_min;$self->{'curr_x_max'}=$t_x_max;$self->{'curr_y_min'}=$t_y_min;$self->{'curr_y_max'}=$t_y_max}}require GD;unless (defined&GD::Polygon::deletePt){*GD::Polygon::deletePt=sub {my ($self,$index)=@_;unless (($index >= 0)&& ($index < @{$self->{'points'}})){warn "Attempt to set an undefined polygon vertex";return undef}my ($vertex)=splice(@{$self->{'points'}},$index,1);$self->{'length'}--;return @$vertex}}1;
CHART_MOUNTAIN

$fatpacked{"Chart/Pareto.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CHART_PARETO';
  package Chart::Pareto;use Chart::Base '2.4.10';use GD;use Carp;use strict;@Chart::Pareto::ISA=qw(Chart::Base);$Chart::Pareto::VERSION='2.4.10';sub _find_y_range {my$self=shift;my$data=$self->{'dataref'};my$sum=0;for (my$i=0 ;$i < $self->{'num_datapoints'};$i++ ){if ($data->[1][$i]>= 0){$sum += $data->[1][$i]}else {carp "We need positiv data, if we want to draw a pareto graph!!";return 0}}$self->{'sum'}=$sum;(0,$sum)}sub _sort_data {my$self=shift;my$data=$self->{'dataref'};my@labels=@{$data->[0]};my@values=@{$data->[1]};@labels=@labels[sort {$values[$b]<=> $values[$a]}0 .. $#labels ];@values=sort {$b <=> $a}@values;@{$data->[0]}=@labels;@{$data->[1]}=@values;return 1}sub _draw_legend {my$self=shift;my ($length);my$num_dataset;if ($self->{'legend'}=~ /^none$/){return 1}if (($#{$self->{'legend_labels'}}>= 0)&& ((scalar(@{$self->{'legend_labels'}}))!=2)){carp "I need two legend labels. One for the data and one for the sum."}unless ($self->{'max_legend_label'}){$self->{'max_legend_label'}=0}unless ($self->{'legend_labels'}[0]){$self->{'legend_labels'}[0]="Dataset"}unless ($self->{'legend_labels'}[1]){$self->{'legend_labels'}[1]="Running sum"}if (length($self->{'legend_labels'}[0])> length($self->{'legend_labels'}[1])){$self->{'max_legend_label'}=length($self->{'legend_labels'}[0])}else {$self->{'max_legend_label'}=length($self->{'legend_labels'}[1])}$num_dataset=$self->{'num_datasets'};$self->{'num_datasets'}=2;if ($self->{'legend'}eq 'bottom'){$self->_draw_bottom_legend}elsif ($self->{'legend'}eq 'right'){$self->_draw_right_legend}elsif ($self->{'legend'}eq 'left'){$self->_draw_left_legend}elsif ($self->{'legend'}eq 'top'){$self->_draw_top_legend}else {carp "I can't put a legend there (at " .$self->{'legend'}.")\n"}$self->{'num_datasets'}=$num_dataset;return 1}sub _draw_data {my$self=shift;my$data=$self->{'dataref'};my$misccolor=$self->_color_role_to_index('misc');my ($x1,$x2,$x3,$y1,$y2,$y3,$y1_line,$y2_line,$x1_line,$x2_line,$h,$w);my ($width,$height,$delta1,$delta2,$map,$mod,$cut);my ($i,$j,$color,$line_color,$percent,$per_label,$per_label_len);my$sum=$self->{'sum'};my$curr_sum=0;my$font=$self->{'legend_font'};my$pink=$self->{'gd_obj'}->colorAllocate(255,0,255);my$diff;unless ((ref($font))eq 'GD::Font'){croak "The subtitle font you specified isn\'t a GD Font object"}($h,$w)=($font->height,$font->width);if ($self->true($self->{'imagemap'})){$self->{'imagemap_data'}=[]}$width=$self->{'curr_x_max'}- $self->{'curr_x_min'};$height=$self->{'curr_y_max'}- $self->{'curr_y_min'};$delta1=$width / ($self->{'num_datapoints'}> 0 ? $self->{'num_datapoints'}: 1);$diff=($self->{'max_val'}- $self->{'min_val'});$diff=1 if$diff==0;$map=$height / $diff;if ($self->true($self->{'spaced_bars'})){$delta2=$delta1 / 3}else {$delta2=$delta1}$x1=$self->{'curr_x_min'};$y1=$self->{'curr_y_max'};$y1_line=$y1;$mod=$self->{'min_val'};$x1_line=$self->{'curr_x_min'};$color=$self->_color_role_to_index('dataset0');$line_color=$self->_color_role_to_index('dataset1');for$j (0 .. $self->{'num_datapoints'}){if (defined($data->[1][$j])){$curr_sum += $data->[1][$j];$percent=int($curr_sum / ($sum || 1)* 100);if ($self->true($self->{'spaced_bars'})){$x2=$x1 + ($j * $delta1)+ $delta2}else {$x2=$x1 + ($j * $delta1)}$y2=$y1;$x3=$x2 + $delta2;$y3=$y1 - (($data->[1][$j]- $mod)* $map);if ($data->[1][$j]> $self->{'max_val'}){$y3=$y1 - (($self->{'max_val'}- $mod)* $map);$cut=1}elsif ($data->[1][$j]< $self->{'min_val'}){$y3=$y1 - (($self->{'min_val'}- $mod)* $map);$cut=1}else {$cut=0}$self->{'gd_obj'}->filledRectangle($x2,$y3,$x3,$y2,$color);if ($self->true($self->{'imagemap'})){$self->{'imagemap_data'}->[1][$j]=[$x2,$y3,$x3,$y2 ]}unless ($cut){$self->{'gd_obj'}->rectangle($x2,$y3,$x3,$y2,$misccolor)}else {$self->{'gd_obj'}->rectangle($x2,$y3,$x3,$y2,$pink)}$x2_line=$x3;if ($self->{'max_val'}>= $curr_sum){$y2_line=$y1 - (($curr_sum - $mod)* $map);$self->{'gd_obj'}->line($x1_line,$y1_line,$x2_line,$y2_line,$line_color);$self->{'gd_obj'}->filledRectangle($x2_line - 2,$y2_line - 2,$x2_line + 2,$y2_line + 2,$line_color);$per_label=$percent .'%';$per_label_len=length($per_label)* $w;$self->{'gd_obj'}->string($font,$x2_line - $per_label_len - 1,$y2_line - $h - 1,$per_label,$line_color);$y1_line=$y2_line;$x1_line=$x2_line}else {$y2_line=$y1 - (($self->{'max_val'}- $mod)* $map);$self->{'gd_obj'}->line($x1_line,$y1_line,$x2_line,$y2_line,$pink);$self->{'gd_obj'}->filledRectangle($x2_line - 2,$y2_line - 2,$x2_line + 2,$y2_line + 2,$pink);$per_label=$percent .'%';$per_label_len=length($per_label)* $w;$self->{'gd_obj'}->string($font,$x2_line - $per_label_len - 1,$y2_line - $h - 1,$per_label,$pink);$y1_line=$y2_line;$x1_line=$x2_line}}else {if ($self->true($self->{'imagemap'})){$self->{'imagemap_data'}->[1][$j]=[undef(),undef(),undef(),undef()]}}}$self->{'gd_obj'}->rectangle($self->{'curr_x_min'},$self->{'curr_y_min'},$self->{'curr_x_max'},$self->{'curr_y_max'},$misccolor);return}1;
CHART_PARETO

$fatpacked{"Chart/Pie.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CHART_PIE';
  package Chart::Pie;use Chart::Base '2.4.10';use GD;use Carp;use Chart::Constants;use strict;@Chart::Pie::ISA=qw(Chart::Base);$Chart::Pie::VERSION='2.4.10';sub _draw_data {my$self=shift;my$data=$self->{'dataref'};my$misccolor=$self->_color_role_to_index('misc');my$textcolor=$self->_color_role_to_index('text');my$background=$self->_color_role_to_index('background');my ($width,$height,$centerX,$centerY,$diameter,$diameter_previous,$text_diameter);my$dataset_sum;my ($start_degrees,$end_degrees,$label_degrees,$label_old_degrees,$labelY_repeat_count);my ($pi,$rd2dg,$dg2rd);my ($font,$fontW,$fontH,$labelX,$labelY);my$label;my ($i,$j,$color);my$label_length=0;my$degrees=0;my$insidecolor;my$forbidden_degrees=0;my%labelinfo;my$max_val_len=0;my$max_label_len=0;$pi=Chart::Constants::PI;$dg2rd=$pi / 180;$rd2dg=180 / $pi;$start_degrees=0;$end_degrees=0;$font=$self->{'legend_font'};$fontW=$self->{'legend_font'}->width;$fontH=$self->{'legend_font'}->height;$label_degrees=$labelY_repeat_count=0;if ($self->true($self->{'imagemap'})){$self->{'imagemap_data'}=[]}$width=$self->{'curr_x_max'}- $self->{'curr_x_min'};$height=$self->{'curr_y_max'}- $self->{'curr_y_min'};$dataset_sum=0;for$j (0 .. $self->{'num_datapoints'}){if (defined$data->[1][$j]&& $data->[1][$j]> 0){$dataset_sum += $data->[1][$j];if ($data->[1][$j]< 0){croak "We need positiv data for a pie chart (which is not true for data[$j])!"}}}$max_label_len=1;for$j (0 .. ($self->{'num_datapoints'}- 1)){$labelinfo{$j}{data}='undefined';if (defined($data->[1][$j])&& $data->[1][$j]> 0){$labelinfo{$j}{data}=$data->[1][$j];$label=$data->[0][$j];$labelinfo{$j}{labeldata}=$label;if (defined$self->{'label_values'}){if ($self->{'label_values'}=~ /^percent$/i){$label=sprintf("%s %4.2f%%",$label,$data->[1][$j]/ ($dataset_sum || 1)* 100)}elsif ($self->{'label_values'}=~ /^value$/i){if ($data->[1][$j]=~ /\./){$label=sprintf("%s %.2f",$label,$data->[1][$j])}else {$label=sprintf("%s %d",$label,$data->[1][$j])}}elsif ($self->{'label_values'}=~ /^both$/i){if ($data->[1][$j]=~ /\./){$label=sprintf("%s %4.2f%% %.2f",$label,$data->[1][$j]/ ($dataset_sum || 1)* 100,$data->[1][$j])}else {$label=sprintf("%s %4.2f%% %d",$label,$data->[1][$j]/ ($dataset_sum || 1)* 100,$data->[1][$j])}}elsif ($self->{'label_values'}=~ /^none$/i){$label=sprintf("%s",$label)}}$label_length=length($label);$labelinfo{$j}{labelstring}=$label,$labelinfo{$j}{labellength}=$label_length}$max_label_len=$label_length if ($max_label_len < $label_length)}$max_label_len *= $fontW;$centerX=int($width / 2)+ $self->{'curr_x_min'};$centerY=int($height / 2)+ $self->{'curr_y_min'};my$labeldistance=2 * $self->maximum($fontW,$fontH);$start_degrees=0;$end_degrees=0;my$max_radius=$self->minimum($width,$height)/ 2;my$radius=$max_radius;for$j (0 .. ($self->{'num_datapoints'}- 1)){$end_degrees=$start_degrees + ($data->[1][$j]/ ($dataset_sum || 1)* 360);$degrees=$start_degrees + ($end_degrees - $start_degrees)/ 2;$label_degrees=($start_degrees + $end_degrees)/ 2;$label_degrees=$self->modulo($label_degrees,360.0);$label=$labelinfo{$j}{labelstring};$label_length=$labelinfo{$j}{labellength}|| 0;if (($label_degrees >= 270 && $label_degrees <= 360)|| ($label_degrees >= 0 && $label_degrees <= 90)){{my$x=$radius * sin($dg2rd * $label_degrees);my$y=$radius * cos($dg2rd * $label_degrees);my$right_pos=$centerX + $x + $label_length * $fontW;if ($right_pos > $self->{'curr_x_max'}){$right_pos=$self->{'curr_x_max'};$x=$right_pos - $centerX - $label_length * $fontW}my$top_pos=$centerY - $y - $fontH;if ($top_pos < $self->{'curr_y_min'}){$top_pos=$self->{'curr_y_min'};$y=$centerY - $top_pos - $fontH}my$down_pos=$centerY + $y + $fontH;if ($down_pos > $self->{'curr_y_max'}){$down_pos=$self->{'curr_y_max'};$y=$down_pos - $centerY - $fontH}if ($label_degrees==0){$radius=$self->minimum($radius,abs($y / cos($dg2rd * $label_degrees)))}else {$radius=$self->minimum($radius,$x / sin($dg2rd * $label_degrees),abs($y / cos($dg2rd * $label_degrees)))}$radius=int($radius + 0.5)}if ($radius <= 0){croak "radius < 0!"}}else {if (abs($label_degrees)< 0.1){$radius=$self->{'curr_x_max'}- $label_length * $fontW}else {my$x=$radius * sin($dg2rd * $label_degrees);my$y=$radius * cos($dg2rd * $label_degrees);my$left_pos=$centerX - $x - $label_length * $fontW;if ($left_pos < $self->{'curr_x_min'}){$left_pos=$self->{'curr_x_min'};$x=$centerX - $left_pos - $label_length * $fontW}my$top_pos=$centerY + $y - $fontH;if ($top_pos < $self->{'curr_y_min'}){$top_pos=$self->{'curr_y_min'};$y=$centerY - $top_pos - $fontH}my$down_pos=$centerY - $y + $fontH;if ($down_pos > $self->{'curr_y_max'}){$down_pos=$self->{'curr_y_max'};$y=$centerY + $fontH - $down_pos}$radius=$self->minimum($radius,$x / sin($dg2rd * $label_degrees),abs($y / cos($dg2rd * $label_degrees)));$radius=int($radius + 0.5)}if ($radius <= 0){croak "radius < 0!"}}$start_degrees=$end_degrees}$diameter=$radius * 2 - 2 * $labeldistance;$text_diameter=$diameter + $labeldistance;$self->{'gd_obj'}->arc($centerX,$centerY,$diameter,$diameter,0,360,$misccolor);$start_degrees=0;$end_degrees=0;for$j (0 .. ($self->{'num_datapoints'}- 1)){next if$labelinfo{$j}{data}eq 'undefined';$color=$self->_color_role_to_index('dataset' .$j);$label=$labelinfo{$j}{labelstring};$label_length=$labelinfo{$j}{labellength};$end_degrees=$start_degrees + ($data->[1][$j]/ ($dataset_sum || 1)* 360);$degrees=($start_degrees + $end_degrees)/ 2;$label_degrees=$degrees;$label_degrees=$self->modulo($label_degrees,360.0);if ($start_degrees < $end_degrees){$self->{'gd_obj'}->filledArc($centerX,$centerY,$diameter,$diameter,int($start_degrees - 0.5),int($end_degrees + 0.5),$color)}if ($j==0){$forbidden_degrees=$rd2dg * atan2($fontH,0.5 * $text_diameter);$label_old_degrees=0}else {my$winkel;my$h;if (($label_old_degrees <= 90.0 && $label_degrees > 90.0)|| ($label_old_degrees <= 270.0 && $label_degrees > 270.0)){$forbidden_degrees=0}$label_degrees=$self->maximum($label_degrees,$forbidden_degrees);$label_old_degrees=$label_degrees;$winkel=cos($label_degrees * $dg2rd);$winkel=abs($winkel);if (abs($winkel)< 0.01){$h=0}else {$h=$fontH / $winkel}my$atan=atan2($h,0.5 * $text_diameter);$forbidden_degrees=$label_degrees + $rd2dg * $atan}$labelX=$centerX + $text_diameter * 0.5 * cos($label_degrees * $dg2rd);$labelY=$centerY + $text_diameter * 0.5 * sin($label_degrees * $dg2rd);if (($label_degrees >= 270 && $label_degrees <= 360)|| ($label_degrees >= 0 && $label_degrees <= 90)){$self->{'gd_obj'}->string($font,$labelX,$labelY - $fontH * 0.5,$label,$textcolor)}else {$self->{'gd_obj'}->string($font,$labelX - length($label)* $fontW,$labelY - $fontH * 0.5,$label,$textcolor)}if ($self->true($self->{'legend_lines'})){$self->{'gd_obj'}->line($centerX + 0.5 * $diameter * cos($degrees * $dg2rd),$centerY + 0.5 * $diameter * sin($degrees * $dg2rd),$labelX,$labelY,$color)}$start_degrees=$end_degrees}if (defined($self->{'ring'})&& abs($self->{'ring'})< 1){my$hole=(1 - abs($self->{'ring'}));if ($self->true($self->{'grey_background'})){$insidecolor=$self->_color_role_to_index('grey_background')}else {$insidecolor=$background}$self->{'gd_obj'}->filledArc($centerX,$centerY,$hole * $diameter,$hole * $diameter,0,360,$insidecolor);$self->{'gd_obj'}->arc($centerX,$centerY,$hole * $diameter,$hole * $diameter,0,360,$misccolor)}$self->{'gd_obj'}->rectangle($self->{'curr_x_min'},$self->{'curr_y_min'},$self->{'curr_x_max'},$self->{'curr_y_max'},$misccolor);return}sub _draw_right_legend {my$self=shift;my$data=$self->{'dataref'};my@labels=@{$data->[0]};my ($x1,$x2,$x3,$y1,$y2,$width,$color,$misccolor,$w,$h,$brush);my$font=$self->{'legend_font'};my$l1=0;my$l2=0;my ($i,$j,$label,$dataset_sum);my$max_label_len=1;unless ((ref($font))eq 'GD::Font'){croak "The font you specified isn\'t a GD Font object"}($h,$w)=($font->height,$font->width);$misccolor=$self->_color_role_to_index('misc');$dataset_sum=0;for my$j (0 .. $self->{'num_datapoints'}){if (defined$data->[1][$j]){$dataset_sum += $data->[1][$j]}}for (@labels){if (length($_)> $l1){$l1=length($_)}}for (my$i=0 ;$i < ($self->{'num_datapoints'});$i++ ){if (length($data->[1][$i])> $l2){$l2=length($data->[1][$i])}}if ($self->{'legend_label_values'}=~ /^value$/i){$max_label_len=$l1 + $l2 + 1}elsif ($self->{'legend_label_values'}=~ /^percent$/i){$max_label_len=$l1 + 7}elsif ($self->{'legend_label_values'}=~ /^both$/i){$max_label_len=$l1 + $l2 + 9}else {$max_label_len=$l1}$width=(2 * $self->{'text_space'})+ $max_label_len * $w + $self->{'legend_example_size'}+ (2 * $self->{'legend_space'});$x1=$self->{'curr_x_max'}- $width;$x2=$self->{'curr_x_max'};$y1=$self->{'curr_y_min'}+ $self->{'graph_border'};$y2=$self->{'curr_y_min'}+ $self->{'graph_border'}+ $self->{'text_space'}+ ($self->{'num_datapoints'}* ($h + $self->{'text_space'}))+ (2 * $self->{'legend_space'});$self->{'gd_obj'}->rectangle($x1,$y1,$x2,$y2,$misccolor);$x1 += $self->{'legend_space'};$y1 += $self->{'legend_space'}+ $self->{'text_space'};for (0 .. $#labels){$color=$self->_color_role_to_index('dataset' .$_);$x2=$x1;$x3=$x2 + $self->{'legend_example_size'};$y2=$y1 + ($_ * ($self->{'text_space'}+ $h))+ $h / 2;$self->{'gd_obj'}->line($x2,$y2,$x3,$y2,$color);$brush=$self->_prepare_brush($color,'point',$self->{'pointStyle' .$_ });$self->{'gd_obj'}->setBrush($brush);$self->{'gd_obj'}->line(int(($x3 + $x2)/ 2),$y2,int(($x3 + $x2)/ 2),$y2,gdBrushed);$x2=$x3 + (2 * $self->{'text_space'});$y2 -= $h / 2;if (defined$data->[1][$_]){if ($self->{'legend_label_values'}=~ /^value$/i){$self->{'gd_obj'}->string($font,$x2,$y2,$labels[$_].' ' .$data->[1][$_],$color)}elsif ($self->{'legend_label_values'}=~ /^percent$/i){$label=sprintf("%s %4.2f%%",$labels[$_],$data->[1][$_]/ ($dataset_sum || 1)* 100);$self->{'gd_obj'}->string($font,$x2,$y2,$label,$color)}elsif ($self->{'legend_label_values'}=~ /^both$/i){if ($data->[1][$_]=~ /\./){$label=sprintf("%s %4.2f%% %.2f",$labels[$_],$data->[1][$_]/ ($dataset_sum || 1)* 100,$data->[1][$_])}else {$label=sprintf("%s %4.2f%% %d",$labels[$_],$data->[1][$_]/ ($dataset_sum || 1)* 100,$data->[1][$_])}$self->{'gd_obj'}->string($font,$x2,$y2,$label,$color)}else {$self->{'gd_obj'}->string($font,$x2,$y2,$labels[$_],$color)}}}$self->{'curr_x_max'}-= $width;return 1}sub _draw_left_legend {my$self=shift;my$data=$self->{'dataref'};my@labels=@{$data->[0]};my ($x1,$x2,$x3,$y1,$y2,$width,$color,$misccolor,$w,$h,$brush);my$font=$self->{'legend_font'};my$max_label_len=1;my$l1=0;my$l2=0;my ($dataset_sum,$label);unless ((ref($font))eq 'GD::Font'){croak "The font you specified isn\'t a GD Font object"}($h,$w)=($font->height,$font->width);$misccolor=$self->_color_role_to_index('misc');$dataset_sum=0;for my$j (0 .. $self->{'num_datapoints'}){if (defined$data->[1][$j]){$dataset_sum += $data->[1][$j]}}for (@labels){if (length($_)> $l1){$l1=length($_)}}for (my$i=0 ;$i < ($self->{'num_datapoints'});$i++ ){if (length($data->[1][$i])> $l2){$l2=length($data->[1][$i])}}if ($self->{'legend_label_values'}=~ /^value$/i){$max_label_len=$l1 + $l2 + 1}elsif ($self->{'legend_label_values'}=~ /^percent$/i){$max_label_len=$l1 + 7}elsif ($self->{'legend_label_values'}=~ /^both$/i){$max_label_len=$l1 + $l2 + 9}else {$max_label_len=$l1}$width=(2 * $self->{'text_space'})+ ($max_label_len * $w)+ $self->{'legend_example_size'}+ (2 * $self->{'legend_space'});$x1=$self->{'curr_x_min'};$x2=$self->{'curr_x_min'}+ $width;$y1=$self->{'curr_y_min'}+ $self->{'graph_border'};$y2=$self->{'curr_y_min'}+ $self->{'graph_border'}+ $self->{'text_space'}+ ($self->{'num_datapoints'}* ($h + $self->{'text_space'}))+ (2 * $self->{'legend_space'});$self->{'gd_obj'}->rectangle($x1,$y1,$x2,$y2,$misccolor);$x1 += $self->{'legend_space'};$y1 += $self->{'legend_space'}+ $self->{'text_space'};for (0 .. $#labels){$color=$self->_color_role_to_index('dataset' .$_);$x2=$x1;$x3=$x2 + $self->{'legend_example_size'};$y2=$y1 + ($_ * ($self->{'text_space'}+ $h))+ $h / 2;$self->{'gd_obj'}->line($x2,$y2,$x3,$y2,$color);$brush=$self->_prepare_brush($color,'point',$self->{'pointStyle' .$_ });$self->{'gd_obj'}->setBrush($brush);$self->{'gd_obj'}->line(int(($x3 + $x2)/ 2),$y2,int(($x3 + $x2)/ 2),$y2,gdBrushed);$x2=$x3 + (2 * $self->{'text_space'});$y2 -= $h / 2;if ($self->{'legend_label_values'}=~ /^value$/i){$self->{'gd_obj'}->string($font,$x2,$y2,$labels[$_].' ' .$data->[1][$_],$color)}elsif ($self->{'legend_label_values'}=~ /^percent$/i){$label=sprintf("%s %4.2f%%",$labels[$_],$data->[1][$_]/ ($dataset_sum || 1)* 100);$self->{'gd_obj'}->string($font,$x2,$y2,$label,$color)}elsif ($self->{'legend_label_values'}=~ /^both$/i){if ($data->[1][$_]=~ /\./){$label=sprintf("%s %4.2f%% %.2f",$labels[$_],$data->[1][$_]/ ($dataset_sum || 1)* 100,$data->[1][$_])}else {$label=sprintf("%s %4.2f%% %d",$labels[$_],$data->[1][$_]/ ($dataset_sum || 1)* 100,$data->[1][$_])}$self->{'gd_obj'}->string($font,$x2,$y2,$label,$color)}else {$self->{'gd_obj'}->string($font,$x2,$y2,$labels[$_],$color)}}$self->{'curr_x_min'}+= $width;return 1}sub _draw_bottom_legend {my$self=shift;my$data=$self->{'dataref'};my@labels=@{$data->[0]};my ($x1,$y1,$x2,$x3,$y2,$empty_width,$max_label_width,$cols,$rows,$color,$brush);my ($col_width,$row_height,$r,$c,$index,$x,$y,$w,$h);my$font=$self->{'legend_font'};my$max_label_len;my$l1=0;my$l2=0;my ($dataset_sum,$j);my$label;unless ((ref($font))eq 'GD::Font'){croak "The font you specified isn\'t a GD Font object"}($h,$w)=($font->height,$font->width);$x1=$self->{'curr_x_min'}+ $self->{'graph_border'};$x2=$self->{'curr_x_max'}- $self->{'graph_border'};if ($self->{'y_label'}){$x1 += $self->{'label_font'}->height + 2 * $self->{'text_space'}}if ($self->{'y_label2'}){$x2 -= $self->{'label_font'}->height + 2 * $self->{'text_space'}}$dataset_sum=0;for$j (0 .. $self->{'num_datapoints'}){if (defined$data->[1][$j]){$dataset_sum += $data->[1][$j]}}for (@labels){if (length($_)> $l1){$l1=length($_)}}for (my$i=0 ;$i < ($self->{'num_datapoints'});$i++ ){if (length($data->[1][$i])> $l2){$l2=length($data->[1][$i])}}if ($self->{'legend_label_values'}=~ /^value$/i){$max_label_len=$l1 + $l2 + 1}elsif ($self->{'legend_label_values'}=~ /^percent$/i){$max_label_len=$l1 + 7}elsif ($self->{'legend_label_values'}=~ /^both$/i){$max_label_len=$l1 + $l2 + 9}else {$max_label_len=$l1}$empty_width=($x2 - $x1)- (2 * $self->{'legend_space'});$max_label_width=$max_label_len * $w + (4 * $self->{'text_space'})+ $self->{'legend_example_size'};$cols=int($empty_width / $max_label_width);unless ($cols){$cols=1}$col_width=$empty_width / $cols;$rows=int($self->{'num_datapoints'}/ $cols);unless (($self->{'num_datapoints'}% $cols)==0){$rows++}unless ($rows){$rows=1}$row_height=$h + $self->{'text_space'};$y1=$self->{'curr_y_max'}- $self->{'text_space'}- ($rows * $row_height)- (2 * $self->{'legend_space'});$y2=$self->{'curr_y_max'};$self->{'gd_obj'}->rectangle($x1,$y1,$x2,$y2,$self->_color_role_to_index('misc'));$x1 += $self->{'legend_space'}+ $self->{'text_space'};$x2 -= $self->{'legend_space'};$y1 += $self->{'legend_space'}+ $self->{'text_space'};$y2 -= $self->{'legend_space'}+ $self->{'text_space'};for$r (0 .. $rows - 1){for$c (0 .. $cols - 1){$index=($r * $cols)+ $c;if ($labels[$index]){$color=$self->_color_role_to_index('dataset' .$index);$x=$x1 + ($col_width * $c);$y=$y1 + ($row_height * $r)+ $h / 2;$self->{'gd_obj'}->line($x,$y,$x + $self->{'legend_example_size'},$y,$color);$brush=$self->_prepare_brush($color,'point',$self->{'pointStyle' .$index });$self->{'gd_obj'}->setBrush($brush);$x3=int($x + $self->{'legend_example_size'}/ 2);$self->{'gd_obj'}->line($x3,$y,$x3,$y,gdBrushed);$x += $self->{'legend_example_size'}+ (2 * $self->{'text_space'});$y=$y1 + ($row_height * $r);if ($self->{'legend_label_values'}=~ /^value$/i){$self->{'gd_obj'}->string($font,$x,$y,$labels[$index].' ' .$data->[1][$index],$color)}elsif ($self->{'legend_label_values'}=~ /^percent$/i){$label=sprintf("%s %4.2f%%",$labels[$index],$data->[1][$index]/ ($dataset_sum || 1)* 100);$self->{'gd_obj'}->string($font,$x,$y,$label,$color)}elsif ($self->{'legend_label_values'}=~ /^both$/i){if ($data->[1][$index]=~ /\./){$label=sprintf("%s %4.2f%% %.2f",$labels[$index],$data->[1][$index]/ ($dataset_sum || 1)* 100,$data->[1][$index])}else {$label=sprintf("%s %4.2f%% %d",$labels[$index],$data->[1][$index]/ ($dataset_sum || 1)* 100,$data->[1][$index])}$self->{'gd_obj'}->string($font,$x,$y,$label,$color)}else {$self->{'gd_obj'}->string($font,$x,$y,$labels[$index],$color)}}}}$self->{'curr_y_max'}-= ($rows * $row_height)+ $self->{'text_space'}+ (2 * $self->{'legend_space'});return 1}sub _draw_top_legend {my$self=shift;my$data=$self->{'dataref'};my ($max_label_len);my$l1=0;my$l2=0;my@labels=@{$data->[0]};my ($x1,$y1,$x2,$x3,$y2,$empty_width,$max_label_width,$cols,$rows,$color,$brush);my ($col_width,$row_height,$r,$c,$index,$x,$y,$w,$h,$dataset_sum,$label);my$font=$self->{'legend_font'};unless ((ref($font))eq 'GD::Font'){croak "The font you specified isn\'t a GD Font object"}($h,$w)=($font->height,$font->width);$dataset_sum=0;for my$j (0 .. $self->{'num_datapoints'}){if (defined$data->[1][$j]){$dataset_sum += $data->[1][$j]}}$x1=$self->{'curr_x_min'}+ $self->{'graph_border'};$x2=$self->{'curr_x_max'}- $self->{'graph_border'};if ($self->{'y_label'}){$x1 += $self->{'label_font'}->height + 2 * $self->{'text_space'}}if ($self->{'y_label2'}){$x2 -= $self->{'label_font'}->height + 2 * $self->{'text_space'}}for (@labels){if (length($_)> $l1){$l1=length($_)}}for (my$i=0 ;$i < ($self->{'num_datapoints'});$i++ ){if (length($data->[1][$i])> $l2){$l2=length($data->[1][$i])}}if ($self->{'legend_label_values'}=~ /^value$/i){$max_label_len=$l1 + $l2 + 1}elsif ($self->{'legend_label_values'}=~ /^percent$/i){$max_label_len=$l1 + 7}elsif ($self->{'legend_label_values'}=~ /^both$/i){$max_label_len=$l1 + $l2 + 9}else {$max_label_len=$l1}$empty_width=($x2 - $x1)- (2 * $self->{'legend_space'});$max_label_width=(4 * $self->{'text_space'})+ $max_label_len * $w + $self->{'legend_example_size'};$cols=int($empty_width / $max_label_width);unless ($cols){$cols=1}$col_width=$empty_width / $cols;$rows=int($self->{'num_datapoints'}/ $cols);unless (($self->{'num_datapoints'}% $cols)==0){$rows++}unless ($rows){$rows=1}$row_height=$h + $self->{'text_space'};$y1=$self->{'curr_y_min'};$y2=$self->{'curr_y_min'}+ $self->{'text_space'}+ ($rows * $row_height)+ (2 * $self->{'legend_space'});$self->{'gd_obj'}->rectangle($x1,$y1,$x2,$y2,$self->_color_role_to_index('misc'));$x1 += $self->{'legend_space'}+ $self->{'text_space'};$x2 -= $self->{'legend_space'};$y1 += $self->{'legend_space'}+ $self->{'text_space'};$y2 -= $self->{'legend_space'}+ $self->{'text_space'};for$r (0 .. $rows - 1){for$c (0 .. $cols - 1){$index=($r * $cols)+ $c;if ($labels[$index]){$color=$self->_color_role_to_index('dataset' .$index);$x=$x1 + ($col_width * $c);$y=$y1 + ($row_height * $r)+ $h / 2;$self->{'gd_obj'}->line($x,$y,$x + $self->{'legend_example_size'},$y,$color);$brush=$self->_prepare_brush($color,'point',$self->{'pointStyle' .$index });$self->{'gd_obj'}->setBrush($brush);$x3=int($x + $self->{'legend_example_size'}/ 2);$self->{'gd_obj'}->line($x3,$y,$x3,$y,gdBrushed);$x += $self->{'legend_example_size'}+ (2 * $self->{'text_space'});$y -= $h / 2;if ($self->{'legend_label_values'}=~ /^value$/i){$self->{'gd_obj'}->string($font,$x,$y,$labels[$index].' ' .$data->[1][$index],$color)}elsif ($self->{'legend_label_values'}=~ /^percent$/i){$label=sprintf("%s %4.2f%%",$labels[$index],$data->[1][$index]/ ($dataset_sum || 1)* 100);$self->{'gd_obj'}->string($font,$x,$y,$label,$color)}elsif ($self->{'legend_label_values'}=~ /^both$/i){if ($data->[1][$index]=~ /\./){$label=sprintf("%s %4.2f%% %.2f",$labels[$index],$data->[1][$index]/ ($dataset_sum || 1)* 100,$data->[1][$index])}else {$label=sprintf("%s %4.2f%% %d",$labels[$index],$data->[1][$index]/ ($dataset_sum || 1)* 100,$data->[1][$index])}$self->{'gd_obj'}->string($font,$x,$y,$label,$color)}else {$self->{'gd_obj'}->string($font,$x,$y,$labels[$index],$color)}}}}$self->{'curr_y_min'}+= ($rows * $row_height)+ $self->{'text_space'}+ 2 * $self->{'legend_space'};return 1}sub _draw_x_ticks {my$self=shift;return}sub _draw_y_ticks {my$self=shift;return}sub _find_y_scale {my$self=shift;return}1;
CHART_PIE

$fatpacked{"Chart/Points.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CHART_POINTS';
  package Chart::Points;use Chart::Base '2.4.10';use GD;use Carp;use strict;@Chart::Points::ISA=qw(Chart::Base);$Chart::Points::VERSION='2.4.10';sub _draw_data {my$self=shift;my$data=$self->{'dataref'};my$misccolor=$self->_color_role_to_index('misc');my ($x1,$x2,$x3,$y1,$y2,$y3,$mod);my ($width,$height,$delta,$map,$delta_num,$zero_offset);my ($i,$j,$color,$brush);my$diff;if ($self->true($self->{'imagemap'})){$self->{'imagemap_data'}=[]}$width=$self->{'curr_x_max'}- $self->{'curr_x_min'};$height=$self->{'curr_y_max'}- $self->{'curr_y_min'};$delta=$width / ($self->{'num_datapoints'}> 0 ? $self->{'num_datapoints'}: 1);$diff=($self->{'max_val'}- $self->{'min_val'});$diff=1 if$diff==0;$map=$height / $diff;if ($self->true($self->{'xy_plot'})){$diff=($self->{'x_max_val'}- $self->{'x_min_val'});$diff=1 if$diff==0;$delta_num=$width / $diff;if ($self->{'x_min_val'}<= 0 && $self->{'x_max_val'}>= 0){$zero_offset=abs($self->{'x_min_val'})* abs($delta_num)}elsif ($self->{'x_min_val'}> 0 || $self->{'x_max_val'}< 0){$zero_offset=-$self->{'x_min_val'}* $delta_num}else {$zero_offset=0}}if ($self->false($self->{'xy_plot'})){$x1=$self->{'curr_x_min'}+ ($delta / 2)}else {$x1=$self->{'curr_x_min'}}if ($self->{'min_val'}>= 0){$y1=$self->{'curr_y_max'};$mod=$self->{'min_val'}}elsif ($self->{'max_val'}<= 0){$y1=$self->{'curr_y_min'};$mod=$self->{'max_val'}}else {$y1=$self->{'curr_y_min'}+ ($map * $self->{'max_val'});$mod=0;$self->{'gd_obj'}->line($self->{'curr_x_min'},$y1,$self->{'curr_x_max'},$y1,$misccolor)}for$i (1 .. $self->{'num_datasets'}){$color=$self->_color_role_to_index('dataset' .($i - 1));my$offset=0;($brush,$offset)=$self->_prepare_brush($color,'point','dataset' .($i - 1));$self->{'gd_obj'}->setBrush($brush);for$j (0 .. $self->{'num_datapoints'}){if (defined($data->[$i][$j])){if ($self->true($self->{'xy_plot'})){$x2=$x1 + $delta_num * $data->[0][$j]+ $zero_offset;$x3=$x2}else {$x2=$x1 + ($delta * $j);$x3=$x2}$y2=$y1 - (($data->[$i][$j]- $mod)* $map);$y3=$y2;if ($data->[$i][$j]<= $self->{'max_val'}&& $data->[$i][$j]>= $self->{'min_val'}){$self->{'gd_obj'}->line($x2,$y2,$x3,$y3,gdBrushed)}if ($self->true($self->{'imagemap'})){$self->{'imagemap_data'}->[$i][$j]=[$x2,$y2 ]}}}}$self->{'gd_obj'}->rectangle($self->{'curr_x_min'},$self->{'curr_y_min'},$self->{'curr_x_max'},$self->{'curr_y_max'},$misccolor);return}1;
CHART_POINTS

$fatpacked{"Chart/Split.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CHART_SPLIT';
  package Chart::Split;use Chart::Base '2.4.10';use GD;use Carp;use strict;@Chart::Split::ISA=qw(Chart::Base);$Chart::Split::VERSION='2.4.10';sub _draw_x_number_ticks {my$self=shift;my$data=$self->{'dataref'};my$font=$self->{'tick_label_font'};my$textcolor=$self->_color_role_to_index('text');my$misccolor=$self->_color_role_to_index('misc');my$num_points=$self->{'num_datapoints'};my ($h,$w,$width,$step,$start,$interval,$label,$stag,@labels);my ($x_start,$y_start,$y,$x,$lines,$delta,$ticks);my$x_label_len=1;my$y_label_len=1;my$x_max=-0x80000000;$self->{'grid_data'}->{'x'}=[];$width=$self->{'curr_x_max'}- $self->{'curr_x_min'};$width=1 if$width==0;unless ((ref$font)eq 'GD::Font'){croak "The tick label font you specified isn\'t a GD Font object"}($w,$h)=($font->width,$font->height);unless (defined$self->{'start'}&& defined$self->{'interval'}){croak "I need two values from you to draw a split chart: start and interval!"}else {$interval=$self->{'interval'};$start=$self->{'start'};$ticks=$self->{'interval_ticks'}- 1;$label=$start}if ($ticks==0){$ticks=1}$step=$interval / $ticks;for (0 .. $ticks){push@labels,$self->{f_x_tick}->(sprintf("%." .$self->{'precision'}."f",$label));$label += $step}for (@{$data->[0]}){if ($_ > $x_max){$x_max=$_}}for (@labels){if (length($_)> $x_label_len){$x_label_len=length($_)}}$lines=int((($x_max - $start)/ $interval)+ 0.99999999999);$lines=1 if$lines==0;$y_label_len=length($lines);if ($lines > 1){if ($self->{'y_axes'}=~ /^right$/i){$x_start=$self->{'curr_x_min'};$width=$self->{'curr_x_max'}- $x_start - $self->{'text_space'}* 2 - $y_label_len * $w - $self->{'tick_len'}}elsif ($self->{'y_axes'}=~ /^both$/i){$x_start=$self->{'curr_x_min'}+ ($w * $y_label_len)+ 2 * $self->{'text_space'}+ $self->{'tick_len'};$width=$self->{'curr_x_max'}- $x_start - ($w * $y_label_len)- 2 * $self->{'text_space'}- $self->{'tick_len'}}else {$x_start=$self->{'curr_x_min'}+ ($w * $y_label_len)+ 3 * $self->{'text_space'};$width=$self->{'curr_x_max'}- $x_start}}else {$x_start=$self->{'curr_x_min'};$width=$self->{'curr_x_max'}- $x_start}$y_start=$self->{'curr_y_max'}- $h - $self->{'text_space'};$delta=$width / ($ticks);if (!defined($self->{'skip_x_ticks'})){$self->{'skip_x_ticks'}=1}if ($self->{'x_ticks'}=~ /^normal$/i){if ($self->{'skip_x_ticks'}> 1){for (0 .. $#labels - 1){if (defined($labels[$_ * $self->{'skip_x_ticks'}])){$x=$x_start + $delta * ($_ * $self->{'skip_x_ticks'})- ($w * length($labels[$_ * $self->{'skip_x_ticks'}]))/ 2;$self->{'gd_obj'}->string($font,$x,$y_start,$labels[$_ * $self->{'skip_x_ticks'}],$textcolor)}}}elsif ($self->{'custom_x_ticks'}){for (@{$self->{'custom_x_ticks'}}){if (defined$labels[$_]){$x=$x_start + $delta * $_ - ($w * length($labels[$_]))/ 2;$self->{'gd_obj'}->string($font,$x,$y_start,$labels[$_],$textcolor)}}}else {for (0 .. $#labels){if (defined$labels[$_]){$x=$x_start + $delta * ($_)- ($w * length($labels[$_]))/ 2;$self->{'gd_obj'}->string($font,$x,$y_start,$labels[$_],$textcolor)}}}}elsif ($self->{'x_ticks'}=~ /^staggered$/i){$stag=0;if ($self->{'skip_x_ticks'}> 1){for (0 .. $#labels - 1){if (defined($labels[$_ * $self->{'skip_x_ticks'}])){$x=$x_start + $delta * ($_ * $self->{'skip_x_ticks'})- ($w * length($labels[$_ * $self->{'skip_x_ticks'}]))/ 2;if ($stag % 2==0){$y_start -= $self->{'text_space'}+ $h}$self->{'gd_obj'}->string($font,$x,$y_start,$labels[$_ * $self->{'skip_x_ticks'}],$textcolor);if ($stag % 2==0){$y_start += $self->{'text_space'}+ $h}$stag++}}}elsif ($self->{'custom_x_ticks'}){for (sort (@{$self->{'custom_x_ticks'}})){if (defined$labels[$_]){$x=$x_start + $delta * $_ - ($w * (length($labels[$_])))/ 2;if ($stag % 2==0){$y_start -= $self->{'text_space'}+ $h}$self->{'gd_obj'}->string($font,$x,$y_start,$labels[$_],$textcolor);if ($stag % 2==0){$y_start += $self->{'text_space'}+ $h}$stag++}}}else {for (0 .. $#labels){if (defined$labels[$_]){$x=$x_start + $delta * $_ - ($w * (length($labels[$_])))/ 2;if ($stag % 2==0){$y_start -= $self->{'text_space'}+ $h}$self->{'gd_obj'}->string($font,$x,$y_start,$labels[$_],$textcolor);if ($stag % 2==0){$y_start += $self->{'text_space'}+ $h}$stag++}}}}elsif ($self->{'x_ticks'}=~ /^vertical$/i){$y_start=$self->{'curr_y_max'}- $self->{'text_space'};if ($self->{'skip_x_ticks'}> 1){for (0 .. $#labels){if (defined $_){$x=$x_start + $delta * ($_ * $self->{'skip_x_ticks'})- $h / 2;$y=$y_start - ($x_label_len - length($labels[$_ * $self->{'skip_x_ticks'}]))* $w;$self->{'gd_obj'}->stringUp($font,$x,$y,$labels[$_ * $self->{'skip_x_ticks'}],$textcolor)}}}elsif ($self->{'custom_x_ticks'}){for (@{$self->{'custom_x_ticks'}}){if (defined$labels[$_]){$x=$x_start + $delta * $_ - $h / 2;$y=$y_start - ($x_label_len - length($labels[$_]))* $w;$self->{'gd_obj'}->stringUp($font,$x,$y,$labels[$_],$textcolor)}}}else {for (0 .. $#labels){if (defined$labels[$_]){$x=$x_start + $delta * $_ - $h / 2;$y=$y_start - ($x_label_len - length($labels[$_]))* $w;$self->{'gd_obj'}->stringUp($font,$x,$y,$labels[$_],$textcolor)}}}}if ($self->{'interval_ticks'}> 0){if ($self->{'x_ticks'}=~ /^normal$/i){$self->{'curr_y_max'}-= $h + $self->{'text_space'}* 2}elsif ($self->{'x_ticks'}=~ /^staggered$/i){$self->{'curr_y_max'}-= 2 * $h + 3 * $self->{'text_space'}}elsif ($self->{'x_ticks'}=~ /^vertical$/i){$self->{'curr_y_max'}-= $w * $x_label_len + $self->{'text_space'}* 2}}$y_start=$self->{'curr_y_max'};$y=$y_start - $self->{'tick_len'};if ($self->{'skip_x_ticks'}> 1){for (0 .. int(($#labels)/ $self->{'skip_x_ticks'})){$x=$x_start + $delta * ($_ * $self->{'skip_x_ticks'});$self->{'gd_obj'}->line($x,$y_start,$x,$y,$misccolor);if ($self->true($self->{'grid_lines'})or $self->true($self->{'x_grid_lines'})){$self->{'grid_data'}->{'x'}->[$_]=$x}}}elsif ($self->{'custom_x_ticks'}){for (@{$self->{'custom_x_ticks'}}){if ($_ <= $ticks){$x=$x_start + $delta * $_;$self->{'gd_obj'}->line($x,$y_start,$x,$y,$misccolor);if ($self->true($self->{'grid_lines'})or $self->true($self->{'x_grid_lines'})){$self->{'grid_data'}->{'x'}->[$_]=$x}}}}else {for (0 .. $#labels){$x=$x_start + $_ * $delta;$self->{'gd_obj'}->line($x,$y_start,$x,$y,$misccolor);if ($self->true($self->{'grid_lines'})or $self->true($self->{'x_grid_lines'})){$self->{'grid_data'}->{'x'}->[$_]=$x}}}$self->{'curr_y_max'}-= $self->{'tick_len'}if$self->{'interval_ticks'}> 0;return}sub _draw_x_ticks {my$self=shift;$self->_draw_x_number_ticks();return 1}sub _draw_y_ticks {my$self=shift;my$side=shift || 'left';my$data=$self->{'dataref'};my$font=$self->{'tick_label_font'};my$textcolor=$self->_color_role_to_index('text');my$misccolor=$self->_color_role_to_index('misc');my@labels=@{$self->{'y_tick_labels'}};my$num_points=$self->{'num_datapoints'};my ($w,$h);my ($x_start,$x,$y_start,$y,$start,$interval);my ($height,$delta,$label,$lines,$label_len);my ($s,$f);my$x_max=-0x80000000;$self->{grid_data}->{'y'}=[];$self->{grid_data}->{'y2'}=[];$height=$self->{'curr_y_max'}- $self->{'curr_y_min'};unless ((ref$font)eq 'GD::Font'){croak "The tick label font you specified isn\'t a GD Font object"}($w,$h)=($font->width,$font->height);$interval=$self->{'interval'};$start=$self->{'start'};for (@{$data->[0]}){if ($_ > $x_max){$x_max=$_}}$lines=int((($x_max - $start)/ $interval)+ 0.99999999999);$lines=1 if$lines==0;$label_len=length($lines);$delta=$height / $lines;if ($lines > 1){if ($side =~ /^right$/i){$x_start=$self->{'curr_x_max'};$y_start=$self->{'curr_y_min'};for$label (0 .. $lines - 1){$x=$x_start - $self->{'text_space'}- $label_len * $w;$y=$y_start + $label * $delta + $delta / 2 - $h / 2;$self->{'gd_obj'}->string($font,$x,$y,$label,$textcolor)}for$label (0 .. $lines){$x=$x_start - $self->{'text_space'}* 2 - $label_len * $w - $self->{'tick_len'};$y=$y_start + $label * $delta;$self->{'gd_obj'}->line($x_start - $self->{'text_space'},$y,$x,$y,$misccolor);push @{$self->{grid_data}->{'y'}},$y}$self->{'curr_x_max'}=$x_start - $self->{'text_space'}* 2 - $label_len * $w - $self->{'tick_len'}}elsif ($side =~ /^both$/i){$x_start=$self->{'curr_x_min'};$y_start=$self->{'curr_y_min'};for$label (0 .. $lines - 1){$x=$self->{'curr_x_min'}+ $self->{'text_space'}* 2;$y=$y_start + $label * $delta + $delta / 2 - $h / 2;$self->{'gd_obj'}->string($font,$x,$y,$self->{'f_y_tick'}->($label),$textcolor)}for$label (0 .. $lines){$x=$x_start + $self->{'text_space'}* 2 + $label_len * $w + $self->{'tick_len'};$y=$y_start + $label * $delta;$self->{'gd_obj'}->line($x_start + $self->{'text_space'},$y,$x,$y,$misccolor)}$x_start=$self->{'curr_x_max'};$y_start=$self->{'curr_y_min'};for$label (0 .. $lines - 1){$x=$x_start - $self->{'text_space'}- $label_len * $w;$y=$y_start + $label * $delta + $delta / 2 - $h / 2;$self->{'gd_obj'}->string($font,$x,$y,$self->{'f_y_tick'}->($label),$textcolor)}for$label (0 .. $lines){$x=$x_start - $self->{'text_space'}* 2 - $label_len * $w - $self->{'tick_len'};$y=$y_start + $label * $delta;$self->{'gd_obj'}->line($x_start - $self->{'text_space'},$y,$x,$y,$misccolor);push @{$self->{grid_data}->{'y'}},$y}$self->{'curr_x_min'}+= $self->{'text_space'}* 2 + $label_len * $w + $self->{'tick_len'};$self->{'curr_x_max'}=$x_start - $self->{'text_space'}* 2 - $label_len * $w - $self->{'tick_len'}}else {$x_start=$self->{'curr_x_min'};$y_start=$self->{'curr_y_min'};for$label (0 .. $lines - 1){$x=$self->{'curr_x_min'}+ $self->{'text_space'}* 2;$y=$y_start + $label * $delta + $delta / 2 - $h / 2;$self->{'gd_obj'}->string($font,$x,$y,$self->{'f_y_tick'}->($label),$textcolor)}for$label (0 .. $lines){$x=$x_start + $label_len * $w + $self->{'tick_len'}+ $self->{'text_space'}* 3;$y=$y_start + $label * $delta;$self->{'gd_obj'}->line($x_start + $self->{'text_space'},$y,$x,$y,$misccolor);push @{$self->{grid_data}->{'y'}},$y}$self->{'curr_x_min'}=$x_start + $self->{'text_space'}* 3 + $label_len * $w}}return 1}sub _draw_data {my$self=shift;my$data=$self->{'dataref'};my$misccolor=$self->_color_role_to_index('misc');my$num_points=$self->{'num_datapoints'};$num_points=1 if$num_points==0;my$num_sets=$self->{'num_datasets'};$num_sets=1 if$num_sets==0;my ($lines,$split,$width,$height,$delta_lines,$delta_sets,$map,$last_line);my ($akt_line,$akt_set,$akt_point,$color,$x_start,$y_start,$x,$y);my ($x_last,$y_last,$delta_point,$brush,$mod,$x_interval,$start);my$i=0;my$interval=($self->{'max_val'}- $self->{'min_val'});$interval=1 if$interval==0;my$x_max=-0x80000000;$width=$self->{'curr_x_max'}- $self->{'curr_x_min'};$width=1 if$width==0;$height=$self->{'curr_y_max'}- $self->{'curr_y_min'};$height=1 if$height==0;if ($self->true($self->{'imagemap'})){$self->{'imagemap_data'}=[]}$x_interval=$self->{'interval'};$x_interval=1 if$x_interval==0;$start=$self->{'start'};for (@{$data->[0]}){if ($_ > $x_max){$x_max=$_}}$lines=int((($x_max - $start)/ $x_interval)+ 0.99999999999);$lines=1 if$lines==0;$delta_lines=$height / $lines;$delta_sets=$delta_lines / $num_sets;$delta_point=$width / ($x_interval);$map=$delta_sets / $interval;if ($self->{'min_val'}>= 0){$mod=$self->{'min_val'};if ($self->{'scale'}> 1){$y_start=$self->{'curr_y_min'}+ ($interval * $map / 2)* ($self->{'scale'}- 1)}else {$y_start=$self->{'curr_y_min'}}}elsif ($self->{'max_val'}<= 0){$mod=$self->{'min_val'};if ($self->{'scale'}> 1){$y_start=$self->{'curr_y_min'}+ ($interval * $map / 2)* ($self->{'scale'}- 1)}else {$y_start=$self->{'curr_y_min'}}}else {$y_start=$self->{'curr_y_min'}+ ($map * $self->{'min_val'});$mod=0}$x_start=$self->{'curr_x_min'};for$akt_set (0 .. $num_sets - 1){for$akt_point (0 .. $self->{'num_datapoints'}- 1){$color=$self->_color_role_to_index('dataset' .$akt_set);$brush=$self->_prepare_brush($color,'line');$self->{'gd_obj'}->setBrush($brush);$last_line=0;for$akt_line ($last_line .. $lines - 1){$last_line=$akt_line;if (defined$data->[0][$akt_point]){if ($data->[0][$akt_point]<= (($akt_line + 1)* $x_interval + $start)&& $data->[0][$akt_point]>= $akt_line * $x_interval + $start){$x=$x_start + ($data->[0][$akt_point]- ($akt_line * $x_interval)- ($start))* $delta_point;$y=$y_start + $akt_line * $delta_lines + $akt_set * $delta_sets + $delta_sets - ($data->[1 + $akt_set ][$akt_point]- $mod)* $map * $self->{'scale'};$self->{'gd_obj'}->line($x_last,$y_last,$x,$y,gdBrushed)if$akt_point!=0;if (defined($data->[0][$akt_point + 1 ])&& $data->[0][$akt_point + 1 ]<= (($akt_line + 1)* $x_interval + $start)&& $data->[0][$akt_point + 1 ]> $akt_line * $x_interval + $start){$x_last=$x;$y_last=$y}else {$x_last=$self->{'curr_x_min'};$y_last=$y_start + ($akt_line + 1)* $delta_lines + $akt_set * $delta_sets + $delta_sets - ($data->[1 + $akt_set ][$akt_point]- $mod)* $map * $self->{'scale'}}if ($self->true($self->{'imagemap'})){$self->{'imagemap_data'}->[$akt_set][$akt_point - 1 ]=[$x_last,$y_last ];$self->{'imagemap_data'}->[$akt_set][$akt_point]=[$x,$y ]}}else {next}}else {if ($self->true($self->{'imagemap'})){$self->{'imagemap_data'}->[$akt_set][$akt_point - 1 ]=[undef(),undef()];$self->{'imagemap_data'}->[$akt_set][$akt_point]=[undef(),undef()]}}}}}$y_start=$self->{'curr_y_min'};for$akt_set (0 .. $num_sets - 1){for$akt_line (0 .. $lines - 1){$self->{'gd_obj'}->line($x_start,$y_start + $akt_line * $delta_lines + $akt_set * $delta_sets,$x_start + $self->{'tick_len'},$y_start + $akt_line * $delta_lines + $akt_set * $delta_sets,$misccolor);$self->{'gd_obj'}->line($self->{'curr_x_max'},$y_start + $akt_line * $delta_lines + $akt_set * $delta_sets,$self->{'curr_x_max'}- $self->{'tick_len'},$y_start + $akt_line * $delta_lines + $akt_set * $delta_sets,$misccolor)}}$self->{'gd_obj'}->rectangle($self->{'curr_x_min'},$self->{'curr_y_min'},$self->{'curr_x_max'},$self->{'curr_y_max'},$misccolor);return}1;
CHART_SPLIT

$fatpacked{"Chart/StackedBars.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CHART_STACKEDBARS';
  package Chart::StackedBars;use Chart::Base '2.4.10';use GD;use Carp;use strict;@Chart::StackedBars::ISA=qw(Chart::Base);$Chart::StackedBars::VERSION='2.4.10';sub _check_data {my$self=shift;my$data=$self->{'dataref'};my$length=0;my ($i,$j,$posneg);my$composite;if (defined$self->{'composite_info'}){if ($self->{'composite_info'}[0][0]=~ /^StackedBars$/i){$composite=0}if ($self->{'composite_info'}[1][0]=~ /^StackedBars$/i){$composite=1}$self->{'num_datasets'}=($#{$self->{'composite_info'}[$composite][1]})+ 1}else {$self->{'num_datasets'}=$#{$data}}$self->{'num_datapoints'}=0;for (0 .. $self->{'num_datasets'}){if (scalar(@{$data->[$_]})> $self->{'num_datapoints'}){$self->{'num_datapoints'}=scalar(@{$data->[$_]})}}for$i (0 .. $self->{'num_datapoints'}- 1){$posneg='';for$j (1 .. $self->{'num_datasets'}){if ($data->[$j][$i]> 0){if ($posneg eq 'neg'){croak "The values for a Chart::StackedBars data point must either be all positive or all negative"}else {$posneg='pos'}}elsif ($data->[$j][$i]< 0){if ($posneg eq 'pos'){croak "The values for a Chart::StackedBars data point must either be all positive or all negative"}else {$posneg='neg'}}}}$self->_find_y_scale;for (@{$data->[0]}){if (length($_)> $length){$length=length($_)}}$self->{'x_tick_label_length'}=$length;return}sub _find_y_range {my$self=shift;my$data=$self->{'dataref'};my$max=undef;my$min=undef;for my$i (0 .. $#{$data->[0]}){my$sum=$data->[1]->[$i]|| 0;for my$dataset (@$data[2 .. $#$data ]){my$datum=$dataset->[$i];$sum += $datum if defined$datum}if (defined$max){if ($sum > $max){$max=$sum}elsif ($sum < $min){$min=$sum}}else {$min=$max=$sum}}if (($max > 0)&& ($min > 0)){$min=0}if (($min < 0)&& ($max < 0)){$max=0}($min,$max)}sub _draw_data {my$self=shift;my$raw=$self->{'dataref'};my$data=[];my$misccolor=$self->_color_role_to_index('misc');my ($width,$height,$delta,$map,$mod);my ($x1,$y1,$x2,$y2,$x3,$y3,$i,$j,$color,$cut);my$pink=$self->{'gd_obj'}->colorAllocate(255,0,255);if ($self->true($self->{'imagemap'})){$self->{'imagemap_data'}=[]}$width=$self->{'curr_x_max'}- $self->{'curr_x_min'};if ($self->true($self->{'spaced_bars'})){$delta=($width / ($self->{'num_datapoints'}* 2))}else {$delta=$width / $self->{'num_datapoints'}}$height=$self->{'curr_y_max'}- $self->{'curr_y_min'};$map=$height / ($self->{'max_val'}- $self->{'min_val'});$x1=$self->{'curr_x_min'};if ($self->{'min_val'}>= 0){$y1=$self->{'curr_y_max'};$mod=$self->{'min_val'}}elsif ($self->{'max_val'}<= 0){$y1=$self->{'curr_y_min'};$mod=$self->{'max_val'}}else {$y1=$self->{'curr_y_min'}+ ($map * $self->{'max_val'});$mod=0;$self->{'gd_obj'}->line($self->{'curr_x_min'},$y1,$self->{'curr_x_max'},$y1,$misccolor)}$data->[1]=[@{$raw->[1]}];for$i (0 .. $self->{'num_datapoints'}- 1){for$j (2 .. $self->{'num_datasets'}){$data->[$j][$i]=$data->[$j - 1 ][$i]+ $raw->[$j][$i]}}for$i (0 .. $self->{'num_datapoints'}- 1){$y2=$y1;for$j (1 .. $self->{'num_datasets'}){$color=$self->_color_role_to_index('dataset' .($j - 1));if ($self->true($self->{'spaced_bars'})){$x2=$x1 + (2 * $i * $delta)+ ($delta / 2);$x3=$x2 + $delta}else {$x2=$x1 + ($i * $delta);$x3=$x2 + $delta}$y3=$y1 - (($data->[$j][$i]- $mod)* $map);if ($data->[$j][$i]> $self->{'max_val'}){$y3=$y1 - (($self->{'max_val'}- $mod)* $map);$cut=1}elsif ($data->[$j][$i]< $self->{'min_val'}){$y3=$y1 - (($self->{'min_val'}- $mod)* $map);$cut=1}else {$cut=0}if ($data->[$j][$i]> 0){$self->{'gd_obj'}->filledRectangle($x2,$y3,$x3,$y2,$color);if ($self->true($self->{'imagemap'})){$self->{'imagemap_data'}->[$j][$i]=[$x2,$y3,$x3,$y2 ]}}else {$self->{'gd_obj'}->filledRectangle($x2,$y2,$x3,$y3,$color);if ($self->true($self->{'imagemap'})){$self->{'imagemap_data'}->[$j][$i]=[$x2,$y2,$x3,$y3 ]}}unless ($cut){$self->{'gd_obj'}->rectangle($x2,$y2,$x3,$y3,$misccolor)}else {$self->{'gd_obj'}->rectangle($x2,$y2,$x3,$y3,$misccolor);$self->{'gd_obj'}->rectangle($x2,$y1,$x3,$y3,$pink)}$y2=$y3}}$self->{'gd_obj'}->rectangle($self->{'curr_x_min'},$self->{'curr_y_min'},$self->{'curr_x_max'},$self->{'curr_y_max'},$misccolor);return}sub _draw_left_legend {my$self=shift;my@labels=@{$self->{'legend_labels'}};my ($x1,$x2,$x3,$y1,$y2,$width,$color,$misccolor,$w,$h,$brush);my$font=$self->{'legend_font'};unless ((ref($font))eq 'GD::Font'){croak "The subtitle font you specified isn\'t a GD Font object"}($h,$w)=($font->height,$font->width);$misccolor=$self->_color_role_to_index('misc');$width=(2 * $self->{'text_space'})+ ($self->{'max_legend_label'}* $w)+ $self->{'legend_example_size'}+ (2 * $self->{'legend_space'});$x1=$self->{'curr_x_min'};$x2=$self->{'curr_x_min'}+ $width;$y1=$self->{'curr_y_min'}+ $self->{'graph_border'};$y2=$self->{'curr_y_min'}+ $self->{'graph_border'}+ $self->{'text_space'}+ ($self->{'num_datasets'}* ($h + $self->{'text_space'}))+ (2 * $self->{'legend_space'});$self->{'gd_obj'}->rectangle($x1,$y1,$x2,$y2,$misccolor);$x1 += $self->{'legend_space'};$y1 += $self->{'legend_space'}+ $self->{'text_space'};for (0 .. $#labels){my$c=$self->{'num_datasets'}- $_ - 1;if ($self->{'dataref'}[1][0]< 0){$color=$self->_color_role_to_index('dataset' .$_)}else {$color=$self->_color_role_to_index('dataset' .$c)}$x2=$x1;$x3=$x2 + $self->{'legend_example_size'};$y2=$y1 + ($_ * ($self->{'text_space'}+ $h))+ $h / 2;$self->{'gd_obj'}->line($x2,$y2,$x3,$y2,$color);$brush=$self->_prepare_brush($color,'point',$self->{'pointStyle' .$_ });$self->{'gd_obj'}->setBrush($brush);$self->{'gd_obj'}->line(int(($x3 + $x2)/ 2),$y2,int(($x3 + $x2)/ 2),$y2,gdBrushed);$x2=$x3 + (2 * $self->{'text_space'});$y2 -= $h / 2;if ($self->{'dataref'}[1][0]< 0){$self->{'gd_obj'}->string($font,$x2,$y2,$labels[$_],$color)}else {$self->{'gd_obj'}->string($font,$x2,$y2,$labels[$c],$color)}}$self->{'curr_x_min'}+= $width;return 1}sub _draw_right_legend {my$self=shift;my@labels=@{$self->{'legend_labels'}};my ($x1,$x2,$x3,$y1,$y2,$width,$color,$misccolor,$w,$h,$brush);my$font=$self->{'legend_font'};unless ((ref($font))eq 'GD::Font'){croak "The subtitle font you specified isn\'t a GD Font object"}($h,$w)=($font->height,$font->width);$misccolor=$self->_color_role_to_index('misc');$width=(2 * $self->{'text_space'})+ ($self->{'max_legend_label'}* $w)+ $self->{'legend_example_size'}+ (2 * $self->{'legend_space'});$x1=$self->{'curr_x_max'}- $width;$x2=$self->{'curr_x_max'};$y1=$self->{'curr_y_min'}+ $self->{'graph_border'};$y2=$self->{'curr_y_min'}+ $self->{'graph_border'}+ $self->{'text_space'}+ ($self->{'num_datasets'}* ($h + $self->{'text_space'}))+ (2 * $self->{'legend_space'});$self->{'gd_obj'}->rectangle($x1,$y1,$x2,$y2,$misccolor);$x1 += $self->{'legend_space'};$y1 += $self->{'legend_space'}+ $self->{'text_space'};for (0 .. $#labels){my$c=$self->{'num_datasets'}- $_ - 1;if ($self->{'dataref'}[1][0]< 0){$color=$self->_color_role_to_index('dataset' .$_)}else {$color=$self->_color_role_to_index('dataset' .$c)}$x2=$x1;$x3=$x2 + $self->{'legend_example_size'};$y2=$y1 + ($_ * ($self->{'text_space'}+ $h))+ $h / 2;$self->{'gd_obj'}->line($x2,$y2,$x3,$y2,$color);$brush=$self->_prepare_brush($color,'point',$self->{'pointStyle' .$_ });$self->{'gd_obj'}->setBrush($brush);$self->{'gd_obj'}->line(int(($x3 + $x2)/ 2),$y2,int(($x3 + $x2)/ 2),$y2,gdBrushed);$x2=$x3 + (2 * $self->{'text_space'});$y2 -= $h / 2;if ($self->{'dataref'}[1][0]< 0){$self->{'gd_obj'}->string($font,$x2,$y2,$labels[$_],$color)}else {$self->{'gd_obj'}->string($font,$x2,$y2,$labels[$c],$color)}}$self->{'curr_x_max'}-= $width;return 1}1;
CHART_STACKEDBARS

$fatpacked{"Crypt/XXTEA_PP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CRYPT_XXTEA_PP';
  package Crypt::XXTEA_PP;use strict;use warnings;use utf8;use integer;use Carp;our$VERSION='0.0102';use Config;BEGIN {if (not defined$Config{use64bitint}){require bigint;bigint->import}}my$DELTA=0x9e3779b9;my$FACTOR=4;my$KEY_SIZE=16;my$ELEMENTS_IN_KEY=$KEY_SIZE / $FACTOR;my$MIN_BLOCK_SIZE=8;my$MIN_ELEMENTS_IN_BLOCK=$MIN_BLOCK_SIZE / $FACTOR;use constant keysize=>$KEY_SIZE;use constant blocksize=>$MIN_BLOCK_SIZE;sub isint {local $_=shift;return 0 unless defined;return 1 if /\A\s*[+-]?(?:0|[1-9][0-9]*)\s*\z/s;0}sub all (&@) {my$f=shift;$f->()or return 0 foreach @_;return 1}sub new {my$class=shift;my$key=shift;my$xxtea_key;croak('key is required')if not defined$key;if (my$ref_of_key=ref($key)){croak(sprintf('key must be a %d-byte-long STRING or a reference of ARRAY',$KEY_SIZE))if not $ref_of_key eq 'ARRAY';croak(sprintf('key must has %d elements if key is a reference of ARRAY',$ELEMENTS_IN_KEY))if scalar(@{$key})!=$ELEMENTS_IN_KEY;croak('each element of key must be a 32bit Integer if key is a reference of ARRAY')if not all {isint($_)!=0}@{$key};$xxtea_key=$key}else {croak(sprintf('key must be a %d-byte-long STRING or a reference of ARRAY',$KEY_SIZE))if length$key!=$KEY_SIZE;$xxtea_key=key_setup($key)}my$self={key=>$xxtea_key,};bless$self,ref($class)|| $class}sub encrypt {my$self=shift;my$plain_text=shift;croak(sprintf('plain_text size must be at least %d bytes',$MIN_BLOCK_SIZE))if length($plain_text)< $MIN_BLOCK_SIZE;croak(sprintf('plain_text size must be a multiple of %d bytes',$FACTOR))if length($plain_text)% $FACTOR!=0;my@block=unpack 'N*',$plain_text;my$cipher_text_ref=$self->encrypt_block(\@block);return pack('N*',@{$cipher_text_ref})}sub decrypt {my$self=shift;my$cipher_text=shift;croak(sprintf('cipher_text size must be at least %d bytes',$MIN_BLOCK_SIZE))if length($cipher_text)< $MIN_BLOCK_SIZE;croak(sprintf('cipher_text size must be a multiple of %d bytes',$FACTOR))if length($cipher_text)% $FACTOR!=0;my@block=unpack 'N*',$cipher_text;my$plain_text_ref=$self->decrypt_block(\@block);return pack('N*',@{$plain_text_ref})}sub encrypt_block {my$self=shift;my$block_ref=shift;my$key_ref=$self->{key};croak(sprintf('block must has at least %d elements',$MIN_ELEMENTS_IN_BLOCK))if scalar(@{$block_ref})< $MIN_ELEMENTS_IN_BLOCK;croak(sprintf('key must has %d elements',$ELEMENTS_IN_KEY))if scalar(@{$key_ref})!=$ELEMENTS_IN_KEY;my@block=map {$_ & 0xffff_ffff}@{$block_ref};my@key=map {$_ & 0xffff_ffff}@{$key_ref};my$delta=$DELTA & 0xffff_ffff;my$rounds=6 + 52 / (scalar@block);my$sum=0 & 0xffff_ffff;my$z=$block[-1];my ($e,$p,$y);for (0 .. $rounds-1){$sum=($sum + $delta)& 0xffff_ffff;$e=($sum >> 2)& 3;for (0 .. $#block-1){$p=$_;$y=$block[$p + 1 ];$z=$block[$p ]=($block[$p ]+ _MX($y,$z,$sum,$p,$e,\@key))& 0xffff_ffff}$p += 1;$y=$block[0];$z=$block[-1]=($block[-1]+ _MX($y,$z,$sum,$p,$e,\@key))& 0xffff_ffff}return \@block}sub decrypt_block {my$self=shift;my$block_ref=shift;my$key_ref=$self->{key};croak(sprintf('block must has at least %d elements',$MIN_ELEMENTS_IN_BLOCK))if scalar(@{$block_ref})< $MIN_ELEMENTS_IN_BLOCK;croak(sprintf('key must has %d elements',$ELEMENTS_IN_KEY))if scalar(@{$key_ref})!=$ELEMENTS_IN_KEY;my@block=map {$_ & 0xffff_ffff}@{$block_ref};my@key=map {$_ & 0xffff_ffff}@{$key_ref};my$delta=$DELTA & 0xffff_ffff;my$rounds=6 + 52 / (scalar@block);my$sum=($rounds * $delta)& 0xffff_ffff;my$y=$block[0];my ($e,$p,$z);for (0 .. $rounds-1){$e=($sum >> 2)& 3;for (reverse 1 .. $#block){$p=$_;$z=$block[$p - 1 ];$y=$block[$p ]=($block[$p ]- _MX($y,$z,$sum,$p,$e,\@key))& 0xffff_ffff}$p -= 1;$z=$block[-1];$y=$block[0]=($block[0]- _MX($y,$z,$sum,$p,$e,\@key))& 0xffff_ffff;$sum=($sum - $delta)& 0xffff_ffff}return \@block}sub _MX {my ($y,$z,$sum,$p,$e,$key)=@_;return ((((((($z >> 5)& 0xffff_ffff)^ (($y << 2)& 0xffff_ffff))& 0xffff_ffff)+ (((($y >> 3)& 0xffff_ffff)^ (($z << 4)& 0xffff_ffff))& 0xffff_ffff))& 0xffff_ffff)^ (((($sum ^ $y)& 0xffff_ffff)+ (($key->[($p & 3)^ $e ]^ $z)& 0xffff_ffff))& 0xffff_ffff))& 0xffff_ffff}sub key_setup {my$key_str=shift;croak(sprintf('key must be %s bytes long',$KEY_SIZE))if length($key_str)!=$KEY_SIZE;my@xxtea_key=unpack 'N*',$key_str;return \@xxtea_key}1;
CRYPT_XXTEA_PP

$fatpacked{"Date/Parse.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DATE_PARSE';
  package Date::Parse;require 5.000;use strict;use vars qw($VERSION @ISA @EXPORT);use Time::Local;use Carp;use Time::Zone;use Exporter;@ISA=qw(Exporter);@EXPORT=qw(&strtotime &str2time &strptime);$VERSION="2.30";my%month=(january=>0,february=>1,march=>2,april=>3,may=>4,june=>5,july=>6,august=>7,september=>8,sept=>8,october=>9,november=>10,december=>11,);my%day=(sunday=>0,monday=>1,tuesday=>2,tues=>2,wednesday=>3,wednes=>3,thursday=>4,thur=>4,thurs=>4,friday=>5,saturday=>6,);my@suf=(qw(th st nd rd th th th th th th))x 3;@suf[11,12,13]=qw(th th th);map {$month{substr($_,0,3)}=$month{$_}}keys%month;map {$day{substr($_,0,3)}=$day{$_}}keys%day;my$strptime=<<'ESQ';use vars qw($day_ref $mon_ref $suf_ref $obj);sub gen_parser {local($day_ref,$mon_ref,$suf_ref,$obj)=@_;if($obj){my$obj_strptime=$strptime;substr($obj_strptime,index($strptime,"sub")+6,0)=<<'ESQ';my$sub=eval "$obj_strptime" or die $@;return$sub}eval "$strptime" or die $@}*strptime=gen_parser(\%day,\%month,\@suf);sub str2time {my@t=strptime(@_);return undef unless@t;my($ss,$mm,$hh,$day,$month,$year,$zone)=@t;my@lt=localtime(time);$hh ||=0;$mm ||=0;$ss ||=0;my$frac=$ss - int($ss);$ss=int$ss;$month=$lt[4]unless(defined$month);$day=$lt[3]unless(defined$day);$year=($month > $lt[4])? ($lt[5]- 1): $lt[5]unless(defined$year);return undef unless($month <= 11 && $day >= 1 && $day <= 31 && $hh <= 23 && $mm <= 59 && $ss <= 59);my$result;if (defined$zone){$result=eval {local$SIG{__DIE__}=sub {};timegm($ss,$mm,$hh,$day,$month,$year)};return undef if!defined$result or $result==-1 && join("",$ss,$mm,$hh,$day,$month,$year)ne "595923311169";$result -= $zone}else {$result=eval {local$SIG{__DIE__}=sub {};timelocal($ss,$mm,$hh,$day,$month,$year)};return undef if!defined$result or $result==-1 && join("",$ss,$mm,$hh,$day,$month,$year)ne join("",(localtime(-1))[0..5])}return$result + $frac}1;
   my %month = map { lc $_ } %$mon_ref;
   my $daypat = join("|", map { lc $_ } reverse sort keys %$day_ref);
   my $monpat = join("|", reverse sort keys %month);
   my $sufpat = join("|", reverse sort map { lc $_ } @$suf_ref);
  
   my %ampm = (
  	'a' => 0,  # AM
  	'p' => 12, # PM
  	);
  
   my($AM, $PM) = (0,12);
  
  sub {
  
    my $dtstr = lc shift;
    my $merid = 24;
  
    my($year,$month,$day,$hh,$mm,$ss,$zone,$dst,$frac);
  
    $zone = tz_offset(shift) if @_;
  
    1 while $dtstr =~ s#\([^\(\)]*\)# #o;
  
    $dtstr =~ s#(\A|\n|\Z)# #sog;
  
    # ignore day names
    $dtstr =~ s#([\d\w\s])[\.\,]\s#$1 #sog;
    $dtstr =~ s/,/ /g;
    $dtstr =~ s#($daypat)\s*(den\s)?\b# #o;
    # Time: 12:00 or 12:00:00 with optional am/pm
  
    return unless $dtstr =~ /\S/;
    
    if ($dtstr =~ s/\s(\d{4})([-:]?)(\d\d?)\2(\d\d?)(?:[-Tt ](\d\d?)(?:([-:]?)(\d\d?)(?:\6(\d\d?)(?:[.,](\d+))?)?)?)?(?=\D)/ /) {
      ($year,$month,$day,$hh,$mm,$ss,$frac) = ($1,$3-1,$4,$5,$7,$8,$9);
    }
  
    unless (defined $hh) {
      if ($dtstr =~ s#[:\s](\d\d?):(\d\d?)(:(\d\d?)(?:\.\d+)?)?(z)?\s*(?:([ap])\.?m?\.?)?\s# #o) {
        ($hh,$mm,$ss) = ($1,$2,$4);
        $zone = 0 if $5;
        $merid = $ampm{$6} if $6;
      }
  
      # Time: 12 am
      
      elsif ($dtstr =~ s#\s(\d\d?)\s*([ap])\.?m?\.?\s# #o) {
        ($hh,$mm,$ss) = ($1,0,0);
        $merid = $ampm{$2};
      }
    }
      
    if (defined $hh and $hh <= 12 and $dtstr =~ s# ([ap])\.?m?\.?\s# #o) {
      $merid = $ampm{$1};
    }
  
  
    unless (defined $year) {
      # Date: 12-June-96 (using - . or /)
      
      if ($dtstr =~ s#\s(\d\d?)([\-\./])($monpat)(\2(\d\d+))?\s# #o) {
        ($month,$day) = ($month{$3},$1);
        $year = $5 if $5;
      }
      
      # Date: 12-12-96 (using '-', '.' or '/' )
      
      elsif ($dtstr =~ s#\s(\d+)([\-\./])(\d\d?)(\2(\d+))?\s# #o) {
        ($month,$day) = ($1 - 1,$3);
  
        if ($5) {
  	$year = $5;
  	# Possible match for 1995-01-24 (short mainframe date format);
  	($year,$month,$day) = ($1, $3 - 1, $5) if $month > 12;
  	return if length($year) > 2 and $year < 1901;
        }
      }
      elsif ($dtstr =~ s#\s(\d+)\s*($sufpat)?\s*($monpat)# #o) {
        ($month,$day) = ($month{$3},$1);
      }
      elsif ($dtstr =~ s#($monpat)\s*(\d+)\s*($sufpat)?\s# #o) {
        ($month,$day) = ($month{$1},$2);
      }
      elsif ($dtstr =~ s#($monpat)([\/-])(\d+)[\/-]# #o) {
        ($month,$day) = ($month{$1},$3);
      }
  
      # Date: 961212
  
      elsif ($dtstr =~ s#\s(\d\d)(\d\d)(\d\d)\s# #o) {
        ($year,$month,$day) = ($1,$2-1,$3);
      }
  
      $year = $1 if !defined($year) and $dtstr =~ s#\s(\d{2}(\d{2})?)[\s\.,]# #o;
  
    }
  
    # Zone
  
    $dst = 1 if $dtstr =~ s#\bdst\b##o;
  
    if ($dtstr =~ s#\s"?([a-z]{3,4})(dst|\d+[a-z]*|_[a-z]+)?"?\s# #o) {
      $dst = 1 if $2 and $2 eq 'dst';
      $zone = tz_offset($1);
      return unless defined $zone;
    }
    elsif ($dtstr =~ s#\s([a-z]{3,4})?([\-\+]?)-?(\d\d?):?(\d\d)?(00)?\s# #o) {
      my $m = defined($4) ? "$2$4" : 0;
      my $h = "$2$3";
      $zone = defined($1) ? tz_offset($1) : 0;
      return unless defined $zone;
      $zone += 60 * ($m + (60 * $h));
    }
  
    if ($dtstr =~ /\S/) {
      # now for some dumb dates
      if ($dtstr =~ s/^\s*(ut?|z)\s*$//) {
        $zone = 0;
      }
      elsif ($dtstr =~ s#\s([a-z]{3,4})?([\-\+]?)-?(\d\d?)(\d\d)?(00)?\s# #o) {
        my $m = defined($4) ? "$2$4" : 0;
        my $h = "$2$3";
        $zone = defined($1) ? tz_offset($1) : 0;
        return unless defined $zone;
        $zone += 60 * ($m + (60 * $h));
      }
  
      return if $dtstr =~ /\S/o;
    }
  
    if (defined $hh) {
      if ($hh == 12) {
        $hh = 0 if $merid == $AM;
      }
      elsif ($merid == $PM) {
        $hh += 12;
      }
    }
  
    $year -= 1900 if defined $year && $year > 1900;
  
    $zone += 3600 if defined $zone && $dst;
    $ss += "0.$frac" if $frac;
  
    return ($ss,$mm,$hh,$day,$month,$year,$zone);
  }
  ESQ
   shift; # package
  ESQ
DATE_PARSE

$fatpacked{"Digest/CRC.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIGEST_CRC';
  package Digest::CRC;use strict;use vars qw($VERSION $XS_VERSION @ISA @EXPORT_OK %_typedef);require Exporter;@ISA=qw(Exporter);@EXPORT_OK=qw(crc8 crcccitt crc16 crcopenpgparmor crc32 crc64 crc crc_hex crc_base64 crcccitt_hex crcccitt_base64 crc8_hex crc8_base64 crc16_hex crc16_base64 crcopenpgparmor_hex crcopenpgparmor_base64 crc32_hex crc32_base64 crc64_hex crc64_base64);$VERSION='0.21';$XS_VERSION=$VERSION;eval {local$ENV{PERL_DL_NONLAZY}=0 if$ENV{PERL_DL_NONLAZY};require DynaLoader;local@ISA=qw(DynaLoader);bootstrap Digest::CRC$XS_VERSION;1};sub _reflectperl {my ($in,$width)=@_;my$out=0;for(my$i=1;$i < ($width+1);$i++){$out |=1 << ($width-$i)if ($in & 1);$in=$in>>1}$out}defined&_crc or eval <<'ENOXS' or die $@;%_typedef=(crc8=>[8,0,0,0,0x07,0,0],crcccitt=>[16,0xffff,0,0,0x1021,0,0],crc16=>[16,0,0,1,0x8005,1,0],crcopenpgparmor=>[24,0xB704CE,0,0,0x864CFB,0,0],crc32=>[32,0xffffffff,0xffffffff,1,0x04C11DB7,1,0],);sub new {my$that=shift;my%params=@_;die if defined($params{type})&&!exists($_typedef{$params{type}})&& $params{type}ne 'crc64';my$class=ref($that)|| $that;my$self={map {($_=>$params{$_})}qw(type width init xorout refout poly refin cont)};bless$self,$class;$self->reset();map {if (defined($params{$_})){$self->{$_}=$params{$_}}}qw(type width init xorout refout poly refin cont);$self}sub reset {my$self=shift;my$typeparams;if (!defined($self->{type})&&!defined($self->{width})){$self->{type}="crc32"}if (defined($self->{type})&& exists($_typedef{$self->{type}})){$typeparams=$_typedef{$self->{type}};$self->{width}=$typeparams->[0],$self->{init}=$typeparams->[1],$self->{xorout}=$typeparams->[2],$self->{refout}=$typeparams->[3],$self->{poly}=$typeparams->[4],$self->{refin}=$typeparams->[5],$self->{cont}=$typeparams->[6],}$self->{_tab}=defined($self->{width})?_tabinit($self->{width},$self->{poly},$self->{refin}):undef;$self->{_data}=undef;$self}sub _encode_hex {sprintf "%x",$_[0]}sub _encode_base64 {my ($res,$padding,$in)=("",undef,$_[0]);$in=pack("H*",sprintf("%x",$in));while ($in =~ /(.{1,45})/gs){$res .= substr pack('u',$1),1;chop$res}$res =~ tr|` -_|AA-Za-z0-9+/|;$padding=(3 - length($in)% 3)% 3;$res =~ s#.{$padding}$#'=' x $padding#e if$padding;$res =~ s#(.{1,76})#$1\n#g;$res}sub add {my$self=shift;$self->{_data}.= join '',@_ if @_;$self}sub addfile {my ($self,$fh)=@_;if (!ref($fh)&& ref(\$fh)ne "GLOB"){require Symbol;$fh=Symbol::qualify($fh,scalar caller)}my$read=0;my$buffer='';my$crc;my$oldinit=$self->{init};while ($read=read$fh,$buffer,32*1024){$self->add($buffer);$crc=$self->digest;$self->{cont}=1;$self->{init}=$crc}$self->{init}=$oldinit;$self->{_crc}=$crc;die __PACKAGE__," read failed: $!" unless defined$read;$self}sub add_bits {}sub digest {my$self=shift;my$crc;if (!$self->{_crc}){my$init=$self->{init};if (defined($self->{type})&& $self->{type}eq 'crc64' || defined($self->{width})&& $self->{width}eq 64){$crc=_crc64($self->{_data})}else {$crc=_crc($self->{_data},$self->{width},$init,$self->{xorout},$self->{refin},$self->{refout},$self->{cont},$self->{_tab})}}else {$crc=$self->{_crc};$self->{_crc}=undef}$self->{_data}=undef;$crc}sub hexdigest {_encode_hex($_[0]->digest)}sub b64digest {_encode_base64($_[0]->digest)}sub clone {my$self=shift;my$clone={type=>$self->{type},width=>$self->{width},init=>$self->{init},xorout=>$self->{xorout},poly=>$self->{poly},refin=>$self->{refin},refout=>$self->{refout},_data=>$self->{_data},cont=>$self->{cont},_tab=>$self->{_tab}};bless$clone,ref$self || $self}sub crc {my ($message,$width,$init,$xorout,$refout,$poly,$refin,$cont)=@_;_crc($message,$width,$init,$xorout,$refin,$refout,$cont,_tabinit($width,$poly,$refin))}sub _cont {my ($message,$init,@parameters)=@_;if (defined$init){$parameters[1]=$init;$parameters[6]=1}crc($message,@parameters)}sub crc8 {_cont($_[0],$_[1],@{$_typedef{crc8}})}sub crcccitt {_cont($_[0],$_[1],@{$_typedef{crcccitt}})}sub crc16 {_cont($_[0],$_[1],@{$_typedef{crc16}})}sub crcopenpgparmor {crc($_[0],@{$_typedef{crcopenpgparmor}})}sub crc32 {_cont($_[0],$_[1],@{$_typedef{crc32}})}sub crc64 {_crc64($_[0],defined($_[1])?$_[1]:0)}sub crc_hex {_encode_hex&crc}sub crc_base64 {_encode_base64&crc}sub crc8_hex {_encode_hex&crc8}sub crc8_base64 {_encode_base64&crc8}sub crcccitt_hex {_encode_hex&crcccitt}sub crcccitt_base64 {_encode_base64&crcccitt}sub crc16_hex {_encode_hex&crc16}sub crc16_base64 {_encode_base64&crc16}sub crcopenpgparmor_hex {_encode_hex&crcopenpgparmor}sub crcopenpgparmor_base64 {_encode_base64&crcopenpgparmor}sub crc32_hex {_encode_hex&crc32}sub crc32_base64 {_encode_base64&crc32}sub crc64_hex {_encode_hex&crc64}sub crc64_base64 {_encode_base64&crc64}1;
  
  sub _reflect($$) {
    my ($in, $width) = @_;
    my $out = 0;
    for(my $i=1; $i < ($width+1); $i++) {
      $out |= 1 << ($width-$i) if ($in & 1);
      $in=$in>>1;
    }
    $out;
  }
  
  sub _tabinit($$$) {
    my ($width,$poly_in,$ref) = @_;
    my @crctab;
    my $poly = $poly_in;
  
    if ($ref) {
      $poly = _reflect($poly,$width);
    }
  
    for (my $i=0; $i<256; $i++) {
      my $r = $i<<($width-8);
      $r = $i if $ref;
      for (my $j=0; $j<8; $j++) {
        if ($ref) {
          $r = ($r>>1)^($r&1&&$poly)
        } else {
          if ($r&(1<<($width-1))) {
            $r = ($r<<1)^$poly
          } else {
            $r = ($r<<1)
          }
        }
      }
      my $x=$r&2**$width-1;
      push @crctab, $x;
    }
    \@crctab;
  }
  
  sub _crc($$$$$$$$) {
    my ($message,$width,$init,$xorout,$refin,$refout,$cont,$tab) = @_;
    if ($cont) {
      $init = ($init ^ $xorout);
      $init = _reflect($init, $width) if $refin;
    }
    my $crc = $init;
    if ($refin == 1) {
      $crc = _reflect($crc,$width);
    } elsif ($refin > 1 and $refin <= $width) {
      $crc = _reflect($crc,$refin);
    }
    my $pos = -length $message;
    my $mask = 2**$width-1;
    while ($pos) {
      if ($refin) {
        $crc = ($crc>>8)^$tab->[($crc^ord(substr($message, $pos++, 1)))&0xff]
      } else {
        $crc = (($crc<<8))^$tab->[(($crc>>($width-8))^ord(substr $message,$pos++,1))&0xff]
      }
    }
  
    if ($refout && !$refin) {
      if ($refout == 1) {
        $crc = _reflect($crc,$width);
      } elsif ($refout > 1 and $refout <= $width) {
        $crc = _reflect($crc,$refout);
      }
    }
  
    $crc = $crc ^ $xorout;
    $crc & $mask;
  }
  
  1;
  
  ENOXS
DIGEST_CRC

$fatpacked{"Geo/ShapeFile.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GEO_SHAPEFILE';
  package Geo::ShapeFile;use strict;use warnings;use Carp;use IO::File;use Geo::ShapeFile::Shape;use Config;use List::Util qw /min max/;use Scalar::Util qw/weaken/;use Tree::R;our$VERSION='2.64';my$little_endian_sys=unpack 'b',(pack 'S',1);sub new {my$proto=shift;my$filebase=shift || croak "Must specify filename!";my$args=shift || {};my$class=ref($proto)|| $proto;my$self={};$self->{filebase}=$filebase;$self->{filebase}=~ s/\.\w{3}$//;$self->{_enable_caching}={shp=>1,dbf=>1,shx=>1,shapes_in_area=>1,};$self->{has_shx}=0;$self->{has_shp}=0;$self->{has_dbf}=0;bless$self,$class;if ($args->{no_cache}){$self->{_no_cache}=1}$self->{_change_cache}={shape_type=>undef,records=>undef,shp=>{},dbf=>{},shx=>{},};$self->{_object_cache}={shp=>{},dbf=>{},shx=>{},shapes_in_area=>{},};if (-f $self->{filebase}.'.shx'){$self->_read_shx_header();$self->{has_shx}=1}if (-f $self->{filebase}.'.shp'){$self->_read_shp_header();$self->{has_shp}=1}if (-f $self->{filebase}.'.dbf'){$self->_read_dbf_header();$self->{has_dbf}=1}if (!$self->{has_dbf}){croak "$self->{filebase}: shp and/or shx file do not exist or are invalid" if!($self->{has_shp}&& $self->{has_shx});croak "$self->{filebase}.dbf does not exist or is invalid"}return$self}sub _disable_all_caching {my$self=shift;for my$type (qw/shp shx dbf shapes_in_area/){$self->{_enable_caching}{$type}=0;$self->{_object_cache}={}}return}sub caching {my$self=shift;my$what=shift;my$flag=shift;if (defined$flag){$self->{_enable_caching}->{$what}=$flag}return$self->{_enable_caching}->{$what}}sub cache {my ($self,$type,$obj,$cache)=@_;return if$self->{_no_cache};return$self->{_change_cache}->{$type}->{$obj}if$self->{_change_cache}->{$type}&& $self->{_change_cache}->{$type}->{$obj};return if!$self->caching($type);if ($cache){$self->{_object_cache}->{$type}->{$obj}=$cache}return$self->{_object_cache}->{$type}->{$obj}}sub get_all_shapes {my$self=shift;my@shapes;for my$id (1 .. $self->shapes()){my$shape=$self->get_shp_record($id);push@shapes,$shape}return wantarray ? @shapes : \@shapes}sub get_shapes_sorted {my$self=shift;my$shapes=shift;my$sub=shift;if (!defined$sub){$sub=sub {my ($s1,$s2)=@_;return$s1->{shp_record_number}<=> $s2->{shp_record_number}}}if (!defined$shapes){$shapes=$self->get_all_shapes}my@sorted=sort {$sub->($a,$b)}@$shapes;return wantarray ? @sorted : \@sorted}sub get_shapes_sorted_spatially {my$self=shift;my$shapes=shift;my$sub=shift;if (!defined$sub){$sub=sub {my ($s1,$s2)=@_;return $s1->x_min <=> $s2->x_min || $s1->y_min <=> $s2->y_min || $s1->x_max <=> $s2->x_max || $s1->y_max <=> $s2->y_max || $s1->shape_id <=> $s2->shape_id }}return$self->get_shapes_sorted ($shapes,$sub)}sub build_spatial_index {my$self=shift;my$shapes=$self->get_all_shapes;my$rtree=Tree::R->new();for my$shape (@$shapes){my@bbox=($shape->x_min,$shape->y_min,$shape->x_max,$shape->y_max);$rtree->insert($shape,@bbox)}$self->{_spatial_index}=$rtree;return$rtree}sub get_spatial_index {my$self=shift;return$self->{_spatial_index}}sub _read_shx_header {shift()->_read_shx_shp_header('shx',@_)}sub _read_shp_header {shift()->_read_shx_shp_header('shp',@_)}sub _read_shx_shp_header {my$self=shift;my$which=shift;my$doubles;$self->{$which .'_header'}=$self->_get_bytes($which,0,100);($self->{$which .'_file_code'},$self->{$which .'_file_length'},$self->{$which .'_version'},$self->{$which .'_shape_type'},$doubles)=unpack 'N x20 N V2 a64',$self->{$which .'_header'};($self->{$which .'_x_min'},$self->{$which .'_y_min'},$self->{$which .'_x_max'},$self->{$which .'_y_max'},$self->{$which .'_z_min'},$self->{$which .'_z_max'},$self->{$which .'_m_min'},$self->{$which .'_m_max'},)=($little_endian_sys ? (unpack 'd8',$doubles): (reverse unpack 'd8',scalar reverse$doubles));return 1}sub type_is {my$self=shift;my$type=shift;return (lc$self->type($self->shape_type))eq (lc$type)}sub get_dbf_field_names {my$self=shift;croak 'dbf field names not loaded yet' if!defined$self->{dbf_field_names};my@fld_names=@{$self->{dbf_field_names}};return wantarray ? @fld_names : \@fld_names}sub _read_dbf_header {my$self=shift;$self->{dbf_header}=$self->_get_bytes('dbf',0,12);($self->{dbf_version},$self->{dbf_updated_year},$self->{dbf_updated_month},$self->{dbf_updated_day},$self->{dbf_num_records},$self->{dbf_header_length},$self->{dbf_record_length},)=unpack 'C4 V v v',$self->{dbf_header};my$ls=$self->{dbf_header_length}+ $self->{dbf_num_records}* $self->{dbf_record_length};my$li=-s $self->{filebase}.'.dbf';my$last_byte=$self->_get_bytes('dbf',$li-1,1);$ls ++ if ord$last_byte==0x1A;croak "dbf: file wrong size (should be $ls, but found $li)" if$ls!=$li;my$header=$self->_get_bytes('dbf',32,$self->{dbf_header_length}- 32);my$count=0;$self->{dbf_header_info}=[];while ($header){my$tmp=substr$header,0,32,'';my$chr=substr$tmp,0,1;last if ord$chr==0x0D;last if length ($tmp)< 32;my%tmp=();($tmp{name},$tmp{type},$tmp{size},$tmp{decimals})=unpack 'Z11 Z x4 C2',$tmp;$self->{dbf_field_info}->[$count]={%tmp};$count++}$self->{dbf_fields}=$count;croak "dbf: Not enough fields ($count < 1)" if$count < 1;my@template=();for (@{$self->{dbf_field_info}}){croak "dbf: Field $_->{name} too short ($_->{size} bytes)" if $_->{size}< 1;croak "dbf: Field $_->{name} too long ($_->{size} bytes)" if $_->{size}> 4000;push@template,'A' .$_->{size}}$self->{dbf_record_template}=join ' ',@template;my@field_names=();for (@{$self->{dbf_field_info}}){push@field_names,$_->{name}}$self->{dbf_field_names}=[@field_names];return 1}sub _generate_dbf_header {my$self=shift;($self->{dbf_version},$self->{dbf_updated_year},$self->{dbf_updated_month},$self->{dbf_updated_day},$self->{dbf_num_records},$self->{dbf_header_length},$self->{dbf_record_length},)=unpack 'C4 V v v',$self->{dbf_header};$self->{_change_cache}->{dbf_cache}->{header}=pack 'C4 V v v',3,(localtime)[5],(localtime)[4]+1,(localtime)[3],0,0,0,}sub get_dbf_field_info {my$self=shift;my$header=$self->{dbf_field_info};return if!$header;my@hdr;for my$field (@$header){my%h=%$field;push@hdr,\%h}return wantarray ? @hdr : \@hdr}sub get_dbf_record {my$self=shift;my$entry=shift;my$dbf=$self->cache('dbf',$entry);if (!$dbf){$entry--;my$record=$self->_get_bytes('dbf',$self->{dbf_header_length}+($self->{dbf_record_length}* $entry),$self->{dbf_record_length}+1,);my ($del,@data)=unpack 'c' .$self->{dbf_record_template},$record;map {s/^\s*//;s/\s*$//}@data;my%record;@record{@{$self->{dbf_field_names}}}=@data;$record{_deleted}=(ord$del==0x2A);$dbf={%record};$self->cache('dbf',$entry + 1,$dbf)}return wantarray ? %{$dbf}: $dbf}sub _set_dbf_record {my$self=shift;my$entry=shift;my%record=@_;$self->{_change_cache}->{dbf}->{$entry}={%record}}sub _get_shp_shx_header_value {my$self=shift;my$val=shift;if (!($self->{'shx_' .$val}|| $self->{'shp_' .$val})){$self->_read_shx_header()}return$self->{'shx_' .$val}|| $self->{'shp_' .$val}|| undef}sub x_min {shift()->_get_shp_shx_header_value('x_min')}sub x_max {shift()->_get_shp_shx_header_value('x_max')}sub y_min {shift()->_get_shp_shx_header_value('y_min')}sub y_max {shift()->_get_shp_shx_header_value('y_max')}sub z_min {shift()->_get_shp_shx_header_value('z_min')}sub z_max {shift()->_get_shp_shx_header_value('z_max')}sub m_min {shift()->_get_shp_shx_header_value('m_min')}sub m_max {shift()->_get_shp_shx_header_value('m_max')}sub upper_left_corner {my$self=shift;return Geo::ShapeFile::Point->new(X=>$self->x_min,Y=>$self->y_max)}sub upper_right_corner {my$self=shift;return Geo::ShapeFile::Point->new(X=>$self->x_max,Y=>$self->y_max)}sub lower_right_corner {my$self=shift;return Geo::ShapeFile::Point->new(X=>$self->x_max,Y=>$self->y_min)}sub lower_left_corner {my$self=shift;return Geo::ShapeFile::Point->new(X=>$self->x_min,Y=>$self->y_min)}sub height {my$self=shift;return if!$self->records;return$self->y_max - $self->y_min}sub width {my$self=shift;return if!$self->records;return$self->x_max - $self->x_min}sub corners {my$self=shift;return ($self->upper_left_corner,$self->upper_right_corner,$self->lower_right_corner,$self->lower_left_corner,)}sub area_contains_point {my$self=shift;my$point=shift;my ($x_min,$y_min,$x_max,$y_max)=@_;my$x=$point->get_x;my$y=$point->get_y;my$result=($x >= $x_min)&& ($x <= $x_max)&& ($y >= $y_min)&& ($y <= $y_max);return$result}sub bounds_contains_point {my$self=shift;my$point=shift;return$self->area_contains_point ($point,$self->x_min,$self->y_min,$self->x_max,$self->y_max,)}sub file_version {shift()->_get_shp_shx_header_value('file_version')}sub shape_type {my$self=shift;return$self->{_change_cache}->{shape_type}if defined$self->{_change_cache}->{shape_type};return$self->_get_shp_shx_header_value('shape_type')}sub shapes {my$self=shift;return$self->{_change_cache}->{records}if defined$self->{_change_cache}->{records};if (!$self->{shx_file_length}){$self->_read_shx_header()}my$filelength=$self->{shx_file_length};$filelength -= 50;return$filelength / 4}sub records {my$self=shift;return$self->{_change_cache}->{records}if defined$self->{_change_cache}->{records};if ($self->{shx_file_length}){my$filelength=$self->{shx_file_length};$filelength -= 50;return$filelength / 4}elsif ($self->{dbf_num_records}){return$self->{dbf_num_records}}return 0}sub shape_type_text {my$self=shift;return$self->type($self->shape_type())}sub get_shx_record_header {shift()->get_shx_record(@_)}sub get_shx_record {my$self=shift;my$entry=shift;croak 'must specify entry index' if!$entry;my$shx=$self->cache('shx',$entry);if (!$shx){my$record=$self->_get_bytes('shx',(($entry - 1)* 8)+ 100,8);$shx=[unpack 'N N',$record];$self->cache('shx',$entry,$shx)}return @{$shx}}sub get_shp_record_header {my$self=shift;my$entry=shift;my($offset)=$self->get_shx_record($entry);my$record=$self->_get_bytes('shp',$offset * 2,8);my ($number,$content_length)=unpack 'N N',$record;return ($number,$content_length)}sub shapes_in_area {my$self=shift;my@area=@_;if (my$sp_index=$self->get_spatial_index){my$shapes=[];$sp_index->query_partly_within_rect (@area,$shapes);my@indexes;for my$shape (@$shapes){push@indexes,$shape->shape_id}return wantarray ? @indexes : \@indexes}my@results=();SHAPE: foreach my$shp_id (1 .. $self->shapes){my ($offset,$content_length)=$self->get_shx_record($shp_id);my$type=unpack 'V',$self->_get_bytes ('shp',$offset * 2 + 8,4);next SHAPE if$self->type($type)eq 'Null';if ($self->type($type)=~ /^Point/){my$bytes=$self->_get_bytes('shp',$offset * 2 + 12,16);my ($x,$y)=($little_endian_sys ? (unpack 'dd',$bytes): (reverse unpack 'dd',scalar reverse$bytes));my$pt=Geo::ShapeFile::Point->new(X=>$x,Y=>$y);if ($self->area_contains_point($pt,@area)){push@results,$shp_id}}elsif ($self->type($type)=~ /^(PolyLine|Polygon|MultiPoint|MultiPatch)/){my$bytes=$self->_get_bytes('shp',($offset * 2)+ 12,32);my@p=($little_endian_sys ? (unpack 'd4',$bytes): (reverse unpack 'd4',scalar reverse$bytes));if ($self->check_in_area(@p,@area)){push@results,$shp_id}}else {print 'type=' .$self->type($type)."\n"}}return wantarray ? @results : \@results}sub check_in_area {my$self=shift;my ($x1_min,$y1_min,$x1_max,$y1_max,$x2_min,$y2_min,$x2_max,$y2_max,)=@_;my$result=!($x1_min > $x2_max or $x1_max < $x2_min or $y1_min > $y2_max or $y1_max < $y2_min);return$result}sub _between {my$self=shift;my$check=shift;if ($_[0]> $_[1]){@_=reverse @_}return ($check >= $_[0])&& ($check <= $_[1])}sub bounds {my$self=shift;return ($self->x_min,$self->y_min,$self->x_max,$self->y_max,)}sub _extract_ints {my$self=shift;my$end=shift;my@what=@_;my$template=($end =~ /^l/i)? 'V': 'N';$self->_extract_and_unpack(4,$template,@what);for (@what){$self->{$_}=$self->{$_}}}sub get_shp_record {my$self=shift;my$entry=shift;my$shape=$self->cache('shp',$entry);if (!$shape){my($offset,$content_length)=$self->get_shx_record($entry);my$record=$self->_get_bytes('shp',$offset * 2,$content_length * 2 + 8);$shape=Geo::ShapeFile::Shape->new();$shape->parse_shp($record);$self->cache('shp',$entry,$shape)}return$shape}sub shx_handle {shift()->_get_handle('shx')}sub shp_handle {shift()->_get_handle('shp')}sub dbf_handle {shift()->_get_handle('dbf')}sub _get_handle {my$self=shift;my$which=shift;my$han=$which .'_handle';if (!$self->{$han}){$self->{$han}=IO::File->new;my$file=join '.',$self->{filebase},$which;croak "Couldn't get file handle for $file: $!" if not $self->{$han}->open($file,O_RDONLY | O_BINARY);binmode$self->{$han};weaken$self->{han}}return$self->{$han}}sub _get_bytes {my$self=shift;my$file=shift;my$offset=shift;my$length=shift;my$handle=$file .'_handle';my$h=$self->$handle();$h->seek ($offset,0)|| croak "Couldn't seek to $offset for $file";my$tmp;my$res=$h->read($tmp,$length);croak "Couldn't read $length bytes from $file at offset $offset ($!)" if!defined$res;croak "EOF reading $length bytes from $file at offset $offset" if$res==0;return$tmp}sub type {my$self=shift;my$shape=shift;my%shape_types=qw(0 Null 1 Point 3 PolyLine 5 Polygon 8 MultiPoint 11 PointZ 13 PolyLineZ 15 PolygonZ 18 MultiPointZ 21 PointM 23 PolyLineM 25 PolygonM 28 MultiPointM 31 MultiPatch);return$shape_types{$shape}}sub find_bounds {my$self=shift;my@objects=@_;return if!scalar@objects;my$obj1=shift@objects;my$x_min=$obj1->x_min();my$y_min=$obj1->y_min();my$x_max=$obj1->x_max();my$y_max=$obj1->y_max();for my$obj (@objects){$x_min=min ($x_min,$obj->x_min());$y_min=min ($y_min,$obj->y_min());$x_max=max ($x_max,$obj->x_max());$y_max=max ($y_max,$obj->y_max())}my%bounds=(x_min=>$x_min,y_min=>$y_min,x_max=>$x_max,y_max=>$y_max,);return%bounds}sub DESTROY {}1;
GEO_SHAPEFILE

$fatpacked{"Geo/ShapeFile/Point.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GEO_SHAPEFILE_POINT';
  package Geo::ShapeFile::Point;use strict;use warnings;use Math::Trig 1.04;use Carp;our$VERSION='2.64';use overload '=='=>'eq','eq'=>'eq','""'=>'stringify','+'=>\&add,'-'=>\&subtract,'*'=>\&multiply,'/'=>\&divide,fallback=>1,;my%config=(comp_includes_z=>1,comp_includes_m=>1,);sub new {my$proto=shift;my$class=ref($proto)|| $proto;my$self={@_};bless$self,$class;return$self}sub _var {my$self=shift;my$var=shift;if (@_){return$self->{$var}=shift}else {return$self->{$var}}}sub X {shift()->_var('X',@_)}sub Y {shift()->_var('Y',@_)}sub Z {shift()->_var('Z',@_)}sub M {shift()->_var('M',@_)}sub x_min {$_[0]->_var('X')}sub x_max {$_[0]->_var('X')}sub y_min {$_[0]->_var('Y')}sub y_max {$_[0]->_var('Y')}sub z_min {$_[0]->_var('Z')}sub z_max {$_[0]->_var('Z')}sub m_min {$_[0]->_var('M')}sub m_max {$_[0]->_var('M')}sub get_x {$_[0]->{X}}sub get_y {$_[0]->{Y}}sub get_z {$_[0]->{Z}}sub get_m {$_[0]->{M}}sub import {my$self=shift;my%args=@_;for(keys%args){$config{$_}=$args{$_}}}sub eq {my$left=shift;my$right=shift;if ($config{comp_includes_z}&& (defined$left->Z || defined$right->Z)){return 0 unless defined$left->Z && defined$right->Z;return 0 unless$left->Z==$right->Z}if ($config{comp_includes_m}&& (defined$left->M || defined$right->M)){return 0 unless defined$left->M && defined$right->M;return 0 unless$left->M==$right->M}return ($left->X==$right->X && $left->Y==$right->Y)}sub stringify {my$self=shift;my@foo=();for(qw/X Y Z M/){if(defined$self->$_()){push@foo,"$_=" .$self->$_()}}my$r='Point(' .join(',',@foo).')'}sub distance_from {my ($p1,$p2)=@_;my$dp=$p2->subtract($p1);return sqrt (($dp->X ** 2)+ ($dp->Y **2))}sub distance_to {distance_from(@_)}sub angle_to {my ($p1,$p2)=@_;my$dp=$p2->subtract ($p1);my$x_off=$dp->get_x;my$y_off=$dp->get_y;return 0 if!($x_off || $y_off);my$bearing=90 - Math::Trig::rad2deg (Math::Trig::atan2 ($y_off,$x_off));if ($bearing < 0){$bearing += 360}return$bearing}sub add {_mathemagic('add',@_)}sub subtract {_mathemagic('subtract',@_)}sub multiply {_mathemagic('multiply',@_)}sub divide {_mathemagic('divide',@_)}sub _mathemagic {my ($op,$l,$r,$reverse)=@_;if ($reverse){($l,$r)=($r,$l)}my ($left,$right);if (UNIVERSAL::isa($l,'Geo::ShapeFile::Point')){$left='point'}if (UNIVERSAL::isa($r,'Geo::ShapeFile::Point')){$right='point'}if ($l =~ /^[\d\.]+$/){$left='number'}if ($r =~ /^[\d\.]+$/){$right='number'}unless ($left){croak "Couldn't identify $l for $op"}unless ($right){croak "Couldn't identify $r for $op"}my$function='_' .join '_',$op,$left,$right;croak "Don't know how to $op $left and $right" if!defined &{$function};do {no strict 'refs';return$function->($l,$r)}}sub _add_point_point {my ($p1,$p2)=@_;my$z;if(defined($p2->Z)&& defined($p1->Z)){$z=($p2->Z + $p1->Z)}Geo::ShapeFile::Point->new(X=>($p2->X + $p1->X),Y=>($p2->Y + $p1->Y),Z=>$z,)}sub _add_point_number {my ($p1,$n)=@_;my$z;if (defined($p1->Z)){$z=($p1->Z + $n)}Geo::ShapeFile::Point->new(X=>($p1->X + $n),Y=>($p1->Y + $n),Z=>$z,)}sub _add_number_point {add_point_number(@_)}sub _subtract_point_point {my($p1,$p2)=@_;my$z;if(defined($p2->Z)&& defined($p1->Z)){$z=($p2->Z - $p1->Z)}my$result=Geo::ShapeFile::Point->new(X=>($p1->X - $p2->X),Y=>($p1->Y - $p2->Y),Z=>$z,);return$result}sub _subtract_point_number {my($p1,$n)=@_;my$z;if (defined$p1->Z){$z=($p1->Z - $n)}Geo::ShapeFile::Point->new(X=>($p1->X - $n),Y=>($p1->Y - $n),Z=>$z,)}sub _subtract_number_point {_subtract_point_number(reverse @_)}sub _multiply_point_point {my ($p1,$p2)=@_;my$z;if (defined$p2->Z and defined$p1->Z){$z=$p2->Z * $p1->Z}Geo::ShapeFile::Point->new(X=>($p2->X * $p1->X),Y=>($p2->Y * $p1->Y),Z=>$z,)}sub _multiply_point_number {my($p1,$n)=@_;my$z;if (defined$p1->Z){$z=$p1->Z * $n}Geo::ShapeFile::Point->new(X=>($p1->X * $n),Y=>($p1->Y * $n),Z=>$z,)}sub _multiply_number_point {_multiply_point_number(reverse @_)}sub _divide_point_point {my($p1,$p2)=@_;my$z;if (defined$p2->Z and defined$p1->Z){$z=$p1->Z / $p2->Z}Geo::ShapeFile::Point->new(X=>($p1->X / $p2->X),Y=>($p1->Y / $p2->Y),Z=>$z,)}sub _divide_point_number {my ($p1,$n)=@_;my$z;if (defined$p1->Z){$z=$p1->Z / $n}Geo::ShapeFile::Point->new(X=>($p1->X / $n),Y=>($p1->Y / $n),Z=>$z,)}sub _divide_number_point {divide_point_number(reverse @_)}1;
GEO_SHAPEFILE_POINT

$fatpacked{"Geo/ShapeFile/Shape.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GEO_SHAPEFILE_SHAPE';
  package Geo::ShapeFile::Shape;use strict;use warnings;use Carp;use Tree::R;use List::Util qw /min max/;use Geo::ShapeFile;use Geo::ShapeFile::Point;use Geo::ShapeFile::Shape::Index;use parent qw /Geo::ShapeFile/;our$VERSION='2.64';my$little_endian_sys=unpack 'b',(pack 'S',1);my$index_class='Geo::ShapeFile::Shape::Index';sub new {my$proto=shift;my$class=ref ($proto)|| $proto;my%args=@_;my$self={shp_content_length=>0,source=>undef,shp_points=>[],shp_num_points=>0,shp_parts=>[],shp_record_number=>undef,shp_shape_type=>undef,shp_num_parts=>0,shp_x_min=>undef,shp_x_max=>undef,shp_y_min=>undef,shp_y_max=>undef,shp_z_min=>undef,shp_z_max=>undef,shp_m_min=>undef,shp_m_max=>undef,shp_data=>undef,};for (keys%args){$self->{$_}=$args{$_}}bless$self,$class;return$self}sub parse_shp {my$self=shift;$self->{source}=$self->{shp_data}=shift;$self->_extract_ints('big','shp_record_number','shp_content_length');$self->_extract_ints('little','shp_shape_type');my$parser='_parse_shp_' .$self->type($self->{shp_shape_type});croak "Can't parse shape_type $self->{shp_shape_type}" if!$self->can($parser);$self->$parser();if (length($self->{shp_data})){my$len=length($self->{shp_data});my$byte_plural=$len > 1 ? 's' : '';carp "$len byte$byte_plural remaining in buffer after parsing " .$self->shape_type_text().' #' .$self->shape_id()}}sub _parse_shp_Null {my$self=shift}sub add_point {my$self=shift;if(@_==1){my$point=shift;if($point->isa('Geo::ShapeFile::Point')){push @{$self->{shp_points}},$point}}else {my%point_opts=@_;push @{$self->{shp_points}},Geo::ShapeFile::Point->new(%point_opts);$self->{shp_num_points}++}}sub add_part {my$self=shift;push @{$self->{shp_parts}},$self->{shp_num_parts}++}sub calculate_bounds {my$self=shift;my%bounds=$self->find_bounds($self->points);for (keys%bounds){$self->{'shp_' .$_}=$bounds{$_}}return%bounds}sub _parse_shp_Point {my$self=shift;$self->_extract_doubles('shp_X','shp_Y');$self->{shp_points}=[Geo::ShapeFile::Point->new(X=>$self->{shp_X},Y=>$self->{shp_Y},)];$self->{shp_num_points}=1;$self->{shp_x_min}=$self->{shp_X};$self->{shp_x_max}=$self->{shp_X};$self->{shp_y_min}=$self->{shp_Y};$self->{shp_y_max}=$self->{shp_Y}}sub _parse_shp_PolyLine {my$self=shift;$self->_extract_bounds();$self->_extract_parts_and_points()}sub _parse_shp_Polygon {my$self=shift;$self->_extract_bounds();$self->_extract_parts_and_points()}sub _parse_shp_MultiPoint {my$self=shift;$self->_extract_bounds();$self->_extract_ints('little','shp_num_points');$self->_extract_points($self->{shp_num_points},'shp_points')}sub _parse_shp_PointZ {my$self=shift;$self->_parse_shp_Point();$self->_extract_doubles('shp_Z','shp_M');$self->{shp_points}->[0]->Z($self->{shp_Z});$self->{shp_points}->[0]->M($self->{shp_M})}sub _parse_shp_PolyLineZ {my$self=shift;$self->_parse_shp_PolyLine();$self->_extract_z_data();$self->_extract_m_data()}sub _parse_shp_PolygonZ {my$self=shift;$self->_parse_shp_Polygon();$self->_extract_z_data();$self->_extract_m_data()}sub _parse_shp_MultiPointZ {my$self=shift;$self->_parse_shp_MultiPoint();$self->_extract_z_data();$self->_extract_m_data()}sub _parse_shp_PointM {my$self=shift;$self->_parse_shp_Point();$self->_extract_doubles('shp_M');$self->{shp_points}->[0]->M($self->{shp_M})}sub _parse_shp_PolyLineM {my$self=shift;$self->_parse_shp_PolyLine();$self->_extract_m_data()}sub _parse_shp_PolygonM {my$self=shift;$self->_parse_shp_Polygon();$self->_extract_m_data()}sub _parse_shp_MultiPointM {my$self=shift;$self->_parse_shp_MultiPoint();$self->_extract_m_datextract_m_data()}sub _parse_shp_MultiPatch {my$self=shift;$self->_extract_bounds();$self->_extract_parts_and_points();$self->_extract_z_data();$self->_extract_m_data()}sub _extract_bounds {my$self=shift;$self->_extract_doubles(qw/shp_x_min shp_y_min shp_x_max shp_y_max/)}sub _extract_ints {my$self=shift;my$end=shift;my@what=@_;my$template=($end =~ /^l/i)? 'V' :'N';$self->_extract_and_unpack(4,$template,@what)}sub _extract_count_ints {my$self=shift;my$count=shift;my$end=shift;my$label=shift;my$template=($end =~ /^l/i)? 'V' :'N';my$tmp=substr$self->{shp_data},0,($count * 4),'';my@tmp=unpack$template .$count,$tmp;$self->{$label}=[@tmp]}sub _extract_doubles {my$self=shift;my@what=@_;my$size=8;my$template='d';for (@what){my$tmp=substr$self->{shp_data},0,$size,'';$self->{$_ }=$little_endian_sys ? (unpack$template,$tmp): (unpack$template,scalar reverse$tmp)}}sub _extract_count_doubles {my$self=shift;my$count=shift;my$label=shift;my$tmp=substr$self->{shp_data},0,$count*8,'';my@tmp=$little_endian_sys ? (unpack 'd'.$count,$tmp): (reverse unpack('d' .$count,scalar (reverse($tmp))));$self->{$label}=[@tmp]}sub _extract_points {my$self=shift;my$count=shift;my$label=shift;my$data=substr$self->{shp_data},0,$count * 16,'';my@ps=$little_endian_sys ? (unpack 'd*',$data): (reverse unpack 'd*',scalar reverse$data);my@p=();while(@ps){my ($x,$y)=(shift@ps,shift@ps);push@p,Geo::ShapeFile::Point->new(X=>$x,Y=>$y)}$self->{$label}=[@p]}sub _extract_and_unpack {my$self=shift;my$size=shift;my$template=shift;my@what=@_;for(@what){my$tmp=substr$self->{shp_data},0,$size,'';if ($template eq 'd'){$tmp=Geo::ShapeFile->byteswap($tmp)}$self->{$_}=unpack$template,$tmp}}sub num_parts {shift()->{shp_num_parts}}sub parts {my$self=shift;my$parts=$self->{shp_parts};return wantarray ? @{$parts || []}: $parts}sub num_points {shift()->{shp_num_points}}sub points {my$self=shift;my$points=$self->{shp_points};return wantarray ? @{$points || []}: $points}sub get_part {my$self=shift;my$index=shift;croak 'index passed to get_part must be >0' if$index <= 0;$index -= 1;my$parts=$self->parts;croak 'index exceeds number of parts' if$index > $#$parts;my$points=$self->points;my$beg=$parts->[$index]|| 0;my$end=$parts->[$index+1]|| 0;$end -= 1;if ($end < 0){$end=$#$points}return wantarray ? @$points[$beg .. $end]: [@$points[$beg .. $end]]}sub shape_type {my$self=shift;return$self->{shp_shape_type}}sub shape_id {my$self=shift;return$self->{shp_record_number}}sub _extract_z_data {my$self=shift;$self->_extract_doubles('shp_z_min','shp_z_max');$self->_extract_count_doubles($self->{shp_num_points},'shp_z_data');my@zdata=@{delete$self->{shp_z_data}};for (0 .. $#zdata){$self->{shp_points}->[$_]->Z($zdata[$_])}}sub _extract_m_data {my$self=shift;$self->_extract_doubles ('shp_m_min','shp_m_max');$self->_extract_count_doubles($self->{shp_num_points},'shp_m_data');my@mdata=@{delete$self->{shp_m_data}};for (0 .. $#mdata){$self->{shp_points}->[$_]->M($mdata[$_])}}sub _extract_parts_and_points {my$self=shift;$self->_extract_ints('little','shp_num_parts','shp_num_points');$self->_extract_count_ints($self->{shp_num_parts},'little','shp_parts');$self->_extract_points($self->{shp_num_points},'shp_points')}sub x_min {shift()->{shp_x_min}}sub x_max {shift()->{shp_x_max}}sub y_min {shift()->{shp_y_min}}sub y_max {shift()->{shp_y_max}}sub z_min {shift()->{shp_z_min}}sub z_max {shift()->{shp_z_max}}sub m_min {shift()->{shp_m_min}}sub m_max {shift()->{shp_m_max}}sub bounds {my$self=shift;my@results=($self->x_min,$self->y_min,$self->x_max,$self->y_max,);return wantarray ? @results : \@results}sub has_point {my$self=shift;my$point=shift;return 0 if!$self->bounds_contains_point($point);for my$check_pt ($self->points){return 1 if$check_pt==$point}return 0}sub contains_point {my ($self,$point,$index_res)=@_;return$self->_contains_point_use_index ($point,$index_res)if$self->get_spatial_index || defined$index_res;return 0 if!$self->bounds_contains_point($point);my$a=0;my ($x0,$y0)=($point->get_x,$point->get_y);my$num_parts=$self->num_parts;for my$part_num (1 .. $num_parts){my$points=$self->get_part($part_num);my$p_start=shift @$points;my$x1=$p_start->get_x - $x0;my$y1=$p_start->get_y - $y0;for my$p2 (@$points){my$x2=$p2->get_x - $x0;my$y2=$p2->get_y - $y0;if (($y2 >= 0)!=($y1 >= 0)){my$isl=$x1 * $y2 - $y1 * $x2;if ($y2 > $y1){if ($isl > 0){$a--}}else {if ($isl < 0){$a++}}}($x1,$y1)=($x2,$y2)}}return$a}sub _contains_point_use_index {my ($self,$point,$index_res)=@_;return 0 if!$self->bounds_contains_point($point);my$sp_index_hash=$self->get_spatial_index || $self->build_spatial_index ($index_res);my$a=0;my ($x0,$y0)=($point->get_x,$point->get_y);my@parts=$self->parts;my$num_parts=scalar@parts;PART: foreach my$part_index (1 .. $num_parts){my$sp_index=$sp_index_hash->{$part_index};my@results=$sp_index->query_point($x0,$y0);next PART if!scalar@results;for my$segment (@results){my$x1=$segment->[0][0]- $x0;my$y1=$segment->[0][1]- $y0;my$x2=$segment->[1][0]- $x0;my$y2=$segment->[1][1]- $y0;if (($y2 >= 0)!=($y1 >= 0)){my$isl=$x1 * $y2 - $y1 * $x2;if ($y2 > $y1){if ($isl > 0){$a--}}else {if ($isl < 0){$a++}}}}}return$a}sub get_spatial_index {my$self=shift;return$self->{_spatial_indexes}}sub build_spatial_index {my$self=shift;my$n=shift || 10;$n=int$n;croak 'Cannot build spatial index with <1 boxes' if$n < 1;my%sp_indexes;my@parts=$self->parts;my ($x_min,$x_max,$y_min,$y_max);my$part_id=0;for my$part (@parts){$part_id ++;my$segments=$self->get_segments ($part_id);if (@parts > 1){my%bounds=$self->_get_part_bounds ($part_id);($x_min,$y_min,$x_max,$y_max)=@bounds{qw /x_min y_min x_max y_max/}}else {($x_min,$y_min,$x_max,$y_max)=$self->bounds}my$n_boxes=@$segments > 20 ? $n : 1;my$sp_index=$index_class->new ($n_boxes,$x_min,$y_min,$x_max,$y_max);for my$segment (@$segments){my$p1=$segment->[0];my$p2=$segment->[1];my$coords=[[$p1->get_x,$p1->get_y],[$p2->get_x,$p2->get_y],];my@bbox=($x_min,$y_min,$x_max,$y_max);$sp_index->insert($coords,@bbox)}$sp_indexes{$part_id}=$sp_index}$self->{_spatial_indexes}=\%sp_indexes;return wantarray ? %sp_indexes : \%sp_indexes}sub _get_part_bounds {my$self=shift;my$part=shift;my$points=$self->get_part($part);my$pt1=shift @$points;my ($x_min,$y_min)=($pt1->get_x,$pt1->get_y);my ($x_max,$y_max)=($x_min,$y_min);for my$pt (@$points){my$x=$pt->get_x;my$y=$pt->get_y;$x_min=min ($x_min,$x);$y_min=min ($y_min,$y);$x_max=max ($x_max,$x);$y_max=max ($y_max,$y)}my%bounds=(x_min=>$x_min,x_max=>$x_max,y_min=>$y_min,y_max=>$y_max,);return wantarray ? %bounds : \%bounds}sub get_segments {my$self=shift;my$part=shift;my$points=$self->get_part($part);my@segments;for my$i (0 .. $#$points - 1){push@segments,[$points->[$i],$points->[$i+1]]}return wantarray ? @segments : \@segments}sub vertex_centroid {my$self=shift;my$part=shift;my ($cx,$cy)=(0,0);my@points=();if ($part){@points=$self->get_part($part)}else {@points=$self->points}for (@points){$cx += $_->X;$cy += $_->Y}Geo::ShapeFile::Point->new(X=>$cx / @points,Y=>$cy / @points,)}*centroid=\&vertex_centroid;sub area_centroid {my ($self,$part)=@_;my ($cx,$cy)=(0,0);my$A=0;my (@points,@parts);if (defined$part){@parts=($part)}else {@parts=(1 .. $self->num_parts)}for my$part (@parts){my ($p0,@pts)=$self->get_part($part);my ($x0,$y0)=($p0->X,$p0->Y);my ($x1,$y1)=(0,0);my ($cxp,$cyp)=(0,0);my$Ap=0;for (@pts){my$x2=$_->X - $x0;my$y2=$_->Y - $y0;$Ap += (my$a=$x2*$y1 - $x1*$y2);$cxp += $a * ($x2 + $x1)/ 3;$cyp += $a * ($y2 + $y1)/ 3;($x1,$y1)=($x2,$y2)}$cx += $Ap * $x0 + $cxp;$cy += $Ap * $y0 + $cyp;$A += $Ap}return Geo::ShapeFile::Point->new(X=>$cx / $A,Y=>$cy / $A,)}sub dump {my$self=shift;my$return='';$return .= sprintf "Shape Type: %s (id: %d)  Parts: %d   Points: %d\n",$self->shape_type_text(),$self->shape_id(),$self->num_parts(),$self->num_points();$return .= sprintf "\tX bounds(min=%s, max=%s)\n",$self->x_min(),$self->x_max();$return .= sprintf "\tY bounds(min=%s, max=%s)\n",$self->y_min(),$self->y_max();if (defined$self->z_min()&& defined$self->z_max()){$return .= sprintf "\tZ bounds(min=%s, max=%s)\n",$self->z_min(),$self->z_max()}if (defined$self->m_min()&& defined$self->m_max()){$return .= sprintf "\tM bounds(min=%s, max=%s)\n",$self->m_min(),$self->m_max()}for (1 .. $self->num_parts()){$return .= "\tPart $_:\n";for ($self->get_part($_)){$return .= "\t\t$_\n"}}$return .= "\n";return$return}1;
GEO_SHAPEFILE_SHAPE

$fatpacked{"Geo/ShapeFile/Shape/Index.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GEO_SHAPEFILE_SHAPE_INDEX';
  package Geo::ShapeFile::Shape::Index;use strict;use warnings;use POSIX qw /floor/;use Carp;use autovivification;our$VERSION='2.64';sub new {my ($class,$n,$x_min,$y_min,$x_max,$y_max)=@_;my$self=bless {},$class;$n ||=10;$n=int$n;die 'Number of blocks must be positive and >=1' if$n <= 0;my$y_range=abs ($y_max - $y_min);my$y_tol=$y_range / 1000;$y_range += 2 * $y_tol;$y_min -= $y_tol;$y_max += $y_tol;my$block_ht=$y_range / $n;$self->{x_min}=$x_min;$self->{y_min}=$y_min;$self->{x_max}=$x_max;$self->{y_max}=$y_max;$self->{y_res}=$block_ht;$self->{y_n}=$n;$self->{x_n}=1;my%blocks;my$y=$y_min;for my$i (1 .. $n){my$key=$self->snap_to_index($x_min,$y);$blocks{$key}=[];$y += $block_ht}$self->{containers}=\%blocks;return$self}sub get_x_min {$_[0]->{x_min}}sub get_x_max {$_[0]->{x_max}}sub get_y_min {$_[0]->{y_min}}sub get_y_max {$_[0]->{y_max}}sub get_y_res {$_[0]->{y_res}}sub _get_container_ref {my ($self,$id)=@_;no autovivification;my$containers=$self->{containers};my$container=$containers->{$id}|| [];return$container};sub snap_to_index {my ($self,$x,$y)=@_;my$y_min=$self->get_y_min;my$y_res=$self->get_y_res;my$partial=($y - $y_min)/ $y_res;my$y_block=floor ($partial * 1.001);return wantarray ? (0,$y_block): "0:$y_block"}sub insert {my ($self,$item,@bbox)=@_;my@index_id1=$self->snap_to_index (@bbox[0,1]);my@index_id2=$self->snap_to_index (@bbox[2,3]);my$insert_count=0;for my$y ($index_id1[1].. $index_id2[1]){my$index_id="0:$y";my$container=$self->_get_container_ref ($index_id);push @$container,$item;$insert_count++}return$insert_count}sub query_point {my ($self,$x,$y,$storage_ref)=@_;my$index_id=$self->snap_to_index ($x,$y);my$container=$self->_get_container_ref ($index_id);if ($storage_ref){push @$storage_ref,@$container}return wantarray ? @$container : [@$container]}1;
GEO_SHAPEFILE_SHAPE_INDEX

$fatpacked{"Graphics/ColorNames.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GRAPHICS_COLORNAMES';
  package Graphics::ColorNames;use 5.006;use base "Exporter";use strict;use warnings;use Carp;use Module::Load 0.10;use Module::Loaded;our$VERSION='2.11';our%EXPORT_TAGS=('all'=>[qw(hex2tuple tuple2hex all_schemes) ],'utility'=>[qw(hex2tuple tuple2hex) ],);our@EXPORT_OK=(@{$EXPORT_TAGS{'all'}});our@EXPORT=();my%FoundSchemes=();our$AUTOLOAD;sub AUTOLOAD {$AUTOLOAD =~ /^(.*:)*([\w\_]+)$/;my$name=$2;my$hex=(my$self=$_[0])->FETCH($name);if (defined$hex){return$hex}else {croak "No method or color named $name"}}sub _load {while(my$module=shift){unless (is_loaded($module)){load($module);mark_as_loaded($module)unless (is_loaded($module))}}}sub _load_scheme_from_module {my$self=shift;my$base=__PACKAGE__;my$module=join('::',$base,(my$scheme=shift));eval {_load($module)};if ($@){eval {_load($module=$scheme)};if ($@){croak "Cannot load color naming scheme \`$module\'"}}{no strict 'refs';if ($module =~ $base){$self->load_scheme($module->NamesRgbTable)}elsif ($module =~ /Color::Library::Dictionary/){$self->load_scheme($module->_load_color_list)}else {croak "Unknown scheme type: $module"}}}sub TIEHASH {my$class=shift || __PACKAGE__;my$self={_schemes=>[],_iterator=>0,};bless$self,$class;if (@_){for my$scheme (@_){if (ref$scheme){$self->load_scheme($scheme)}elsif (-r $scheme){$self->_load_scheme_from_file($scheme)}else {$self->_load_scheme_from_module($scheme)}}}else {$self->_load_scheme_from_module('X')}return$self}sub FETCH {my$self=shift;my$key=lc(shift||"");if ($key =~ m/^\x23?([\da-f]{6})$/){return $1}else {$key =~ s/[^a-z\d\%]//g;my$val=undef;my$i=0;while ((!defined$val)&& ($i < @{$self->{_schemes}})){$val=$self->{_schemes}->[$i++]->{$key}}if (defined$val){return sprintf('%06x',$val),}else {return}}}sub EXISTS {my ($self,$key)=@_;defined ($self->FETCH($key))}sub FIRSTKEY {(my$self=shift)->{_iterator}=0;each %{$self->{_schemes}->[$self->{_iterator}]}}sub NEXTKEY {my$self=shift;my ($key,$val)=each %{$self->{_schemes}->[$self->{_iterator}]};unless (defined$key){($key,$val)=each %{$self->{_schemes}->[++$self->{_iterator}]}}return$key}sub load_scheme {my$self=shift;my$scheme=shift;if (ref($scheme)eq "HASH"){push @{$self->{_schemes}},$scheme}elsif (ref($scheme)eq "CODE"){_load("Tie::Sub");push @{$self->{_schemes}},{};tie %{$self->{_schemes}->[-1]},'Tie::Sub',$scheme}elsif (ref($scheme)eq "ARRAY"){my$s={};for my$rec (@$scheme){my$key=$rec->[0];my$name=$rec->[1];my$code=$rec->[5];$name =~ s/[\W\_]//g;$s->{$name}=$code unless (exists$s->{$name});if ($key =~ /^(.+\:.+)\.(\d+)$/){$s->{"$name$2"}=$code}}push @{$self->{_schemes}},$s}else {undef $!;eval {if ((ref($scheme)eq 'GLOB')|| ref($scheme)eq "IO::File" || $scheme->isa('IO::File')|| ref($scheme)eq "FileHandle" || $scheme->isa('FileHandle')){$self->_load_scheme_from_file($scheme)}};if ($@){croak "Error $@ on scheme type ",ref($scheme)}elsif ($!){croak "$!"}else {}}}sub _find_schemes {my$path=shift;if (-d $path){my$dh=DirHandle->new($path)|| croak "Unable to access directory $path";while (defined(my$fn=$dh->read)){if ((-r File::Spec->catdir($path,$fn))&& ($fn =~ /(.+)\.pm$/)){$FoundSchemes{$1}++}}}}sub _readonly_error {croak "Cannot modify a read-only value"}sub DESTROY {my$self=shift;delete$self->{_schemes};delete$self->{_iterator}}sub UNTIE {}BEGIN {no strict 'refs';*STORE=\ &_readonly_error;*DELETE=\ &_readonly_error;*CLEAR=\ &_readonly_error;*new=\ &TIEHASH}1;sub hex2tuple {my$rgb=CORE::hex(shift);my ($red,$green,$blue);$blue=($rgb & 0x0000ff);$green=($rgb & 0x00ff00)>> 8;$red=($rgb & 0xff0000)>> 16;return ($red,$green,$blue)}sub tuple2hex {my ($red,$green,$blue)=@_;my$rgb=sprintf "%.2x%.2x%.2x",$red,$green,$blue;return$rgb}sub all_schemes {unless (%FoundSchemes){_load("DirHandle","File::Spec");for my$dir (@INC){_find_schemes(File::Spec->catdir($dir,split(/::/,__PACKAGE__)))}}return (keys%FoundSchemes)}sub _load_scheme_from_file {my$self=shift;my$file=shift;unless (ref$file){unless (-r $file){croak "Cannot load scheme from file: \'$file\'"}_load("IO::File")}my$fh=ref($file)? $file : (IO::File->new);unless (ref$file){open($fh,$file)|| croak "Cannot open file: \'$file\'"}my$scheme={};while (my$line=<$fh>){chomp($line);$line =~ s/[\!\#].*$//;if ($line ne ""){my$name=lc(substr($line,12));$name =~ s/[\W]//g;croak "Missing color name",unless ($name ne "");$scheme->{$name}=0;for (0,4,8){$scheme->{$name}<<=8;$scheme->{$name}|=(eval substr($line,$_,3))}}}$self->load_scheme($scheme);unless (ref$file){close$fh}}sub hex {my$self=shift;my$rgb=$self->FETCH(my$name=shift);my$pre=shift || "";return ($pre.$rgb)}sub rgb {my$self=shift;my@rgb=hex2tuple($self->FETCH(my$name=shift));my$sep=shift || ',';return wantarray ? @rgb : join($sep,@rgb)}
GRAPHICS_COLORNAMES

$fatpacked{"Graphics/ColorNames/HTML.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GRAPHICS_COLORNAMES_HTML';
  package Graphics::ColorNames::HTML;use strict;use warnings;our$VERSION='2.11';sub NamesRgbTable() {use integer;return {'black'=>0x000000,'blue'=>0x0000ff,'aqua'=>0x00ffff,'lime'=>0x00ff00,'fuchsia'=>0xff00ff,'fuscia'=>0xff00ff,'red'=>0xff0000,'yellow'=>0xffff00,'white'=>0xffffff,'navy'=>0x000080,'teal'=>0x008080,'green'=>0x008000,'purple'=>0x800080,'maroon'=>0x800000,'olive'=>0x808000,'gray'=>0x808080,'silver'=>0xc0c0c0,}}1;
GRAPHICS_COLORNAMES_HTML

$fatpacked{"Graphics/ColorNames/Netscape.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GRAPHICS_COLORNAMES_NETSCAPE';
  package Graphics::ColorNames::Netscape;use strict;use warnings;our$VERSION='2.11';sub NamesRgbTable() {use integer;return {"white"=>0xffffff,"red"=>0xff0000,"green"=>0x00ff00,"blue"=>0x0000ff,"magenta"=>0xff00ff,"cyan"=>0x00ffff,"yellow"=>0xffff00,"black"=>0x000000,"aquamarine"=>0x70db93,"bakerschocolate"=>0x5c3317,"blueviolet"=>0x9f5f9f,"brass"=>0xb5a642,"brightgold"=>0xd9d919,"brown"=>0xa62a2a,"bronze"=>0x8c7853,"bronzeii"=>0xa67d3d,"cadetblue"=>0x5f9f9f,"coolcopper"=>0xd98719,"copper"=>0xb87333,"coral"=>0xff7f00,"cornflowerblue"=>0x42426f,"darkbrown"=>0x5c4033,"darkgreen"=>0x2f4f2f,"darkgreencopper"=>0x4a766e,"darkolivegreen"=>0x4f4f2f,"darkorchid"=>0x9932cd,"darkpurple"=>0x871f78,"darkslateblue"=>0x241882,"darkslategrey"=>0x2f4f4f,"darktan"=>0x97694f,"darkturquoise"=>0x7093db,"darkwood"=>0x855e42,"dimgrey"=>0x545454,"dustyrose"=>0x856363,"feldspar"=>0xd19275,"firebrick"=>0x8e2323,"flesh"=>0xf5ccb0,"forestgreen"=>0x238e23,"gold"=>0xcd7f32,"goldenrod"=>0xdbdb70,"grey"=>0x545454,"greencopper"=>0x856363,"greenyellow"=>0xd19275,"huntergreen"=>0x8e2323,"indianred"=>0xf5ccb0,"khaki"=>0x238e23,"lightblue"=>0xcdd9d9,"lightgrey"=>0xdbdb70,"lightsteelblue"=>0x545454,"lightwood"=>0x856363,"limegreen"=>0xd19275,"mandarianorange"=>0x8e2323,"maroon"=>0xf5ccb0,"mediumaquamarine"=>0x238e23,"mediumblue"=>0x3232cd,"mediumforestgreen"=>0xdbdb70,"mediumgoldenrod"=>0xeaeaae,"mediumorchid"=>0x9370db,"mediumseagreen"=>0x426f42,"mediumslateblue"=>0x7f00ff,"mediumspringgreen"=>0x7fff00,"mediumturquoise"=>0x70dbdb,"mediumvioletred"=>0xdb7093,"mediumwood"=>0xa68064,"midnightblue"=>0x2f2f4f,"navyblue"=>0x23238e,"neonblue"=>0x4d4dff,"neonpink"=>0xff6ec7,"newmidnightblue"=>0x00009c,"newtan"=>0xebc79e,"oldgold"=>0xcfb53b,"orange"=>0xff7f00,"orangered"=>0xff2400,"orchid"=>0xdb70db,"palegreen"=>0x8fbc8f,"pink"=>0xbc8f8f,"plum"=>0xeaadea,"quartz"=>0xd9d9f3,"richblue"=>0x5959ab,"salmon"=>0x6f4242,"scarlet"=>0x8c1717,"seagreen"=>0x238e68,"semisweetchocolate"=>0x6b4226,"sienna"=>0x8e6b23,"silver"=>0xe6e8fa,"skyblue"=>0x3299cc,"slateblue"=>0x007fff,"spicypink"=>0xff1cae,"springgreen"=>0x00ff7f,"steelblue"=>0x236b8e,"summersky"=>0x38b0de,"tan"=>0xdb9370,"thistle"=>0xd8bfd8,"turquoise"=>0xadeaea,"verydarkbrown"=>0x5c4033,"verylightgrey"=>0xcdcdcd,"violet"=>0x4f2f4f,"violetred"=>0xcc3299,"wheat"=>0xd8d8bf,"yellowgreen"=>0x99cc32,}}1;
GRAPHICS_COLORNAMES_NETSCAPE

$fatpacked{"Graphics/ColorNames/Windows.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GRAPHICS_COLORNAMES_WINDOWS';
  package Graphics::ColorNames::Windows;use strict;use warnings;our$VERSION='2.11';sub NamesRgbTable() {use integer;return {'black'=>0x000000,'blue'=>0x0000ff,'cyan'=>0x00ffff,'green'=>0x00ff00,'magenta'=>0xff00ff,'red'=>0xff0000,'yellow'=>0xffff00,'white'=>0xffffff,'darkblue'=>0x000080,'darkcyan'=>0x008080,'darkgreen'=>0x008000,'darkmagenta'=>0x800080,'darkred'=>0x800000,'darkyellow'=>0x808000,'darkgray'=>0x808080,'lightgray'=>0xc0c0c0,}}1;
GRAPHICS_COLORNAMES_WINDOWS

$fatpacked{"Graphics/ColorNames/X.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GRAPHICS_COLORNAMES_X';
  package Graphics::ColorNames::X;use strict;use warnings;our$VERSION='2.11';sub NamesRgbTable() {use integer;return {"snow"=>0xfffafa,"ghostwhite"=>0xf8f8ff,"whitesmoke"=>0xf5f5f5,"gainsboro"=>0xdcdcdc,"floralwhite"=>0xfffaf0,"oldlace"=>0xfdf5e6,"linen"=>0xfaf0e6,"antiquewhite"=>0xfaebd7,"papayawhip"=>0xffefd5,"blanchedalmond"=>0xffebcd,"bisque"=>0xffe4c4,"peachpuff"=>0xffdab9,"navajowhite"=>0xffdead,"moccasin"=>0xffe4b5,"cornsilk"=>0xfff8dc,"ivory"=>0xfffff0,"lemonchiffon"=>0xfffacd,"seashell"=>0xfff5ee,"honeydew"=>0xf0fff0,"mintcream"=>0xf5fffa,"azure"=>0xf0ffff,"aliceblue"=>0xf0f8ff,"lavender"=>0xe6e6fa,"lavenderblush"=>0xfff0f5,"mistyrose"=>0xffe4e1,"white"=>0xffffff,"black"=>0x000000,"darkslategray"=>0x2f4f4f,"darkslategrey"=>0x2f4f4f,"dimgray"=>0x696969,"dimgrey"=>0x696969,"slategray"=>0x708090,"slategrey"=>0x708090,"lightslategray"=>0x778899,"lightslategrey"=>0x778899,"gray"=>0xbebebe,"grey"=>0xbebebe,"lightgrey"=>0xd3d3d3,"lightgray"=>0xd3d3d3,"midnightblue"=>0x191970,"navy"=>0x000080,"navyblue"=>0x000080,"cornflowerblue"=>0x6495ed,"darkslateblue"=>0x483d8b,"slateblue"=>0x6a5acd,"mediumslateblue"=>0x7b68ee,"lightslateblue"=>0x8470ff,"mediumblue"=>0x0000cd,"royalblue"=>0x4169e1,"blue"=>0x0000ff,"dodgerblue"=>0x1e90ff,"deepskyblue"=>0x00bfff,"skyblue"=>0x87ceeb,"lightskyblue"=>0x87cefa,"steelblue"=>0x4682b4,"lightsteelblue"=>0xb0c4de,"lightblue"=>0xadd8e6,"powderblue"=>0xb0e0e6,"paleturquoise"=>0xafeeee,"darkturquoise"=>0x00ced1,"mediumturquoise"=>0x48d1cc,"turquoise"=>0x40e0d0,"cyan"=>0x00ffff,"lightcyan"=>0xe0ffff,"cadetblue"=>0x5f9ea0,"mediumaquamarine"=>0x66cdaa,"aquamarine"=>0x7fffd4,"darkgreen"=>0x006400,"darkolivegreen"=>0x556b2f,"darkseagreen"=>0x8fbc8f,"seagreen"=>0x2e8b57,"mediumseagreen"=>0x3cb371,"lightseagreen"=>0x20b2aa,"palegreen"=>0x98fb98,"springgreen"=>0x00ff7f,"lawngreen"=>0x7cfc00,"green"=>0x00ff00,"chartreuse"=>0x7fff00,"mediumspringgreen"=>0x00fa9a,"greenyellow"=>0xadff2f,"limegreen"=>0x32cd32,"yellowgreen"=>0x9acd32,"forestgreen"=>0x228b22,"olivedrab"=>0x6b8e23,"darkkhaki"=>0xbdb76b,"khaki"=>0xf0e68c,"palegoldenrod"=>0xeee8aa,"lightgoldenrodyellow"=>0xfafad2,"lightyellow"=>0xffffe0,"yellow"=>0xffff00,"gold"=>0xffd700,"lightgoldenrod"=>0xeedd82,"goldenrod"=>0xdaa520,"darkgoldenrod"=>0xb8860b,"rosybrown"=>0xbc8f8f,"indianred"=>0xcd5c5c,"saddlebrown"=>0x8b4513,"sienna"=>0xa0522d,"peru"=>0xcd853f,"burlywood"=>0xdeb887,"beige"=>0xf5f5dc,"wheat"=>0xf5deb3,"sandybrown"=>0xf4a460,"tan"=>0xd2b48c,"chocolate"=>0xd2691e,"firebrick"=>0xb22222,"brown"=>0xa52a2a,"darksalmon"=>0xe9967a,"salmon"=>0xfa8072,"lightsalmon"=>0xffa07a,"orange"=>0xffa500,"darkorange"=>0xff8c00,"coral"=>0xff7f50,"lightcoral"=>0xf08080,"tomato"=>0xff6347,"orangered"=>0xff4500,"red"=>0xff0000,"hotpink"=>0xff69b4,"deeppink"=>0xff1493,"pink"=>0xffc0cb,"lightpink"=>0xffb6c1,"palevioletred"=>0xdb7093,"maroon"=>0xb03060,"mediumvioletred"=>0xc71585,"violetred"=>0xd02090,"magenta"=>0xff00ff,"violet"=>0xee82ee,"plum"=>0xdda0dd,"orchid"=>0xda70d6,"mediumorchid"=>0xba55d3,"darkorchid"=>0x9932cc,"darkviolet"=>0x9400d3,"blueviolet"=>0x8a2be2,"purple"=>0xa020f0,"mediumpurple"=>0x9370db,"thistle"=>0xd8bfd8,"snow1"=>0xfffafa,"snow2"=>0xeee9e9,"snow3"=>0xcdc9c9,"snow4"=>0x8b8989,"seashell1"=>0xfff5ee,"seashell2"=>0xeee5de,"seashell3"=>0xcdc5bf,"seashell4"=>0x8b8682,"antiquewhite1"=>0xffefdb,"antiquewhite2"=>0xeedfcc,"antiquewhite3"=>0xcdc0b0,"antiquewhite4"=>0x8b8378,"bisque1"=>0xffe4c4,"bisque2"=>0xeed5b7,"bisque3"=>0xcdb79e,"bisque4"=>0x8b7d6b,"peachpuff1"=>0xffdab9,"peachpuff2"=>0xeecbad,"peachpuff3"=>0xcdaf95,"peachpuff4"=>0x8b7765,"navajowhite1"=>0xffdead,"navajowhite2"=>0xeecfa1,"navajowhite3"=>0xcdb38b,"navajowhite4"=>0x8b795e,"lemonchiffon1"=>0xfffacd,"lemonchiffon2"=>0xeee9bf,"lemonchiffon3"=>0xcdc9a5,"lemonchiffon4"=>0x8b8970,"cornsilk1"=>0xfff8dc,"cornsilk2"=>0xeee8cd,"cornsilk3"=>0xcdc8b1,"cornsilk4"=>0x8b8878,"ivory1"=>0xfffff0,"ivory2"=>0xeeeee0,"ivory3"=>0xcdcdc1,"ivory4"=>0x8b8b83,"honeydew1"=>0xf0fff0,"honeydew2"=>0xe0eee0,"honeydew3"=>0xc1cdc1,"honeydew4"=>0x838b83,"lavenderblush1"=>0xfff0f5,"lavenderblush2"=>0xeee0e5,"lavenderblush3"=>0xcdc1c5,"lavenderblush4"=>0x8b8386,"mistyrose1"=>0xffe4e1,"mistyrose2"=>0xeed5d2,"mistyrose3"=>0xcdb7b5,"mistyrose4"=>0x8b7d7b,"azure1"=>0xf0ffff,"azure2"=>0xe0eeee,"azure3"=>0xc1cdcd,"azure4"=>0x838b8b,"slateblue1"=>0x836fff,"slateblue2"=>0x7a67ee,"slateblue3"=>0x6959cd,"slateblue4"=>0x473c8b,"royalblue1"=>0x4876ff,"royalblue2"=>0x436eee,"royalblue3"=>0x3a5fcd,"royalblue4"=>0x27408b,"blue1"=>0x0000ff,"blue2"=>0x0000ee,"blue3"=>0x0000cd,"blue4"=>0x00008b,"dodgerblue1"=>0x1e90ff,"dodgerblue2"=>0x1c86ee,"dodgerblue3"=>0x1874cd,"dodgerblue4"=>0x104e8b,"steelblue1"=>0x63b8ff,"steelblue2"=>0x5cacee,"steelblue3"=>0x4f94cd,"steelblue4"=>0x36648b,"deepskyblue1"=>0x00bfff,"deepskyblue2"=>0x00b2ee,"deepskyblue3"=>0x009acd,"deepskyblue4"=>0x00688b,"skyblue1"=>0x87ceff,"skyblue2"=>0x7ec0ee,"skyblue3"=>0x6ca6cd,"skyblue4"=>0x4a708b,"lightskyblue1"=>0xb0e2ff,"lightskyblue2"=>0xa4d3ee,"lightskyblue3"=>0x8db6cd,"lightskyblue4"=>0x607b8b,"slategray1"=>0xc6e2ff,"slategray2"=>0xb9d3ee,"slategray3"=>0x9fb6cd,"slategray4"=>0x6c7b8b,"slategrey1"=>0xc6e2ff,"slategrey2"=>0xb9d3ee,"slategrey3"=>0x9fb6cd,"slategrey4"=>0x6c7b8b,"lightsteelblue1"=>0xcae1ff,"lightsteelblue2"=>0xbcd2ee,"lightsteelblue3"=>0xa2b5cd,"lightsteelblue4"=>0x6e7b8b,"lightblue1"=>0xbfefff,"lightblue2"=>0xb2dfee,"lightblue3"=>0x9ac0cd,"lightblue4"=>0x68838b,"lightcyan1"=>0xe0ffff,"lightcyan2"=>0xd1eeee,"lightcyan3"=>0xb4cdcd,"lightcyan4"=>0x7a8b8b,"paleturquoise1"=>0xbbffff,"paleturquoise2"=>0xaeeeee,"paleturquoise3"=>0x96cdcd,"paleturquoise4"=>0x668b8b,"cadetblue1"=>0x98f5ff,"cadetblue2"=>0x8ee5ee,"cadetblue3"=>0x7ac5cd,"cadetblue4"=>0x53868b,"turquoise1"=>0x00f5ff,"turquoise2"=>0x00e5ee,"turquoise3"=>0x00c5cd,"turquoise4"=>0x00868b,"cyan1"=>0x00ffff,"cyan2"=>0x00eeee,"cyan3"=>0x00cdcd,"cyan4"=>0x008b8b,"darkslategray1"=>0x97ffff,"darkslategray2"=>0x8deeee,"darkslategray3"=>0x79cdcd,"darkslategray4"=>0x528b8b,"darkslategrey1"=>0x97ffff,"darkslategrey2"=>0x8deeee,"darkslategrey3"=>0x79cdcd,"darkslategrey4"=>0x528b8b,"aquamarine1"=>0x7fffd4,"aquamarine2"=>0x76eec6,"aquamarine3"=>0x66cdaa,"aquamarine4"=>0x458b74,"darkseagreen1"=>0xc1ffc1,"darkseagreen2"=>0xb4eeb4,"darkseagreen3"=>0x9bcd9b,"darkseagreen4"=>0x698b69,"seagreen1"=>0x54ff9f,"seagreen2"=>0x4eee94,"seagreen3"=>0x43cd80,"seagreen4"=>0x2e8b57,"palegreen1"=>0x9aff9a,"palegreen2"=>0x90ee90,"palegreen3"=>0x7ccd7c,"palegreen4"=>0x548b54,"springgreen1"=>0x00ff7f,"springgreen2"=>0x00ee76,"springgreen3"=>0x00cd66,"springgreen4"=>0x008b45,"green1"=>0x00ff00,"green2"=>0x00ee00,"green3"=>0x00cd00,"green4"=>0x008b00,"chartreuse1"=>0x7fff00,"chartreuse2"=>0x76ee00,"chartreuse3"=>0x66cd00,"chartreuse4"=>0x458b00,"olivedrab1"=>0xc0ff3e,"olivedrab2"=>0xb3ee3a,"olivedrab3"=>0x9acd32,"olivedrab4"=>0x698b22,"darkolivegreen1"=>0xcaff70,"darkolivegreen2"=>0xbcee68,"darkolivegreen3"=>0xa2cd5a,"darkolivegreen4"=>0x6e8b3d,"khaki1"=>0xfff68f,"khaki2"=>0xeee685,"khaki3"=>0xcdc673,"khaki4"=>0x8b864e,"lightgoldenrod1"=>0xffec8b,"lightgoldenrod2"=>0xeedc82,"lightgoldenrod3"=>0xcdbe70,"lightgoldenrod4"=>0x8b814c,"lightyellow1"=>0xffffe0,"lightyellow2"=>0xeeeed1,"lightyellow3"=>0xcdcdb4,"lightyellow4"=>0x8b8b7a,"yellow1"=>0xffff00,"yellow2"=>0xeeee00,"yellow3"=>0xcdcd00,"yellow4"=>0x8b8b00,"gold1"=>0xffd700,"gold2"=>0xeec900,"gold3"=>0xcdad00,"gold4"=>0x8b7500,"goldenrod1"=>0xffc125,"goldenrod2"=>0xeeb422,"goldenrod3"=>0xcd9b1d,"goldenrod4"=>0x8b6914,"darkgoldenrod1"=>0xffb90f,"darkgoldenrod2"=>0xeead0e,"darkgoldenrod3"=>0xcd950c,"darkgoldenrod4"=>0x8b6508,"rosybrown1"=>0xffc1c1,"rosybrown2"=>0xeeb4b4,"rosybrown3"=>0xcd9b9b,"rosybrown4"=>0x8b6969,"indianred1"=>0xff6a6a,"indianred2"=>0xee6363,"indianred3"=>0xcd5555,"indianred4"=>0x8b3a3a,"sienna1"=>0xff8247,"sienna2"=>0xee7942,"sienna3"=>0xcd6839,"sienna4"=>0x8b4726,"burlywood1"=>0xffd39b,"burlywood2"=>0xeec591,"burlywood3"=>0xcdaa7d,"burlywood4"=>0x8b7355,"wheat1"=>0xffe7ba,"wheat2"=>0xeed8ae,"wheat3"=>0xcdba96,"wheat4"=>0x8b7e66,"tan1"=>0xffa54f,"tan2"=>0xee9a49,"tan3"=>0xcd853f,"tan4"=>0x8b5a2b,"chocolate1"=>0xff7f24,"chocolate2"=>0xee7621,"chocolate3"=>0xcd661d,"chocolate4"=>0x8b4513,"firebrick1"=>0xff3030,"firebrick2"=>0xee2c2c,"firebrick3"=>0xcd2626,"firebrick4"=>0x8b1a1a,"brown1"=>0xff4040,"brown2"=>0xee3b3b,"brown3"=>0xcd3333,"brown4"=>0x8b2323,"salmon1"=>0xff8c69,"salmon2"=>0xee8262,"salmon3"=>0xcd7054,"salmon4"=>0x8b4c39,"lightsalmon1"=>0xffa07a,"lightsalmon2"=>0xee9572,"lightsalmon3"=>0xcd8162,"lightsalmon4"=>0x8b5742,"orange1"=>0xffa500,"orange2"=>0xee9a00,"orange3"=>0xcd8500,"orange4"=>0x8b5a00,"darkorange1"=>0xff7f00,"darkorange2"=>0xee7600,"darkorange3"=>0xcd6600,"darkorange4"=>0x8b4500,"coral1"=>0xff7256,"coral2"=>0xee6a50,"coral3"=>0xcd5b45,"coral4"=>0x8b3e2f,"tomato1"=>0xff6347,"tomato2"=>0xee5c42,"tomato3"=>0xcd4f39,"tomato4"=>0x8b3626,"orangered1"=>0xff4500,"orangered2"=>0xee4000,"orangered3"=>0xcd3700,"orangered4"=>0x8b2500,"red1"=>0xff0000,"red2"=>0xee0000,"red3"=>0xcd0000,"red4"=>0x8b0000,"deeppink1"=>0xff1493,"deeppink2"=>0xee1289,"deeppink3"=>0xcd1076,"deeppink4"=>0x8b0a50,"hotpink1"=>0xff6eb4,"hotpink2"=>0xee6aa7,"hotpink3"=>0xcd6090,"hotpink4"=>0x8b3a62,"pink1"=>0xffb5c5,"pink2"=>0xeea9b8,"pink3"=>0xcd919e,"pink4"=>0x8b636c,"lightpink1"=>0xffaeb9,"lightpink2"=>0xeea2ad,"lightpink3"=>0xcd8c95,"lightpink4"=>0x8b5f65,"palevioletred1"=>0xff82ab,"palevioletred2"=>0xee799f,"palevioletred3"=>0xcd6889,"palevioletred4"=>0x8b475d,"maroon1"=>0xff34b3,"maroon2"=>0xee30a7,"maroon3"=>0xcd2990,"maroon4"=>0x8b1c62,"violetred1"=>0xff3e96,"violetred2"=>0xee3a8c,"violetred3"=>0xcd3278,"violetred4"=>0x8b2252,"magenta1"=>0xff00ff,"magenta2"=>0xee00ee,"magenta3"=>0xcd00cd,"magenta4"=>0x8b008b,"orchid1"=>0xff83fa,"orchid2"=>0xee7ae9,"orchid3"=>0xcd69c9,"orchid4"=>0x8b4789,"plum1"=>0xffbbff,"plum2"=>0xeeaeee,"plum3"=>0xcd96cd,"plum4"=>0x8b668b,"mediumorchid1"=>0xe066ff,"mediumorchid2"=>0xd15fee,"mediumorchid3"=>0xb452cd,"mediumorchid4"=>0x7a378b,"darkorchid1"=>0xbf3eff,"darkorchid2"=>0xb23aee,"darkorchid3"=>0x9a32cd,"darkorchid4"=>0x68228b,"purple1"=>0x9b30ff,"purple2"=>0x912cee,"purple3"=>0x7d26cd,"purple4"=>0x551a8b,"mediumpurple1"=>0xab82ff,"mediumpurple2"=>0x9f79ee,"mediumpurple3"=>0x8968cd,"mediumpurple4"=>0x5d478b,"thistle1"=>0xffe1ff,"thistle2"=>0xeed2ee,"thistle3"=>0xcdb5cd,"thistle4"=>0x8b7b8b,"gray0"=>0x000000,"gray1"=>0x030303,"gray2"=>0x050505,"gray3"=>0x080808,"gray4"=>0x0a0a0a,"gray5"=>0x0d0d0d,"gray6"=>0x0f0f0f,"gray7"=>0x121212,"gray8"=>0x141414,"gray9"=>0x171717,"gray10"=>0x1a1a1a,"gray11"=>0x1c1c1c,"gray12"=>0x1f1f1f,"gray13"=>0x212121,"gray14"=>0x242424,"gray15"=>0x262626,"gray16"=>0x292929,"gray17"=>0x2b2b2b,"gray18"=>0x2e2e2e,"gray19"=>0x303030,"gray20"=>0x333333,"gray21"=>0x363636,"gray22"=>0x383838,"gray23"=>0x3b3b3b,"gray24"=>0x3d3d3d,"gray25"=>0x404040,"gray26"=>0x424242,"gray27"=>0x454545,"gray28"=>0x474747,"gray29"=>0x4a4a4a,"gray30"=>0x4d4d4d,"gray31"=>0x4f4f4f,"gray32"=>0x525252,"gray33"=>0x545454,"gray34"=>0x575757,"gray35"=>0x595959,"gray36"=>0x5c5c5c,"gray37"=>0x5e5e5e,"gray38"=>0x616161,"gray39"=>0x636363,"gray40"=>0x666666,"gray41"=>0x696969,"gray42"=>0x6b6b6b,"gray43"=>0x6e6e6e,"gray44"=>0x707070,"gray45"=>0x737373,"gray46"=>0x757575,"gray47"=>0x787878,"gray48"=>0x7a7a7a,"gray49"=>0x7d7d7d,"gray50"=>0x7f7f7f,"gray51"=>0x828282,"gray52"=>0x858585,"gray53"=>0x878787,"gray54"=>0x8a8a8a,"gray55"=>0x8c8c8c,"gray56"=>0x8f8f8f,"gray57"=>0x919191,"gray58"=>0x949494,"gray59"=>0x969696,"gray60"=>0x999999,"gray61"=>0x9c9c9c,"gray62"=>0x9e9e9e,"gray63"=>0xa1a1a1,"gray64"=>0xa3a3a3,"gray65"=>0xa6a6a6,"gray66"=>0xa8a8a8,"gray67"=>0xababab,"gray68"=>0xadadad,"gray69"=>0xb0b0b0,"gray70"=>0xb3b3b3,"gray71"=>0xb5b5b5,"gray72"=>0xb8b8b8,"gray73"=>0xbababa,"gray74"=>0xbdbdbd,"gray75"=>0xbfbfbf,"gray76"=>0xc2c2c2,"gray77"=>0xc4c4c4,"gray78"=>0xc7c7c7,"gray79"=>0xc9c9c9,"gray80"=>0xcccccc,"gray81"=>0xcfcfcf,"gray82"=>0xd1d1d1,"gray83"=>0xd4d4d4,"gray84"=>0xd6d6d6,"gray85"=>0xd9d9d9,"gray86"=>0xdbdbdb,"gray87"=>0xdedede,"gray88"=>0xe0e0e0,"gray89"=>0xe3e3e3,"gray90"=>0xe5e5e5,"gray91"=>0xe8e8e8,"gray92"=>0xebebeb,"gray93"=>0xededed,"gray94"=>0xf0f0f0,"gray95"=>0xf2f2f2,"gray96"=>0xf5f5f5,"gray97"=>0xf7f7f7,"gray98"=>0xfafafa,"gray99"=>0xfcfcfc,"gray100"=>0xffffff,"grey0"=>0x000000,"grey1"=>0x030303,"grey2"=>0x050505,"grey3"=>0x080808,"grey4"=>0x0a0a0a,"grey5"=>0x0d0d0d,"grey6"=>0x0f0f0f,"grey7"=>0x121212,"grey8"=>0x141414,"grey9"=>0x171717,"grey10"=>0x1a1a1a,"grey11"=>0x1c1c1c,"grey12"=>0x1f1f1f,"grey13"=>0x212121,"grey14"=>0x242424,"grey15"=>0x262626,"grey16"=>0x292929,"grey17"=>0x2b2b2b,"grey18"=>0x2e2e2e,"grey19"=>0x303030,"grey20"=>0x333333,"grey21"=>0x363636,"grey22"=>0x383838,"grey23"=>0x3b3b3b,"grey24"=>0x3d3d3d,"grey25"=>0x404040,"grey26"=>0x424242,"grey27"=>0x454545,"grey28"=>0x474747,"grey29"=>0x4a4a4a,"grey30"=>0x4d4d4d,"grey31"=>0x4f4f4f,"grey32"=>0x525252,"grey33"=>0x545454,"grey34"=>0x575757,"grey35"=>0x595959,"grey36"=>0x5c5c5c,"grey37"=>0x5e5e5e,"grey38"=>0x616161,"grey39"=>0x636363,"grey40"=>0x666666,"grey41"=>0x696969,"grey42"=>0x6b6b6b,"grey43"=>0x6e6e6e,"grey44"=>0x707070,"grey45"=>0x737373,"grey46"=>0x757575,"grey47"=>0x787878,"grey48"=>0x7a7a7a,"grey49"=>0x7d7d7d,"grey50"=>0x7f7f7f,"grey51"=>0x828282,"grey52"=>0x858585,"grey53"=>0x878787,"grey54"=>0x8a8a8a,"grey55"=>0x8c8c8c,"grey56"=>0x8f8f8f,"grey57"=>0x919191,"grey58"=>0x949494,"grey59"=>0x969696,"grey60"=>0x999999,"grey61"=>0x9c9c9c,"grey62"=>0x9e9e9e,"grey63"=>0xa1a1a1,"grey64"=>0xa3a3a3,"grey65"=>0xa6a6a6,"grey66"=>0xa8a8a8,"grey67"=>0xababab,"grey68"=>0xadadad,"grey69"=>0xb0b0b0,"grey70"=>0xb3b3b3,"grey71"=>0xb5b5b5,"grey72"=>0xb8b8b8,"grey73"=>0xbababa,"grey74"=>0xbdbdbd,"grey75"=>0xbfbfbf,"grey76"=>0xc2c2c2,"grey77"=>0xc4c4c4,"grey78"=>0xc7c7c7,"grey79"=>0xc9c9c9,"grey80"=>0xcccccc,"grey81"=>0xcfcfcf,"grey82"=>0xd1d1d1,"grey83"=>0xd4d4d4,"grey84"=>0xd6d6d6,"grey85"=>0xd9d9d9,"grey86"=>0xdbdbdb,"grey87"=>0xdedede,"grey88"=>0xe0e0e0,"grey89"=>0xe3e3e3,"grey90"=>0xe5e5e5,"grey91"=>0xe8e8e8,"grey92"=>0xebebeb,"grey93"=>0xededed,"grey94"=>0xf0f0f0,"grey95"=>0xf2f2f2,"grey96"=>0xf5f5f5,"grey97"=>0xf7f7f7,"grey98"=>0xfafafa,"grey99"=>0xfcfcfc,"grey100"=>0xffffff,"darkgrey"=>0xa9a9a9,"darkgray"=>0xa9a9a9,"darkblue"=>0x00008b,"darkcyan"=>0x008b8b,"darkmagenta"=>0x8b008b,"darkred"=>0x8b0000,"lightgreen"=>0x90ee90,}}1;
GRAPHICS_COLORNAMES_X

$fatpacked{"Graphics/ColorObject.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GRAPHICS_COLOROBJECT';
  package Graphics::ColorObject;use 5.006;use strict;use warnings;require Exporter;our@ISA=qw(Exporter);our%EXPORT_TAGS=('all'=>[qw(RGB_to_RGB255 RGB255_to_RGB RGBhex_to_RGB RGB_to_RGBhex RGB_to_XYZ XYZ_to_RGB XYZ_to_Lab Lab_to_XYZ RGB_to_Lab Lab_to_RGB XYZ_to_Luv Luv_to_XYZ Luv_to_LCHuv LCHuv_to_Luv XYZ_to_xyY xyY_to_XYZ Lab_to_LCHab LCHab_to_Lab RGB_to_linear_RGB linear_RGB_to_RGB RGB_to_YPbPr YPbPr_to_RGB RGB_to_HSV HSV_to_RGB RGB_to_HSL HSL_to_RGB) ]);our@EXPORT_OK=(@{$EXPORT_TAGS{'all'}});our@EXPORT=qw();our$VERSION='0.5.0';use Carp;use POSIX qw(pow);use Math::Trig;use vars qw(%RGB_SPACES %WHITE_POINTS %COLORNAMES);sub new {my ($pkgname,@opts)=@_;my$this=+{};bless$this,$pkgname;my$col=&Graphics::ColorObject::namecolor($opts[0]);if ($col){shift(@opts);$this=new_RGB($pkgname,$col,@opts);return$this}if (scalar(@opts)% 2==0){my%opts=@opts;$this->{space}=$opts{space};$this->{white_point}=$opts{white_point}}return$this}sub new_XYZ {my ($pkgname,$xyz,%opts)=@_;my$this=&new($pkgname,%opts);$this->{xyz}=$xyz;return$this}sub new_xyY {my ($pkgname,$xyy,%opts)=@_;my$this=&new($pkgname,%opts);$this->{xyz}=&xyY_to_XYZ($xyy);return$this}sub new_RGB {my ($pkgname,$rgb,%opts)=@_;my$this=&new($pkgname,%opts);$this->{xyz}=&RGB_to_XYZ($rgb,$this->{space});return$this}sub new_RGB255 {my ($pkgname,$rgb255,%opts)=@_;return&new_RGB($pkgname,&RGB255_to_RGB($rgb255),%opts)}sub new_RGBhex {my ($pkgname,$rgbhex,%opts)=@_;return&new_RGB($pkgname,&RGBhex_to_RGB($rgbhex),%opts)}sub new_Lab {my ($pkgname,$lab,%opts)=@_;my$this=&new($pkgname,%opts);$this->{xyz}=&Lab_to_XYZ($lab,$this->get_XYZ_white());return$this}sub new_LCHab {my ($pkgname,$lch,%opts)=@_;my$this=&new($pkgname,%opts);$this->{xyz}=&Lab_to_XYZ(&LCHab_to_Lab($lch),$this->get_XYZ_white());return$this}sub new_Luv {my ($pkgname,$luv,%opts)=@_;my$this=&new($pkgname,%opts);$this->{xyz}=&Luv_to_XYZ($luv,$this->get_XYZ_white());return$this}sub new_LCHuv {my ($pkgname,$lch,%opts)=@_;my$this=&new($pkgname,%opts);$this->{xyz}=&Luv_to_XYZ(&LCHuv_to_Luv($lch),$this->get_XYZ_white());return$this}sub new_HSL {my ($pkgname,$hsl,%opts)=@_;return&new_RGB($pkgname,&HSL_to_RGB($hsl),%opts)}sub new_HSV {my ($pkgname,$hsv,%opts)=@_;return&new_RGB($pkgname,&HSV_to_RGB($hsv),%opts)}sub new_CMY {my ($pkgname,$cmy,%opts)=@_;return&new_RGB($pkgname,&CMY_to_RGB($cmy),%opts)}sub new_CMYK {my ($pkgname,$cmyk,%opts)=@_;return&new_RGB($pkgname,&CMY_to_RGB(&CMYK_to_CMY($cmyk)),%opts)}sub new_YPbPr {my ($pkgname,$ypbpr,%opts)=@_;return&new_RGB($pkgname,&YPbPr_to_RGB($ypbpr),space=>'NTSC')}sub new_YCbCr {my ($pkgname,$ycbcr,%opts)=@_;return&new_RGB($pkgname,&YCbCr_to_RGB($ycbcr),space=>'NTSC')}sub new_YUV {my ($pkgname,$yuv,%opts)=@_;return&new_RGB($pkgname,&YUV_to_RGB($yuv),space=>'NTSC')}sub new_YIQ {my ($pkgname,$yiq,%opts)=@_;return&new_RGB($pkgname,&YIQ_to_RGB($yiq),space=>'NTSC')}sub new_PhotoYCC {my ($pkgname,$ycc,%opts)=@_;return&new_RGB($pkgname,&PhotoYCC_to_RGB($ycc),space=>'sRGB')}sub as_XYZ {my ($this,%opts)=@_;my$xyz=$this->{xyz};if ($opts{clip}){my ($Xw,$Yw,$Zw)=@{$this->get_XYZ_white()};$xyz=&_generic_clip($xyz,[[0,$Xw],[0,$Yw],[0,$Zw]])}return$xyz}sub as_RGB {my ($this,%opts)=@_;my$space=$opts{space}|| $this->{space};my$rgb=&XYZ_to_RGB($this->{xyz},$space);if ($opts{clip}){$rgb=&_generic_clip($rgb,[[0,1],[0,1],[0,1]])};return$rgb}sub as_RGB255 {my ($this)=@_;return&RGB_to_RGB255($this->as_RGB())}sub as_RGBhex {my ($this)=@_;return&RGB_to_RGBhex($this->as_RGB())}sub as_xyY {my ($this,%opts)=@_;my$xyy=&XYZ_to_xyY($this->{xyz},$this->get_XYZ_white());return$xyy}sub as_Lab {my ($this)=@_;my$lab=&XYZ_to_Lab($this->{xyz},$this->get_XYZ_white());return$lab}sub as_LCHab {my ($this)=@_;my$lchab=&Lab_to_LCHab(&XYZ_to_Lab($this->{xyz},$this->get_XYZ_white()));return$lchab}sub as_Luv {my ($this)=@_;my$luv=&XYZ_to_Luv($this->{xyz},$this->get_XYZ_white());return$luv}sub as_LCHuv {my ($this)=@_;my$lchuv=&Luv_to_LCHuv(&XYZ_to_Luv($this->{xyz},$this->get_XYZ_white()));return$lchuv}sub as_HSL {my ($this,%opts)=@_;my$hsl=&RGB_to_HSL($this->as_RGB());if ($opts{clip}){$hsl=&_generic_clip($hsl,[[0,360],[0,1],[0,1]])};return$hsl}sub as_HSV {my ($this,%opts)=@_;my$hsv=&RGB_to_HSV($this->as_RGB());if ($opts{clip}){$hsv=&_generic_clip($hsv,[[0,360],[0,1],[0,1]])};return$hsv}sub as_CMY {my ($this,%opts)=@_;my$cmy=&RGB_to_CMY($this->as_RGB());if ($opts{clip}){$cmy=&_generic_clip($cmy,[[0,1],[0,1],[0,1]])};return$cmy}sub as_CMYK {my ($this)=@_;my$cmyk=&CMY_to_CMYK(&RGB_to_CMY($this->as_RGB()));return$cmyk}sub as_YPbPr {my ($this,%opts)=@_;my$ypbpr=&RGB_to_YPbPr($this->as_RGB(space=>'NTSC'));if ($opts{clip}){$ypbpr=&_generic_clip($ypbpr,[[0,1],[-0.5,0.5],[-0.5,0.5]])};return$ypbpr}sub as_YCbCr {my ($this,%opts)=@_;my$ycbcr=&RGB_to_YCbCr($this->as_RGB(space=>'NTSC'));if ($opts{clip}){$ycbcr=&_generic_clip($ycbcr,[[16,235],[16,239],[16,239]])};return$ycbcr}sub as_YUV {my ($this)=@_;my$yuv=&RGB_to_YUV($this->as_RGB(space=>'NTSC'));return$yuv}sub as_YIQ {my ($this)=@_;my$yiq=&RGB_to_YIQ($this->as_RGB(space=>'NTSC'));return$yiq}sub as_PhotoYCC {my ($this)=@_;my$ycc=&RGB_to_PhotoYCC($this->as_RGB(space=>'sRGB'));return$ycc}sub get_XYZ_white {my ($this,%opts)=@_;my$white_point=$opts{white_point}|| $this->{white_point}|| &_get_RGB_space_by_name($opts{space}|| $this->{space})->{white_point};$white_point=&_check_white_point($white_point);my$xy=$WHITE_POINTS{$white_point };my ($x,$y)=@{$xy};return&xyY_to_XYZ([$x,$y,1.0])}sub get_white_point {my ($this)=@_;return$this->{white_point}}sub set_white_point {my ($this,$white_point)=@_;$white_point=&_check_white_point($white_point);if (&_check_white_point($this->{white_point})ne $white_point){$this->{xyz}=&XYZ_change_white_point($this->{xyz},$this->get_XYZ_white(),$this->get_XYZ_white($white_point));$this->{white_point}=$white_point}return$this}sub get_rgb_space {my ($this)=@_;return$this->{space}}sub set_rgb_space {my ($this,$space)=@_;my$s=&_get_RGB_space_by_name($space);if ($this->get_white_point()ne $s->{white_point}){$this->set_white_point($s->{white_point})}$this->{space}=$space;return$this}sub copy {my ($this)=@_;my$copy=+{xyz=>$this->{xyz},space=>$this->{space},white_point=>$this->{white_point}};bless$copy,ref$this;return$copy}sub equals {my ($this,$other,%opts)=@_;$other=$other->copy();$other->set_white_point($this->{white_point});$other->set_rgb_space($this->{space});my$accuracy=$opts{accuracy}|| 0.0001;if (&_delta_v3($this->{xyz},$other->{xyz})< $accuracy){return 1}else {return 0}}sub difference {my ($this,$other)=@_;return$this->difference_CIE1976($other)}sub difference_CIE1976 {my ($this,$other)=@_;my ($L1,$a1,$b1)=@{$this->as_Lab()};my ($L2,$a2,$b2)=@{$other->as_Lab()};my$deltaE=sqrt(&_sqr($L1-$L2)+ &_sqr($a1-$a2)+ &_sqr($b1-$b2));return$deltaE}sub difference_CIE1994 {}sub difference_CMC {my ($this,$other,%opts)=@_;my$l=$opts{l}|| 1;my$c=$opts{c}|| 1;my ($L1,$a1,$b1)=@{$this->as_Lab()};my ($L2,$a2,$b2)=@{$other->as_Lab()};my$C1=sqrt($a1*$a1 + $b1*$b1);my$C2=sqrt($a2*$a2 + $b2*$b2);my$dH=sqrt(&_sqr($a1-$a2)+ &_sqr($b1-$b2)- &_sqr($C1-$C2));my$SL=($L1 < 16 ? 0.511 : 0.040975 * $L1 / (1 + 0.01765 * $L1));my$SC=0.638 + 0.0638 * $C1 / (1 + 0.0131 * $C1);my$F=sqrt(pow($C1,4)/ (pow($C1,4)+ 1900));my$H1=atan2($b1,$a1);my$T=((deg2rad(164)<= $H1 && $H1 <= deg2rad(345))? 0.56 + abs(0.2 * cos($H1 + deg2rad(168))): 0.36 + abs(0.4 * cos($H1 + deg2rad(35))));my$SH=$SC * ($F*$T - $F + 1);my$deltaE=sqrt(&_sqr(($L1 - $L2)/($l * $SL))+ &_sqr(($C1 - $C2)/($c * $SC))+ &_sqr($dH/$SH));return$deltaE}sub list_colorspaces {return qw(RGB XYZ xyY Lab LCHab Luv LCHuv HSL HSV CMY CMYK YCbCr YPbPr YUV YIQ)}sub list_rgb_spaces {return sort keys%RGB_SPACES}sub list_white_points {return sort keys%WHITE_POINTS}sub RGB_to_RGB255 {my ($rgb)=@_;my ($r,$g,$b)=@{$rgb};if ($r < 0){$r=0}elsif ($r > 1){$r=1}if ($g < 0){$g=0}elsif ($g > 1){$g=1}if ($b < 0){$b=0}elsif ($b > 1){$b=1}return [sprintf('%.0f',255*$r),sprintf('%.0f',255*$g),sprintf('%.0f',255*$b)]}sub RGB255_to_RGB {my ($rgb255)=@_;my ($r,$g,$b)=@{$rgb255};return [$r/255,$g/255,$b/255 ]}sub RGBhex_to_RGB {my ($rgbhex)=@_;my ($r,$g,$b);if ($rgbhex =~ m!^\#([0-9a-fA-F]{6})!){$rgbhex=$1}if ($rgbhex =~ m!^[0-9a-fA-F]{6}$!){$r=hex(substr($rgbhex,0,2));$g=hex(substr($rgbhex,2,2));$b=hex(substr($rgbhex,4,2))}return&RGB255_to_RGB([$r,$g,$b])}sub RGB_to_RGBhex {my ($rgb)=@_;my$rgb255=&RGB_to_RGB255($rgb);return sprintf('%02X%02X%02X',@{$rgb255})}sub RGB_to_XYZ {my ($rgb,$space)=@_;my$s=&_get_RGB_space_by_name($space);my$rgb_lin=&RGB_to_linear_RGB($rgb,$space);my$xyz=&_mult_v3_m33($rgb_lin,$s->{m});return ($xyz)}sub XYZ_to_RGB {my ($xyz,$space)=@_;my$s=&_get_RGB_space_by_name($space);my$rgb_lin=&_mult_v3_m33($xyz,$s->{mstar});my$rgb=&linear_RGB_to_RGB($rgb_lin,$space);return ($rgb)}sub XYZ_to_Lab {my ($xyz,$xyz_white)=@_;my ($X,$Y,$Z)=@{$xyz};my ($Xw,$Yw,$Zw)=@{$xyz_white};my ($L,$a,$b);my$epsilon=0.008856;my$kappa=903.3;my ($fx,$fy,$fz);my ($xr,$yr,$zr)=($X / $Xw,$Y / $Yw,$Z / $Zw);if ($xr > $epsilon){$fx=pow($xr,1/3)}else {$fx=($kappa*$xr + 16)/116}if ($yr > $epsilon){$fy=pow($yr,1/3)}else {$fy=($kappa*$yr + 16)/116}if ($zr > $epsilon){$fz=pow($zr,1/3)}else {$fz=($kappa*$zr + 16)/116}$L=116 * $fy - 16;$a=500 * ($fx - $fy);$b=200 * ($fy - $fz);return [$L,$a,$b ]}sub Lab_to_XYZ {my ($lab,$xyz_white)=@_;my ($L,$a,$b)=@{$lab};my ($Xw,$Yw,$Zw)=@{$xyz_white};my ($X,$Y,$Z);my$epsilon=0.008856;my$kappa=903.3;my ($fx,$fy,$fz);my ($xr,$yr,$zr);if ($L > $kappa*$epsilon){$yr=pow(($L + 16)/116,3)}else {$yr=$L / $kappa}if ($yr > $epsilon){$fy=($L + 16)/116}else {$fy=($kappa*$yr + 16)/116}$fx=($a / 500)+ $fy;$fz=$fy - ($b / 200);if (pow($fx,3)> $epsilon){$xr=pow($fx,3)}else {$xr=(116 * $fx - 16)/$kappa}if (pow($fz,3)> $epsilon){$zr=pow($fz,3)}else {$zr=(116 * $fz - 16)/$kappa}if ($L > $kappa*$epsilon){$yr=pow(($L + 16)/116,3)}else {$yr=$L/$kappa}$X=$xr * $Xw;$Y=$yr * $Yw;$Z=$zr * $Zw;return [$X,$Y,$Z ]}sub RGB_to_Lab {my ($rgb,$space)=@_;my$xyz_white=&RGB_to_XYZ([1.0,1.0,1.0 ],$space);my$xyz=&RGB_to_XYZ($rgb,$space);return&XYZ_to_Lab($xyz,$xyz_white)}sub Lab_to_RGB {my ($lab,$space)=@_;my$xyz_white=&RGB_to_XYZ([1.0,1.0,1.0 ],$space);my$xyz=&Lab_to_XYZ($lab,$xyz_white);return&XYZ_to_RGB($xyz,$space)}sub XYZ_to_Luv {my ($xyz,$xyz_white)=@_;my ($X,$Y,$Z)=@{$xyz};my ($Xw,$Yw,$Zw)=@{$xyz_white};my ($L,$u,$v);my$epsilon=0.008856;my$kappa=903.3;my ($yr)=($Y / $Yw);if ($yr > $epsilon){$L=116 * pow($yr,1/3)- 16}else {$L=$kappa*$yr}my ($up,$vp);my ($upw,$vpw);($upw,$vpw)=(4 * $Xw / ($Xw + 15 * $Yw + 3 * $Zw),9 * $Yw / ($Xw + 15 * $Yw + 3 * $Zw));if (!($X==0 && $Y==0 && $Z==0)){($up,$vp)=(4 * $X / ($X + 15 * $Y + 3 * $Z),9 * $Y / ($X + 15 * $Y + 3 * $Z))}else {($up,$vp)=($upw,$vpw)}($u,$v)=(13 * $L * ($up - $upw),13 * $L * ($vp - $vpw));return [$L,$u,$v ]}sub Luv_to_XYZ {my ($luv,$xyz_white)=@_;my ($L,$u,$v)=@{$luv};my ($Xw,$Yw,$Zw)=@{$xyz_white};my ($X,$Y,$Z);my$epsilon=0.008856;my$kappa=903.3;if ($L > $kappa*$epsilon){$Y=pow(($L + 16)/116,3)}else {$Y=$L / $kappa}my ($upw,$vpw)=(4 * $Xw / ($Xw + 15 * $Yw + 3 * $Zw),9 * $Yw / ($Xw + 15 * $Yw + 3 * $Zw));if (!($L==0 && $u==0 && $v==0)){my$a=(1/3)*(((52 * $L)/ ($u + 13 * $L * $upw))- 1);my$b=-5 * $Y;my$c=-1/3;my$d=$Y * (((39 * $L)/ ($v + 13 * $L * $vpw))- 5);$X=($d - $b)/($a - $c);$Z=$X * $a + $b}else {($X,$Z)=(0.0,0.0)}return [$X,$Y,$Z ]}sub Luv_to_LCHuv {my ($luv)=@_;my ($L,$u,$v)=@{$luv};my ($C,$H);$C=sqrt($u*$u + $v*$v);$H=atan2($v,$u);$H=rad2deg($H);return [$L,$C,$H ]}sub LCHuv_to_Luv {my ($lch)=@_;my ($L,$C,$H)=@{$lch};my ($u,$v);$H=deg2rad($H);my$th=tan($H);$u=$C / sqrt($th * $th + 1);$v=sqrt($C*$C - $u*$u);if ($H < 0){$H=$H + 2*pi}if ($H > pi/2 && $H < 3*pi/2){$u= - $u}if ($H > pi){$v= - $v}return [$L,$u,$v ]}sub XYZ_to_xyY {my ($xyz,$xyz_white)=@_;my ($X,$Y,$Z)=@{$xyz};my ($Xw,$Yw,$Zw)=@{$xyz_white};my ($x,$y);if (!($X==0 && $Y==0 && $Z==0)){$x=$X / ($X + $Y + $Z);$y=$Y / ($X + $Y + $Z)}else {$x=$Xw / ($Xw + $Yw + $Zw);$y=$Yw / ($Xw + $Yw + $Zw)}return [$x,$y,$Y ]}sub xyY_to_XYZ {my ($xyy)=@_;my ($x,$y,$Y)=@{$xyy};my ($X,$Z);if (!($y==0)){$X=$x * $Y / $y;$Z=(1 - $x - $y)* $Y / $y}else {$X=0;$Y=0;$Z=0}return [$X,$Y,$Z ]}sub Lab_to_LCHab {my ($lab)=@_;my ($L,$a,$b)=@{$lab};my ($C,$H);$C=sqrt($a*$a + $b*$b);$H=atan2($b,$a);$H=rad2deg($H);return [$L,$C,$H ]}sub LCHab_to_Lab {my ($lch)=@_;my ($L,$C,$H)=@{$lch};my ($a,$b);$H=deg2rad($H);my$th=tan($H);$a=$C / sqrt($th * $th + 1);$b=sqrt($C*$C - $a*$a);if ($H < 0){$H=$H + 2*pi}if ($H > pi/2 && $H < 3*pi/2){$a= - $a}if ($H > pi){$b= - $b}return [$L,$a,$b ]}sub RGB_to_linear_RGB {my ($rgb,$space)=@_;my ($R,$G,$B)=@{$rgb};my$s=&_get_RGB_space_by_name($space);if ($s->{gamma}eq 'sRGB'){if (abs($R)<= 0.04045){$R=$R / 12.92}else {$R=&_apow(($R + 0.055)/ 1.055,2.4)}if (abs($G)<= 0.04045){$G=$G / 12.92}else {$G=&_apow(($G + 0.055)/ 1.055,2.4)}if (abs($B)<= 0.04045){$B=$B / 12.92}else {$B=&_apow(($B + 0.055)/ 1.055,2.4)}}else {$R=&_apow($R,$s->{gamma});$G=&_apow($G,$s->{gamma});$B=&_apow($B,$s->{gamma})}return [$R,$G,$B ]}sub linear_RGB_to_RGB {my ($rgb,$space)=@_;my ($R,$G,$B)=@{$rgb};my$s=&_get_RGB_space_by_name($space);if ($s->{gamma}eq 'sRGB'){if (abs($R)<= 0.0031308){$R=12.92 * $R}else {$R=1.055 * &_apow($R,1/2.4)- 0.055};if (abs($G)<= 0.0031308){$G=12.92 * $G}else {$G=1.055 * &_apow($G,1/2.4)- 0.055}if (abs($B)<= 0.0031308){$B=12.92 * $B}else {$B=1.055 * &_apow($B,1/2.4)- 0.055}}else {$R=&_apow($R,1/$s->{gamma});$G=&_apow($G,1/$s->{gamma});$B=&_apow($B,1/$s->{gamma})}return [$R,$G,$B ]}sub RGB_to_YIQ {my ($rgb)=@_;my$m=[[0.299,0.587,0.114 ],[0.59590059,-0.27455667,-0.32134392],[0.21153661,-0.52273617,0.31119955]];my$yiq=&_mult_m33_v3($m,$rgb);return$yiq}sub YIQ_to_RGB {my ($yiq)=@_;my$mstar=[[1.0,0.95598634,0.6208248 ],[1.0,-0.27201283,-0.64720424],[1.0,-1.1067402,1.7042305 ]];my$rgb=&_mult_m33_v3($mstar,$yiq);return$rgb}sub RGB_to_YUV {my ($rgb)=@_;my$m=[[0.299,0.587,0.114 ],[-0.14714119,-0.28886916,0.43601035 ],[0.61497538,-0.51496512,-0.10001026 ]];my$yuv=&_mult_m33_v3($m,$rgb);return$yuv}sub YUV_to_RGB {my ($yuv)=@_;my$mstar=[[1.0,0.0,1.139883 ],[1.0,-0.39464233,-0.58062185],[1.0,2.0320619,0.0 ]];my$rgb=&_mult_m33_v3($mstar,$yuv);return$rgb}sub RGB_to_YPbPr {my ($rgb)=@_;my$m=[[0.299,0.587,0.114 ],[-0.168736,-0.331264,0.5 ],[0.5,-0.418688,-0.081312]];my$ypbpr=&_mult_m33_v3($m,$rgb);return$ypbpr}sub YPbPr_to_RGB {my ($ypbpr)=@_;my$mstar=[[1.0,0.0,1.402 ],[1.0,-0.344136,-0.714136],[1.0,1.772,0.0 ]];my$rgb=&_mult_m33_v3($mstar,$ypbpr);return$rgb}sub RGB_to_YCbCr {my ($rgb)=@_;my$m=[[65.481,128.553,24.966],[-37.797,-74.203,112.0 ],[112.0,-93.786,-18.214]];my$ycbcr=&_add_v3(&_mult_m33_v3($m,$rgb),[16,128,128 ]);return$ycbcr}sub YCbCr_to_RGB {my ($ycbcr)=@_;my$mstar=[[0.00456621,0.0,0.00625893],[0.00456621,-0.00153632,-0.00318811],[0.00456621,0.00791071,0.0 ]];my$rgb=&_mult_m33_v3($mstar,&_add_v3($ycbcr,[-16,-128,-128]));return$rgb}sub RGB_to_PhotoYCC {my ($rgb)=@_;my$m=[[0.299,0.587,0.114 ],[-0.299,-0.587,0.866 ],[0.701,-0.587,-0.114 ]];my$ycc=&_add_v3([0,156,137],&_mult_m33_v3([[255/1.402,0,0],[0,111.40,0],[0,0,135.64]],&_mult_m33_v3($m,$rgb)));return$ycc}sub PhotoYCC_to_RGB {my ($ycc)=@_;my$mstar=[[1.0,0.0,1.0 ],[0.99603657,-0.19817126,-0.50936968],[1.0204082,1.0204082,0.0 ]];my$rgb=&_mult_m33_v3($mstar,&_mult_m33_v3([[1/(255/1.402),0,0],[0,1/111.40,0],[0,0,1/135.64]],&_add_v3([0,-156,-137],$ycc)));return$rgb}sub RGB_to_HSV {my ($rgb)=@_;my ($r,$g,$b)=@{$rgb};my ($h,$s,$v);my$min=&_min($r,$g,$b);my$max=&_max($r,$g,$b);$v=$max;my$delta=$max - $min;if($delta!=0){$s=$delta / $max}else {$s=0;$h=0;return [$h,$s,$v]}if($r==$max){$h=($g - $b)/ $delta}elsif ($g==$max){$h=2 + ($b - $r)/ $delta}else {$h=4 + ($r - $g)/ $delta}$h *= 60;if($h < 0){$h += 360}return [$h,$s,$v ]}sub HSV_to_RGB {my ($hsv)=@_;my ($h,$s,$v)=@{$hsv};my ($r,$g,$b);while ($h < 0){$h += 360}while ($h >= 360){$h -= 360}$h /= 60;my$i=POSIX::floor($h);my$f=$h - $i;my$p=$v * (1 - $s);my$q=$v * (1 - $s * $f);my$t=$v * (1 - $s * (1 - $f));if($i==0){$r=$v;$g=$t;$b=$p}elsif($i==1){$r=$q;$g=$v;$b=$p}elsif($i==2){$r=$p;$g=$v;$b=$t}elsif($i==3){$r=$p;$g=$q;$b=$v}elsif($i==4){$r=$t;$g=$p;$b=$v}else {$r=$v;$g=$p;$b=$q}return [$r,$g,$b ]}sub RGB_to_HSL {my ($rgb)=@_;my ($r,$g,$b)=@{$rgb};my ($h,$s,$v)=@{&RGB_to_HSV($rgb)};my$min=&_min($r,$g,$b);my$max=&_max($r,$g,$b);my$delta=$max - $min;my$l=($max+$min)/2.0;if($delta==0){return [0,0,$l]}else {if($l <= 0.5){$s=$delta/($max+$min)}else {$s=$delta/(2-$max-$min)}}return [$h,$s,$l]}sub HSL_to_RGB {my ($hsl)=@_;my ($h,$s,$l)=@{$hsl};my ($r,$g,$b);my ($p1,$p2);if($l <= 0.5){$p1=$l * (1-$s);$p2=2*$l - $p1}else {$p2=$l + $s - ($l*$s);$p1=2*$l - $p2}$r=&_rgbquant($p1,$p2,$h+120);$g=&_rgbquant($p1,$p2,$h);$b=&_rgbquant($p1,$p2,$h-120);return [$r,$g,$b ]}sub _rgbquant {my ($q1,$q2,$h)=@_;while ($h < 0){$h += 360}while ($h >= 360){$h -= 360}if ($h < 60){return ($q1 + (($q2-$q1)*$h/60))}elsif ($h < 180){return ($q2)}elsif ($h < 240){return ($q1 + (($q2-$q1)*(240-$h)/60))}else {return ($q1)}}sub RGB_to_CMY {my ($rgb)=@_;return [map {1 - $_}@{$rgb}]}sub CMY_to_RGB {my ($cmy)=@_;return [map {1 - $_}@{$cmy}]}sub CMY_to_CMYK {my ($cmy)=@_;my$k=&_min(@{$cmy});return [(map {$_-$k}@{$cmy}),$k ]}sub CMYK_to_CMY {my ($cmyk)=@_;my ($c,$m,$y,$k)=@{$cmyk};return [$c+$k,$m+$k,$y+$k ]}sub XYZ_change_white_point {my ($xyz,$xyz_old_white_point,$xyz_new_white_point)=@_;my$ma=[[0.8951,-0.7502,0.0389 ],[0.2664,1.7135,-0.0685 ],[-0.1614,0.0367,1.0296 ]];my$ma_star=[[0.986993,0.432305,-0.008529 ],[-0.147054,0.518360,0.040043 ],[0.159963,0.049291,0.968487 ]];my$cone_old=&_mult_v3_m33($xyz_old_white_point,$ma);my$cone_new=&_mult_v3_m33($xyz_new_white_point,$ma);my$q=[[$cone_new->[0]/$cone_old->[0],0,0 ],[0,$cone_new->[1]/$cone_old->[1],0 ],[0,0,$cone_new->[2]/$cone_old->[2]]];my$m=&_mult_m33_m33($ma,&_mult_m33_m33($q,$ma_star));my$xyz_new=&_mult_v3_m33($xyz,$m);return$xyz_new}sub white_point_from_temperature {my ($temp)=@_;my ($x,$y);if ($temp < 4000 || $temp > 25000){carp "color temperature out of range: $temp, should be between 4000 and 25000 Kelvin"}if ($temp <= 7000){$x=-4.6070e+9 / ($temp*$temp*$temp)+ 2.9678e+6 / ($temp*$temp)+ 0.09911e+3 / $temp + 0.244063}else {$x=-2.0064e+9 / ($temp*$temp*$temp)+ 1.9018e+6 / ($temp*$temp)+ 0.24748e+3 / $temp + 0.237040}$y=-3.0 * $x * $x + 2.87 * $x - 0.275;return [$x,$y ]}sub _get_RGB_space_by_name {my ($space)=@_;if (!defined$space){$space='sRGB'}elsif (!$RGB_SPACES{$space }){carp("rgb space not found: ".$space.", defaulting to sRGB");$space='sRGB'}my$s=$RGB_SPACES{$space};if ($s &&!ref$s){$s=$RGB_SPACES{$s}}return$s}sub _check_white_point {my ($white_point)=@_;if (!defined$white_point){$white_point='D65'}elsif ($white_point =~ m!^(\d+)K$!){my$temperature=$1;$WHITE_POINTS{$white_point }=&white_point_from_temperature($temperature)}elsif (!$WHITE_POINTS{$white_point }){carp("white point not found: ".$white_point.", defaulting to D65");$white_point='D65'}return$white_point}sub _mult_v3_m33 {my ($v,$m)=@_;my$vout=[($v->[0]* $m->[0]->[0]+ $v->[1]* $m->[1]->[0]+ $v->[2]* $m->[2]->[0]),($v->[0]* $m->[0]->[1]+ $v->[1]* $m->[1]->[1]+ $v->[2]* $m->[2]->[1]),($v->[0]* $m->[0]->[2]+ $v->[1]* $m->[1]->[2]+ $v->[2]* $m->[2]->[2])];return$vout}sub _mult_m33_v3 {my ($m,$v)=@_;my$vout=[($v->[0]* $m->[0]->[0]+ $v->[1]* $m->[0]->[1]+ $v->[2]* $m->[0]->[2]),($v->[0]* $m->[1]->[0]+ $v->[1]* $m->[1]->[1]+ $v->[2]* $m->[1]->[2]),($v->[0]* $m->[2]->[0]+ $v->[1]* $m->[2]->[1]+ $v->[2]* $m->[2]->[2])];return$vout}sub _mult_m33_m33 {my ($m,$n)=@_;my$q=[];for my$i (0..2){for my$j (0..2){for my$k (0..2){$q->[$i]->[$j]+= $m->[$i]->[$k]* $n->[$k]->[$j]}}}return$q}sub _add_v3 {my ($a,$b)=@_;my$c=[$a->[0]+ $b->[0],$a->[1]+ $b->[1],$a->[2]+ $b->[2]];return$c}sub _pow_v3 {my ($v3,$c)=@_;my$v3out=[pow($v3->[0],$c),pow($v3->[1],$c),pow($v3->[2],$c)];return$v3out}sub _delta_v3 {my ($a3,$b3)=@_;return (abs($a3->[0]- $b3->[0])+ abs($a3->[1]- $b3->[1])+ abs($a3->[2]- $b3->[2]))}sub _generic_clip {my ($v3,$c32)=@_;if ($v3->[0]< $c32->[0]->[0]){$v3->[0]=$c32->[0]->[0]}if ($v3->[0]> $c32->[0]->[1]){$v3->[0]=$c32->[0]->[1]}if ($v3->[1]< $c32->[1]->[0]){$v3->[1]=$c32->[1]->[0]}if ($v3->[1]> $c32->[1]->[1]){$v3->[1]=$c32->[1]->[1]}if ($v3->[2]< $c32->[2]->[0]){$v3->[2]=$c32->[2]->[0]}if ($v3->[2]> $c32->[2]->[1]){$v3->[2]=$c32->[2]->[1]}return$v3}sub _apow {my ($v,$p)=@_;return ($v >= 0 ? pow($v,$p): -pow(-$v,$p))}sub _sqr {my ($v)=@_;return$v*$v}sub _is_zero {my ($v)=@_;return (abs($v)< 0.000001)}sub _min {my$min=shift(@_);for my$v (@_){if ($v <= $min){$min=$v}};return$min}sub _max {my$max=shift(@_);for my$v (@_){if ($v >= $max){$max=$v}};return$max}our%RGB_SPACES=('Adobe'=>'Adobe RGB (1998)','Adobe RGB (1998)'=>{white_point=>'D65',gamma=>2.2,m=>[[0.5767001212121210,0.2973609999999999,0.0270328181818181 ],[0.1855557042253521,0.6273550000000000,0.0706878873239437 ],[0.1882125000000000,0.0752850000000000,0.9912525000000000 ]],mstar=>[[2.0414778828777158,-0.9692568708746859,0.0134454339800522 ],[-0.5649765261191881,1.8759931170154693,-0.1183725462165374 ],[-0.3447127732462102,0.0415556248231326,1.0152620834741313 ]],},'Apple'=>'Apple RGB','Apple RGB'=>{white_point=>'D65',gamma=>1.8,m=>[[0.4496948529411764,0.2446340000000000,0.0251829117647059 ],[0.3162512941176471,0.6720340000000000,0.1411836134453782 ],[0.1845208571428572,0.0833320000000000,0.9226042857142855 ]],mstar=>[[2.9517603398020569,-1.0851001264872848,0.0854802409232915 ],[-1.2895090072470441,1.9908397072633022,-0.2694550155056003 ],[-0.4738802866606785,0.0372022452865781,1.0911301341384845 ]],},'BestRGB'=>{white_point=>'D50',gamma=>2.2,m=>[[0.6326700260082926,0.2284570000000000,0.0000000000000000 ],[0.2045557161290322,0.7373519999999999,0.0095142193548387 ],[0.1269951428571429,0.0341910000000000,0.8156995714285713 ]],mstar=>[[1.7552588897490133,-0.5441338472581142,0.0063467101890703 ],[-0.4836782739368681,1.5068795234848715,-0.0175760572028268 ],[-0.2529998994965047,0.0215528345168675,1.2256901641540674 ]],},'Beta RGB'=>{white_point=>'D50',gamma=>2.2,m=>[[0.6712546349614399,0.3032730000000001,0.0000000000000001 ],[0.1745833659117997,0.6637859999999999,0.0407009558998808 ],[0.1183817187500000,0.0329410000000000,0.7845011448863635 ]],mstar=>[[1.6832246105012654,-0.7710229999344457,0.0400016919321019 ],[-0.4282356869228009,1.7065573340451357,-0.0885384492378917 ],[-0.2360181522709381,0.0446899574535591,1.2723768250932299 ]],},'BruceRGB'=>{white_point=>'D65',gamma=>2.2,m=>[[0.4673842424242424,0.2409950000000000,0.0219086363636363 ],[0.2944540307692308,0.6835539999999999,0.0736135076923076 ],[0.1886300000000000,0.0754520000000000,0.9934513333333335 ]],mstar=>[[2.7456543761403882,-0.9692568108426551,0.0112706581772173 ],[-1.1358911781912031,1.8759930008236942,-0.1139588771251973 ],[-0.4350565642146659,0.0415556222493375,1.0131069405965349 ]],},'CIE'=>{white_point=>'E',gamma=>2.2,m=>[[0.4887167547169811,0.1762040000000000,0.0000000000000000 ],[0.3106804602510461,0.8129850000000002,0.0102048326359833 ],[0.2006041111111111,0.0108110000000000,0.9898071111111111 ]],mstar=>[[2.3706802022946527,-0.5138847730830187,0.0052981111618865 ],[-0.9000427625776859,1.4253030498717687,-0.0146947611471193 ],[-0.4706349622815629,0.0885813466699250,1.0093845871252884 ]],},'ColorMatch'=>{white_point=>'D50',gamma=>1.8,m=>[[0.5093438823529410,0.2748840000000000,0.0242544705882353 ],[0.3209073388429752,0.6581320000000002,0.1087821487603307 ],[0.1339700000000000,0.0669850000000000,0.6921783333333333 ]],mstar=>[[2.6422872594587332,-1.1119754096457255,0.0821692807629542 ],[-1.2234269646206919,2.0590166676215107,-0.2807234418494614 ],[-0.3930142794480749,0.0159613695164458,1.4559774449385248 ]],},'DonRGB4'=>{white_point=>'D50',gamma=>2.2,m=>[[0.6457719999999998,0.2783499999999999,0.0037113333333334 ],[0.1933510457516340,0.6879700000000001,0.0179861437908497 ],[0.1250971428571429,0.0336800000000000,0.8035085714285716 ]],mstar=>[[1.7603878846606116,-0.7126289975811030,0.0078207770365325 ],[-0.4881191497764036,1.6527436537605511,-0.0347412748629646 ],[-0.2536122811541382,0.0416715470705678,1.2447804103656714 ]],},'ECI'=>{white_point=>'D50',gamma=>1.8,m=>[[0.6502045454545454,0.3202500000000000,-0.0000000000000001 ],[0.1780773380281691,0.6020710000000000,0.0678389859154930 ],[0.1359382500000000,0.0776790000000000,0.7573702500000002 ]],mstar=>[[1.7827609790470664,-0.9593624312689213,0.0859317810050046 ],[-0.4969845184555761,1.9477964513641737,-0.1744675553737970 ],[-0.2690099687053119,-0.0275807381172883,1.3228286288043098 ]],},'Ekta Space PS5'=>{white_point=>'D50',gamma=>2.2,m=>[[0.5938923114754098,0.2606289999999999,0.0000000000000000 ],[0.2729799428571429,0.7349460000000001,0.0419969142857143 ],[0.0973500000000000,0.0044250000000000,0.7832250000000001 ]],mstar=>[[2.0043787360968186,-0.7110290170493107,0.0381257297502959 ],[-0.7304832564783660,1.6202136618008882,-0.0868766628736253 ],[-0.2450047962579189,0.0792227384931296,1.2725243569115190 ]],},'601'=>'NTSC','CIE Rec 601'=>'NTSC','NTSC'=>{white_point=>'C',gamma=>2.2,m=>[[0.6067337272727271,0.2988389999999999,-0.0000000000000001 ],[0.1735638169014085,0.5868110000000000,0.0661195492957747 ],[0.2001125000000000,0.1143500000000000,1.1149125000000002 ]],mstar=>[[1.9104909450902432,-0.9843106185066585,0.0583742441336926 ],[-0.5325921048972800,1.9984488315135187,-0.1185174047562849 ],[-0.2882837998985277,-0.0282979742694222,0.8986095763610844 ]],},'CIE ITU'=>'PAL/SECAM','PAL'=>'PAL/SECAM','PAL/SECAM'=>{white_point=>'D65',gamma=>2.2,m=>[[0.4305861818181819,0.2220210000000001,0.0201837272727273 ],[0.3415450833333333,0.7066450000000000,0.1295515833333333 ],[0.1783350000000000,0.0713340000000000,0.9392309999999999 ]],mstar=>[[3.0631308078036081,-0.9692570313532748,0.0678676345258901 ],[-1.3932854294802033,1.8759934276211896,-0.2288214781555966 ],[-0.4757879688629482,0.0415556317034429,1.0691933898259074 ]],},'ProPhoto'=>{white_point=>'D50',gamma=>1.8,m=>[[0.7976742857142858,0.2880400000000000,0.0000000000000000 ],[0.1351916830080914,0.7118740000000000,0.0000000000000000 ],[0.0314760000000000,0.0000860000000000,0.8284380000000000 ]],mstar=>[[1.3459444124134017,-0.5445989438461810,-0.0000000000000000 ],[-0.2556077203964527,1.5081675237232912,-0.0000000000000000 ],[-0.0511118080787822,0.0205351443915685,1.2070909349884964 ]],},'SMPTE'=>'SMPTE-C','SMPTE-C'=>{white_point=>'D65',gamma=>2.2,m=>[[0.3935554411764707,0.2123950000000001,0.0187407352941176 ],[0.3652524201680672,0.7010489999999999,0.1119321932773109 ],[0.1916597142857142,0.0865560000000000,0.9582985714285710 ]],mstar=>[[3.5056956039694129,-1.0690641158576772,0.0563116543373650 ],[-1.7396380462846184,1.9778095119692913,-0.1969933651732733 ],[-0.5440105230649496,0.0351719640259221,1.0500467308790999 ]],},'709'=>'sRGB','CIE Rec 709'=>'sRGB','sRGB'=>{white_point=>'D65',gamma=>'sRGB',m=>[[0.4124237575757575,0.2126560000000000,0.0193323636363636 ],[0.3575789999999999,0.7151579999999998,0.1191930000000000 ],[0.1804650000000000,0.0721860000000000,0.9504490000000001 ]],mstar=>[[3.2407109439941704,-0.9692581090654827,0.0556349466243886 ],[-1.5372603195869781,1.8759955135292130,-0.2039948042894247 ],[-0.4985709144606416,0.0415556779089489,1.0570639858633826 ]],},'WideGamut'=>{white_point=>'D50',gamma=>2.2,m=>[[0.7161035660377360,0.2581870000000001,0.0000000000000000 ],[0.1009296246973366,0.7249380000000000,0.0517812857142858 ],[0.1471875000000000,0.0168750000000000,0.7734375000000001 ]],mstar=>[[1.4628087611158722,-0.5217931929785991,0.0349338148323482 ],[-0.1840625990709008,1.4472377239217746,-0.0968919015161355 ],[-0.2743610287417160,0.0677227300206644,1.2883952872306403 ]],});our%WHITE_POINTS=('A'=>[0.44757,0.40745 ],'D50'=>[0.34567,0.35850 ],'B'=>[0.34842,0.35161 ],'D55'=>[0.33242,0.34743 ],'E'=>[0.333333,0.333333 ],'D65'=>[0.312713,0.329016 ],'C'=>[0.310063,0.316158 ],'D75'=>[0.29902,0.31485 ],'D93'=>[0.28480,0.29320 ],'F2'=>[0.37207,0.37512 ],'F7'=>[0.31285,0.32918 ],'F11'=>[0.38054,0.37691 ],);sub RGBtoHSV {my (@c)=@_;return @{&RGB_to_HSV([@c])}}sub HSVtoRGB {my (@c)=@_;return @{&HSV_to_RGB([@c])}}sub RGBtoHSL {my (@c)=@_;return @{&RGB_to_HSL([@c])}}sub RGBquant {my (@c)=@_;return&_rgbquant(@c)}sub HSLtoRGB {my (@c)=@_;return @{&HSL_to_RGB([@c])}}sub newRGB {my ($p,@c)=@_;return&new_RGB($p,[@c],space=>'NTSC')}sub newHSV {my ($p,@c)=@_;return&new_HSV($p,[@c],space=>'NTSC')}sub newHSL {my ($p,@c)=@_;return&new_HSL($p,[@c],space=>'NTSC')}sub newGrey {my ($p,@c)=@_;return&new_YPbPr($p,[$c[0],0.0,0.0],space=>'NTSC')}sub asRGB {my ($this)=@_;return @{$this->as_RGB()}}sub asHSV {my ($this)=@_;return @{$this->as_HSV()}}sub asHSL {my ($this)=@_;return @{$this->as_HSL()}}sub asGrey {my ($this)=@_;return$this->as_YPbPr()->[0]}sub asGrey2 {my ($this)=@_;return$this->asGrey()}sub asLum {my ($this)=@_;return$this->as_HSL()->[2]}sub asCMY {my ($this)=@_;return @{$this->as_CMY()}}sub asCMYK {my ($this)=@_;return @{$this->as_CMYK()}}sub asCMYK2 {my ($this)=@_;return @{$this->as_CMYK()}}sub asCMYK3 {my ($this)=@_;return (map {$_*0.75}@{$this->as_CMYK()})}sub asHex {my ($this)=@_;return '#'.$this->as_RGBhex()}sub asHexCMYK {my ($this)=@_;return sprintf('%%%02X%02X%02X%02X',map {$_*255}$this->asCMYK())}sub asHexHSV {my ($this)=@_;return sprintf('!%02X%02X%02X',map {$_*255}$this->asHSV())}sub setRGB {my ($this,@c)=@_;%{$this}=%{&newRGB(ref$this,@c)}}sub setHSV {my ($this,@c)=@_;%{$this}=%{&newHSV(ref$this,@c)}}sub setHSL {my ($this,@c)=@_;%{$this}=%{&newHSL(ref$this,@c)}}sub setGrey {my ($this,@c)=@_;%{$this}=%{&newGrey(ref$this,@c)}}sub setHex {my ($this,@c)=@_;%{$this}=%{&new(ref$this,@c)}}sub addSaturation {my ($this,$s2)=@_;my ($h,$s,$v)=$this->asHSV;$this->setHSV($h,$s+$s2,$v)}sub setSaturation {my ($this,$s2)=@_;my ($h,$s,$v)=$this->asHSV;$this->setHSV($h,$s2,$v)}sub rotHue {my ($this,$h2)=@_;my ($h,$s,$v)=$this->asHSV;$h+=$h2;$h%=360;$this->setHSV($h,$s,$v)}sub setHue {my ($this,$h2)=@_;my ($h,$s,$v)=$this->asHSV;$this->setHSV($h2,$s,$v)}sub addBrightness {my ($this,$v2)=@_;my ($h,$s,$v)=$this->asHSV;$this->setHSV($h,$s,$v+$v2)}sub setBrightness {my ($this,$v2)=@_;my ($h,$s,$v)=$this->asHSV;$this->setHSV($h,$s,$v2)}sub addLightness {my ($this,$l2)=@_;my ($h,$s,$l)=$this->asHSL;$this->setHSL($h,$s,$l+$l2)}sub setLightness {my ($this,$l2)=@_;my ($h,$s,$l)=$this->asHSL;$this->setHSL($h,$s,$l2)}use Graphics::ColorNames;our%COLORNAMES;tie%COLORNAMES,'Graphics::ColorNames',qw(HTML Windows Netscape X);sub namecolor {my$name=lc(shift @_);$name=~s/[^\#!%\&a-z0-9]//g;my$col;my$opt=shift @_;if($name=~/^#/){my ($r,$g,$b,$h);if(length($name)<5){$r=hex(substr($name,1,1))/0xf;$g=hex(substr($name,2,1))/0xf;$b=hex(substr($name,3,1))/0xf}elsif(length($name)<8){$r=hex(substr($name,1,2))/0xff;$g=hex(substr($name,3,2))/0xff;$b=hex(substr($name,5,2))/0xff}elsif(length($name)<11){$r=hex(substr($name,1,3))/0xfff;$g=hex(substr($name,4,3))/0xfff;$b=hex(substr($name,7,3))/0xfff}else {$r=hex(substr($name,1,4))/0xffff;$g=hex(substr($name,5,4))/0xffff;$b=hex(substr($name,9,4))/0xffff}$col=[$r,$g,$b]}elsif($name=~/^%/){my ($r,$g,$b,$c,$y,$m,$k);if(length($name)<6){$c=hex(substr($name,1,1))/0xf;$m=hex(substr($name,2,1))/0xf;$y=hex(substr($name,3,1))/0xf;$k=hex(substr($name,4,1))/0xf}elsif(length($name)<10){$c=hex(substr($name,1,2))/0xff;$m=hex(substr($name,3,2))/0xff;$y=hex(substr($name,5,2))/0xff;$k=hex(substr($name,7,2))/0xff}elsif(length($name)<14){$c=hex(substr($name,1,3))/0xfff;$m=hex(substr($name,4,3))/0xfff;$y=hex(substr($name,7,3))/0xfff;$k=hex(substr($name,10,3))/0xfff}else {$c=hex(substr($name,1,4))/0xffff;$m=hex(substr($name,5,4))/0xffff;$y=hex(substr($name,9,4))/0xffff;$k=hex(substr($name,13,4))/0xffff}if($opt){$r=1-$c-$k;$g=1-$m-$k;$b=1-$y-$k;$col=[$r,$g,$b]}else {$r=1-$c-$k;$g=1-$m-$k;$b=1-$y-$k;$col=[$r,$g,$b]}}elsif($name=~/^!/){my ($r,$g,$b,$h,$s,$v);if(length($name)<5){$h=360*hex(substr($name,1,1))/0xf;$s=hex(substr($name,2,1))/0xf;$v=hex(substr($name,3,1))/0xf}elsif(length($name)<8){$h=360*hex(substr($name,1,2))/0xff;$s=hex(substr($name,3,2))/0xff;$v=hex(substr($name,5,2))/0xff}elsif(length($name)<11){$h=360*hex(substr($name,1,3))/0xfff;$s=hex(substr($name,4,3))/0xfff;$v=hex(substr($name,7,3))/0xfff}else {$h=360*hex(substr($name,1,4))/0xffff;$s=hex(substr($name,5,4))/0xffff;$v=hex(substr($name,9,4))/0xffff}if($opt){($r,$g,$b)=HSVtoRGB($h,$s,$v);$col=[$r,$g,$b]}else {($r,$g,$b)=HSVtoRGB($h,$s,$v);$col=[$r,$g,$b]}}elsif($name=~/^&/){my ($r,$g,$b,$h,$s,$l);if(length($name)<5){$h=360*hex(substr($name,1,1))/0xf;$s=hex(substr($name,2,1))/0xf;$l=hex(substr($name,3,1))/0xf}elsif(length($name)<8){$h=360*hex(substr($name,1,2))/0xff;$s=hex(substr($name,3,2))/0xff;$l=hex(substr($name,5,2))/0xff}elsif(length($name)<11){$h=360*hex(substr($name,1,3))/0xfff;$s=hex(substr($name,4,3))/0xfff;$l=hex(substr($name,7,3))/0xfff}else {$h=360*hex(substr($name,1,4))/0xffff;$s=hex(substr($name,5,4))/0xffff;$l=hex(substr($name,9,4))/0xffff}if($opt){($r,$g,$b)=HSLtoRGB($h,$s,$l);$col=[$r,$g,$b]}else {($r,$g,$b)=HSLtoRGB($h,$s,$l);$col=[$r,$g,$b]}}else {if ($COLORNAMES{$name}){my ($r,$g,$b)=&Graphics::ColorNames::hex2tuple($COLORNAMES{$name});($r,$g,$b)=map {$_/0xff}($r,$g,$b);$col=[$r,$g,$b]}else {return undef}}return$col}1;
GRAPHICS_COLOROBJECT

$fatpacked{"IO/Multiplex.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IO_MULTIPLEX';
  package IO::Multiplex;use strict;use warnings;our$VERSION='1.16';use POSIX qw(errno_h BUFSIZ);use Socket;use FileHandle qw(autoflush);use IO::Handle;use Fcntl;use Carp qw(carp);use constant IsWin=>($^O eq 'MSWin32');BEGIN {eval {require Time::HiRes;Time::HiRes->import('time')}}$SIG{PIPE}='IGNORE';{no warnings;if(IsWin){*EWOULDBLOCK=sub() {10035}}}sub new {my$package=shift;my$self=bless {_readers=>'',_writers=>'',_fhs=>{},_handles=>{},_timerkeys=>{},_timers=>[],_listen=>{}}=>$package;return$self}sub listen {my$self=shift;my$fh=shift;$self->add($fh);$self->{_fhs}{"$fh"}{listen}=1;$fh}sub add {my$self=shift;my$fh=shift;return if$self->{_fhs}{"$fh"};nonblock($fh);autoflush($fh,1);fd_set($self->{_readers},$fh,1);my$sockopt=getsockopt$fh,SOL_SOCKET,SO_TYPE;$self->{_fhs}{"$fh"}{udp_true}=1 if defined$sockopt && SOCK_DGRAM==unpack "i",$sockopt;$self->{_fhs}{"$fh"}{inbuffer}='';$self->{_fhs}{"$fh"}{outbuffer}='';$self->{_fhs}{"$fh"}{fileno}=fileno($fh);$self->{_handles}{"$fh"}=$fh;tie *$fh,"IO::Multiplex::Handle",$self,$fh;return$fh}sub remove {my$self=shift;my$fh=shift;fd_set($self->{_writers},$fh,0);fd_set($self->{_readers},$fh,0);delete$self->{_fhs}{"$fh"};delete$self->{_handles}{"$fh"};$self->_removeTimer($fh);untie *$fh;return 1}sub set_callback_object {my$self=shift;my$obj=shift;my$fh=shift;return if$fh &&!exists($self->{_fhs}{"$fh"});my$old=$fh ? $self->{_fhs}{"$fh"}{object}: $self->{_object};$fh ? $self->{_fhs}{"$fh"}{object}: $self->{_object}=$obj;return$old}sub kill_output {my$self=shift;my$fh=shift;return unless$fh && exists($self->{_fhs}{"$fh"});$self->{_fhs}{"$fh"}{outbuffer}='';fd_set($self->{_writers},$fh,0)}sub outbuffer {my$self=shift;my$fh=shift;return unless$fh && exists($self->{_fhs}{"$fh"});if (@_){$self->{_fhs}{"$fh"}{outbuffer}=$_[0]if @_;fd_set($self->{_writers},$fh,0)if!$_[0]}$self->{_fhs}{"$fh"}{outbuffer}}sub inbuffer {my$self=shift;my$fh=shift;return unless$fh && exists($self->{_fhs}{"$fh"});if (@_){$self->{_fhs}{"$fh"}{inbuffer}=$_[0]if @_}return$self->{_fhs}{"$fh"}{inbuffer}}sub set_timeout {my$self=shift;my$fh=shift;my$timeout=shift;return unless$fh && exists($self->{_fhs}{"$fh"});if (defined$timeout){$self->_addTimer($fh,$timeout + time)}else {$self->_removeTimer($fh)}}sub handles {my$self=shift;return grep(!$self->{_fhs}{"$_"}{listen},values %{$self->{_handles}})}sub _addTimer {my$self=shift;my$fh=shift;my$time=shift;$self->{_timerkeys}{"$fh"}=1;@{$self->{_timers}}=sort {$a->[1]<=> $b->[1]}(@{$self->{_timers}},[$fh,$time ])}sub _removeTimer {my$self=shift;my$fh=shift;return unless exists$self->{_timerkeys}{"$fh"};@{$self->{_timers}}=grep {$_->[0]ne $fh}@{$self->{_timers}};delete$self->{_timerkeys}{"$fh"}}sub loop {my$self=shift;my$heartbeat=shift;$self->{_endloop}=0;while (!$self->{_endloop}&& keys %{$self->{_fhs}}){my$rv;my$data;my$rdready="";my$wrready="";my$timeout=undef;for my$fh (values %{$self->{_handles}}){fd_set($rdready,$fh,1)if ref($fh)=~ /SSL/ && $fh->can("pending")&& $fh->pending}if (!length$rdready){if (@{$self->{_timers}}){$timeout=$self->{_timers}[0][1]- time}my$numready=select($rdready=$self->{_readers},$wrready=$self->{_writers},undef,$timeout);unless(defined($numready)){if ($!==EINTR || $!==EAGAIN){next}else {last}}}&{$heartbeat}($rdready,$wrready)if$heartbeat;for my$k (keys %{$self->{_handles}}){my$fh=$self->{_handles}->{$k}or next;next unless exists$self->{_fhs}{"$fh"};my$obj=$self->{_fhs}{"$fh"}{object}|| $self->{_object};if (fd_isset($rdready,$fh)){if ($self->{_fhs}{"$fh"}{listen}){my$client=$fh->accept;next unless ($client);$self->add($client);$obj->mux_connection($self,$client)if$obj && $obj->can("mux_connection")}else {if ($self->is_udp($fh)){$rv=recv($fh,$data,BUFSIZ,0);if (defined$rv){$self->{_fhs}{"$fh"}{udp_peer}=$rv}}else {$rv=&POSIX::read(fileno($fh),$data,BUFSIZ)}if (defined($rv)&& length($data)){$self->{_fhs}{"$fh"}{inbuffer}.= $data;$obj->mux_input($self,$fh,\$self->{_fhs}{"$fh"}{inbuffer})if$obj && $obj->can("mux_input")}else {unless (defined$rv){next if $!==EINTR || $!==EAGAIN || $!==EWOULDBLOCK;warn "IO::Multiplex read error: $!" if $!!=ECONNRESET}fd_set($self->{_readers},$fh,0);$obj->mux_eof($self,$fh,\$self->{_fhs}{"$fh"}{inbuffer})if$obj && $obj->can("mux_eof");if (exists$self->{_fhs}{"$fh"}){$self->{_fhs}{"$fh"}{inbuffer}='';$self->close($fh)unless exists$self->{_fhs}{"$fh"}&& length$self->{_fhs}{"$fh"}{outbuffer}}next}}}next unless exists$self->{_fhs}{"$fh"};if (fd_isset($wrready,$fh)){unless (length$self->{_fhs}{"$fh"}{outbuffer}){fd_set($self->{_writers},$fh,0);$obj->mux_outbuffer_empty($self,$fh)if ($obj && $obj->can("mux_outbuffer_empty"));next}$rv=&POSIX::write(fileno($fh),$self->{_fhs}{"$fh"}{outbuffer},length($self->{_fhs}{"$fh"}{outbuffer}));unless (defined($rv)){unless ($!==EWOULDBLOCK || $!==EINTR || $!==EAGAIN){if ($!==EPIPE){$obj->mux_epipe($self,$fh)if$obj && $obj->can("mux_epipe")}else {warn "IO::Multiplex: write error: $!\n"}$self->close($fh)}next}substr($self->{_fhs}{"$fh"}{outbuffer},0,$rv)='';unless (length$self->{_fhs}{"$fh"}{outbuffer}){fd_set($self->{_writers},$fh,0);$obj->mux_outbuffer_empty($self,$fh)if ($obj && $obj->can("mux_outbuffer_empty"));if ($self->{_fhs}{"$fh"}&& $self->{_fhs}{"$fh"}{shutdown}){shutdown($fh,1);$self->{_fhs}{"$fh"}{outbuffer}='';unless (length$self->{_fhs}{"$fh"}{inbuffer}){$self->close($fh);next}}}}next unless exists$self->{_fhs}{"$fh"}}$self->_checkTimeouts()if @{$self->{_timers}}}}sub _checkTimeouts {my$self=shift;my$time=time;my@timers=();for my$timer (@{$self->{_timers}}){last if$timer->[1]> $time;push@timers,$timer}for my$timer (@timers){my$fh=$timer->[0];$self->_removeTimer($fh);next unless exists$self->{_fhs}{"$fh"};my$obj=$self->{_fhs}{"$fh"}{object}|| $self->{_object};$obj->mux_timeout($self,$fh)if$obj && $obj->can("mux_timeout")}}sub endloop {my$self=shift;$self->{_endloop}=1}sub udp_peer {my$self=shift;my$fh=shift;return$self->{_fhs}{"$fh"}{udp_peer}}sub is_udp {my$self=shift;my$fh=shift;return$self->{_fhs}{"$fh"}{udp_true}}sub write {my$self=shift;my$fh=shift;my$data=shift;return unless$fh && exists($self->{_fhs}{"$fh"});if ($self->{_fhs}{"$fh"}{shutdown}){$!=EPIPE;return undef}if ($self->is_udp($fh)){if (my$udp_peer=$self->udp_peer($fh)){return send($fh,$data,0,$udp_peer)}else {return send($fh,$data,0)}}$self->{_fhs}{"$fh"}{outbuffer}.= $data;fd_set($self->{_writers},$fh,1);return length($data)}sub shutdown {my$self=shift;my$fh=shift;my$which=shift;return unless$fh && exists($self->{_fhs}{"$fh"});if ($which==0 || $which==2){shutdown($fh,0)}if ($which==1 || $which==2){if(length$self->{_fhs}{"$fh"}{outbuffer}){$self->{_fhs}{"$fh"}{shutdown}=1}else {shutdown($fh,1);$self->{_fhs}{"$fh"}{outbuffer}=''}}unless (length$self->{_fhs}{"$fh"}{inbuffer}|| length$self->{_fhs}{"$fh"}{outbuffer}){$self->close($fh)}}sub close {my$self=shift;my$fh=shift;return unless exists$self->{_fhs}{"$fh"};my$obj=$self->{_fhs}{"$fh"}{object}|| $self->{_object};warn "closing with read buffer" if length$self->{_fhs}{"$fh"}{inbuffer};warn "closing with write buffer" if length$self->{_fhs}{"$fh"}{outbuffer};fd_set($self->{_readers},$fh,0);fd_set($self->{_writers},$fh,0);delete$self->{_fhs}{"$fh"};delete$self->{_handles}{"$fh"};untie *$fh;close$fh;$obj->mux_close($self,$fh)if$obj && $obj->can("mux_close")}sub nonblock {my$fh=shift;if(IsWin){ioctl($fh,0x8004667e,pack("L!",1))}else {my$flags=fcntl($fh,F_GETFL,0)or die "fcntl F_GETFL: $!\n";fcntl($fh,F_SETFL,$flags | O_NONBLOCK)or die "fcntl F_SETFL $!\n"}}sub fd_set {vec($_[0],fileno($_[1]),1)=$_[2]}sub fd_isset {return vec($_[0],fileno($_[1]),1)}package IO::Multiplex::Handle;use strict;use Tie::Handle;use Carp;use vars qw(@ISA);@ISA=qw(Tie::Handle);sub FILENO {my$self=shift;return ($self->{_mux}->{_fhs}->{"$self->{_fh}"}->{fileno})}sub TIEHANDLE {my$package=shift;my$mux=shift;my$fh=shift;my$self=bless {_mux=>$mux,_fh=>$fh }=>$package;return$self}sub WRITE {my$self=shift;my ($msg,$len,$offset)=@_;$offset ||=0;return$self->{_mux}->write($self->{_fh},substr($msg,$offset,$len))}sub CLOSE {my$self=shift;return$self->{_mux}->shutdown($self->{_fh},2)}sub READ {carp "Do not read from a muxed file handle"}sub READLINE {carp "Do not read from a muxed file handle"}sub FETCH {return "Fnord"}sub UNTIE {}1;
IO_MULTIPLEX

$fatpacked{"IP/Anonymous.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IP_ANONYMOUS';
  package IP::Anonymous;$VERSION='0.04';require 5.001;use strict;use warnings;use vars qw($VERSION);use Carp;use Socket;use Crypt::XXTEA_PP;my$m_pad;my$ecb;my$first4bytes_pad;sub new {my$package=shift;my@key=@_;my$m_key;$m_key=pack("C16",@key[0..15]);$m_pad=pack("C16",@key[16..31]);$ecb=new Crypt::XXTEA_PP$m_key;$m_pad=$ecb->encrypt($m_pad);$first4bytes_pad=unpack("N",$m_pad);return bless({},$package)}sub anonymize {my$package=shift;my$address=shift;my$first4bytes_input;my@rin_input=();my$rin_output;my$result=0;if($address !~ /^\d{1,3}(?:\.\d{1,3}){3}$/){croak("ERROR [".__LINE__."]: invalid IP address format\n");return}$address=unpack("N",pack("C4",split /\./,$address));@rin_input=unpack("C16",$m_pad);$rin_input[0]=($first4bytes_pad >> 24);$rin_input[1]=(($first4bytes_pad << 8 & 0xffffffff)>> 24);$rin_input[2]=(($first4bytes_pad << 16 & 0xffffffff)>> 24);$rin_input[3]=(($first4bytes_pad << 24 & 0xffffffff)>> 24);$rin_output=unpack("C",$ecb->encrypt(pack("C16",@rin_input)));$result |=($rin_output >> 7)<< 31;for (my$position=1;$position <= 31;$position++){$first4bytes_input=(($address >> (32-$position))<< (32-$position))| (($first4bytes_pad << $position & 0xffffffff)>> $position);$rin_input[0]=($first4bytes_input >> 24);$rin_input[1]=(($first4bytes_input << 8 & 0xffffffff)>> 24);$rin_input[2]=(($first4bytes_input << 16 & 0xffffffff)>> 24);$rin_input[3]=(($first4bytes_input << 24 & 0xffffffff)>> 24);$rin_output=unpack("C",$ecb->encrypt(pack("C16",@rin_input)));$result |=($rin_output >> 7)<< (31-$position)}return inet_ntoa(pack("N",$result ^ $address))}1;
IP_ANONYMOUS

$fatpacked{"IPC/Run.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IPC_RUN';
  package IPC::Run;use bytes;use strict;use Exporter ();use vars qw{$VERSION @ISA @FILTER_IMP @FILTERS @API @EXPORT_OK %EXPORT_TAGS};BEGIN {$VERSION='0.94';@ISA=qw{Exporter};@FILTER_IMP=qw(input_avail get_more_input);@FILTERS=qw(new_appender new_chunker new_string_source new_string_sink);@API=qw(run harness start pump pumpable finish signal kill_kill reap_nb io timer timeout close_terminal binary);@EXPORT_OK=(@API,@FILTER_IMP,@FILTERS,qw(Win32_MODE));%EXPORT_TAGS=('filter_imp'=>\@FILTER_IMP,'all'=>\@EXPORT_OK,'filters'=>\@FILTERS,'api'=>\@API,)}use strict;use IPC::Run::Debug;use Exporter;use Fcntl;use POSIX ();BEGIN {if ($] < 5.008){require Symbol}}use Carp;use File::Spec ();use IO::Handle;require IPC::Run::IO;require IPC::Run::Timer;use UNIVERSAL ();use constant Win32_MODE=>$^O =~ /os2|Win32/i;BEGIN {if (Win32_MODE){eval "use IPC::Run::Win32Helper; 1;" or ($@ && die)or die "$!"}else {eval "use File::Basename; 1;" or die $!}}sub input_avail();sub get_more_input();use vars qw($_EIO $_EAGAIN);use Errno qw(EIO EAGAIN);BEGIN {local $!;$!=EIO;$_EIO=qr/^$!/;$!=EAGAIN;$_EAGAIN=qr/^$!/}sub _newed() {0}sub _harnessed(){1}sub _finished() {2}sub _started() {3}my%fds;use vars qw($cur_self);sub _debug_fd {return fileno STDERR unless defined$cur_self;if (_debugging &&!defined$cur_self->{DEBUG_FD}){my$fd=select STDERR;$|=1;select$fd;$cur_self->{DEBUG_FD}=POSIX::dup fileno STDERR;_debug("debugging fd is $cur_self->{DEBUG_FD}\n")if _debugging_details}return fileno STDERR unless defined$cur_self->{DEBUG_FD};return$cur_self->{DEBUG_FD}}sub DESTROY {my IPC::Run$self=shift;POSIX::close$self->{DEBUG_FD}if defined$self->{DEBUG_FD};$self->{DEBUG_FD}=undef}my%cmd_cache;sub _search_path {my ($cmd_name)=@_;if (File::Spec->file_name_is_absolute($cmd_name)&& -x $cmd_name){_debug "'",$cmd_name,"' is absolute" if _debugging_details;return$cmd_name}my$dirsep=(Win32_MODE ? '[/\\\\]' : $^O =~ /MacOS/ ? ':' : $^O =~ /VMS/ ? '[\[\]]' : '/');if (Win32_MODE && ($cmd_name =~ /$dirsep/)&& ($cmd_name !~ m!\.[^\\/\.]+$!)){_debug "no extension(.exe), checking ENV{PATHEXT}" if _debugging;for (split /;/,$ENV{PATHEXT}|| ".COM;.BAT;.EXE"){my$name="$cmd_name$_";$cmd_name=$name,last if -f $name && -x _}_debug "cmd_name is now '$cmd_name'" if _debugging}if ($cmd_name =~ /($dirsep)/){_debug "'$cmd_name' contains '$1'" if _debugging;croak "file not found: $cmd_name" unless -e $cmd_name;croak "not a file: $cmd_name" unless -f $cmd_name;croak "permission denied: $cmd_name" unless -x $cmd_name;return$cmd_name}if (exists$cmd_cache{$cmd_name}){_debug "'$cmd_name' found in cache: '$cmd_cache{$cmd_name}'" if _debugging;return$cmd_cache{$cmd_name}if -x $cmd_cache{$cmd_name};_debug "'$cmd_cache{$cmd_name}' no longer executable, searching..." if _debugging;delete$cmd_cache{$cmd_name}}my@searched_in;my$re=Win32_MODE ? qr/;/ : qr/:/;LOOP: for (split($re,$ENV{PATH}|| '',-1)){$_="." unless length $_;push@searched_in,$_;my$prospect=File::Spec->catfile($_,$cmd_name);my@prospects;@prospects=(Win32_MODE &&!(-f $prospect && -x _))? map "$prospect$_",split /;/,$ENV{PATHEXT}|| ".COM;.BAT;.EXE" : ($prospect);for my$found (@prospects){if (-f $found && -x _){$cmd_cache{$cmd_name}=$found;last LOOP}}}if (exists$cmd_cache{$cmd_name}){_debug "'",$cmd_name,"' added to cache: '",$cmd_cache{$cmd_name},"'" if _debugging_details;return$cmd_cache{$cmd_name}}croak "Command '$cmd_name' not found in " .join(", ",@searched_in)}sub _empty($) {!(defined $_[0]&& length $_[0])}sub _close {confess 'undef' unless defined $_[0];my$fd=$_[0]=~ /^\d+$/ ? $_[0]: fileno $_[0];my$r=POSIX::close$fd;$r=$r ? '' : " ERROR $!";delete$fds{$fd};_debug "close( $fd ) = " .($r || 0)if _debugging_details}sub _dup {confess 'undef' unless defined $_[0];my$r=POSIX::dup($_[0]);croak "$!: dup( $_[0] )" unless defined$r;$r=0 if$r eq '0 but true';_debug "dup( $_[0] ) = $r" if _debugging_details;$fds{$r}=1;return$r}sub _dup2_rudely {confess 'undef' unless defined $_[0]&& defined $_[1];my$r=POSIX::dup2($_[0],$_[1]);croak "$!: dup2( $_[0], $_[1] )" unless defined$r;$r=0 if$r eq '0 but true';_debug "dup2( $_[0], $_[1] ) = $r" if _debugging_details;$fds{$r}=1;return$r}sub _exec {confess 'undef passed' if grep!defined,@_;_debug 'exec()ing ',join " ",map "'$_'",@_ if _debugging_details;exec {$_[0]}@_}sub _sysopen {confess 'undef' unless defined $_[0]&& defined $_[1];_debug sprintf("O_RDONLY=0x%02x ",O_RDONLY),sprintf("O_WRONLY=0x%02x ",O_WRONLY),sprintf("O_RDWR=0x%02x ",O_RDWR),sprintf("O_TRUNC=0x%02x ",O_TRUNC),sprintf("O_CREAT=0x%02x ",O_CREAT),sprintf("O_APPEND=0x%02x ",O_APPEND),if _debugging_details;my$r=POSIX::open($_[0],$_[1],0644);croak "$!: open( $_[0], ",sprintf("0x%03x",$_[1])," )" unless defined$r;_debug "open( $_[0], ",sprintf("0x%03x",$_[1])," ) = $r" if _debugging_data;$fds{$r}=1;return$r}sub _pipe {my ($r,$w)=POSIX::pipe;croak "$!: pipe()" unless defined$r;_debug "pipe() = ( $r, $w ) " if _debugging_details;$fds{$r}=$fds{$w}=1;return ($r,$w)}sub _pipe_nb {local (*R,*W);my$f=pipe(R,W);croak "$!: pipe()" unless defined$f;my ($r,$w)=(fileno R,fileno W);_debug "pipe_nb pipe() = ( $r, $w )" if _debugging_details;unless (Win32_MODE){my$fres=fcntl(W,&F_SETFL,O_WRONLY | O_NONBLOCK);croak "$!: fcntl( $w, F_SETFL, O_NONBLOCK )" unless$fres;_debug "fcntl( $w, F_SETFL, O_NONBLOCK )" if _debugging_details}($r,$w)=(_dup($r),_dup($w));_debug "pipe_nb() = ( $r, $w )" if _debugging_details;return ($r,$w)}sub _pty {require IO::Pty;my$pty=IO::Pty->new();croak "$!: pty ()" unless$pty;$pty->autoflush();$pty->blocking(0)or croak "$!: pty->blocking ( 0 )";_debug "pty() = ( ",$pty->fileno,", ",$pty->slave->fileno," )" if _debugging_details;$fds{$pty->fileno}=$fds{$pty->slave->fileno}=1;return$pty}sub _read {confess 'undef' unless defined $_[0];my$s='';my$r=POSIX::read($_[0],$s,10_000);croak "$!: read( $_[0] )" if not($r)and $!!=POSIX::EINTR;$r ||=0;_debug "read( $_[0] ) = $r chars '$s'" if _debugging_data;return$s}sub _spawn {my IPC::Run$self=shift;my ($kid)=@_;_debug "opening sync pipe ",$kid->{PID}if _debugging_details;my$sync_reader_fd;($sync_reader_fd,$self->{SYNC_WRITER_FD})=_pipe;$kid->{PID}=fork();croak "$! during fork" unless defined$kid->{PID};unless ($kid->{PID}){$self->_do_kid_and_exit($kid)}_debug "fork() = ",$kid->{PID}if _debugging_details;_close$self->{SYNC_WRITER_FD};my$sync_pulse=_read$sync_reader_fd;_close$sync_reader_fd;if (!defined$sync_pulse || length$sync_pulse){if (waitpid($kid->{PID},0)>= 0){$kid->{RESULT}=$?}else {$kid->{RESULT}=-1}$sync_pulse="error reading synchronization pipe for $kid->{NUM}, pid $kid->{PID}" unless length$sync_pulse;croak$sync_pulse}return$kid->{PID};if (keys %{$self->{PTYS}}&& $IO::Pty::VERSION < 0.9){_debug "sleeping to give pty a chance to init, will fix when newer IO::Pty arrives.";sleep 1}}sub _write {confess 'undef' unless defined $_[0]&& defined $_[1];my$r=POSIX::write($_[0],$_[1],length $_[1]);croak "$!: write( $_[0], '$_[1]' )" unless$r;_debug "write( $_[0], '$_[1]' ) = $r" if _debugging_data;return$r}use vars qw($in_run);sub run {local$in_run=1;my IPC::Run$self=start(@_);my$r=eval {$self->{clear_ins}=0;$self->finish};if ($@){my$x=$@;$self->kill_kill;die$x}return$r}sub signal {my IPC::Run$self=shift;local$cur_self=$self;$self->_kill_kill_kill_pussycat_kill unless @_;Carp::cluck "Ignoring extra parameters passed to kill()" if @_ > 1;my ($signal)=@_;croak "Undefined signal passed to signal" unless defined$signal;for (grep $_->{PID}&&!defined $_->{RESULT},@{$self->{KIDS}}){_debug "sending $signal to $_->{PID}" if _debugging;kill$signal,$_->{PID}or _debugging && _debug "$! sending $signal to $_->{PID}"}return}sub kill_kill {my IPC::Run$self=shift;my%options=@_;my$grace=$options{grace};$grace=30 unless defined$grace;++$grace;my$coup_d_grace=$options{coup_d_grace};$coup_d_grace="KILL" unless defined$coup_d_grace;delete$options{$_}for qw(grace coup_d_grace);Carp::cluck "Ignoring unknown options for kill_kill: ",join " ",keys%options if keys%options;$self->signal("TERM");my$quitting_time=time + $grace;my$delay=0.01;my$accum_delay;my$have_killed_before;while (){select undef,undef,undef,$delay;$accum_delay += $delay;$self->reap_nb;last unless$self->_running_kids;if ($accum_delay >= $grace*0.8){if (time >= $quitting_time){if (!$have_killed_before){$self->signal($coup_d_grace);$have_killed_before=1;$quitting_time += $grace;$delay=0.01;$accum_delay=0;next}croak "Unable to reap all children, even after KILLing them"}}$delay *= 2;$delay=0.5 if$delay >= 0.5}$self->_cleanup;return$have_killed_before}my$harness_id=0;sub harness {my$options;if (@_ && ref $_[-1]eq 'HASH'){$options=pop;require Data::Dumper;carp "Passing in options as a hash is deprecated:\n",Data::Dumper::Dumper($options)}my@args;if (@_==1 &&!ref $_[0]){if (Win32_MODE){my$command=$ENV{ComSpec}|| 'cmd';@args=([$command,'/c',win32_parse_cmd_line $_[0]])}else {@args=([qw(sh -c),@_ ])}}elsif (@_ > 1 &&!grep ref $_,@_){@args=([@_ ])}else {@args=@_}my@errs;my$succinct;my$cur_kid;my$assumed_fd=0;my$handle_num=0;my IPC::Run$self=bless {},__PACKAGE__;local$cur_self=$self;$self->{ID}=++$harness_id;$self->{IOS}=[];$self->{KIDS}=[];$self->{PIPES}=[];$self->{PTYS}={};$self->{STATE}=_newed;if ($options){$self->{$_}=$options->{$_}for keys %$options}_debug "****** harnessing *****" if _debugging;my$first_parse;local $_;my$arg_count=@args;while (@args){for (shift@args){eval {$first_parse=1;_debug("parsing ",defined $_ ? ref $_ eq 'ARRAY' ? ('[ ',join(', ',map "'$_'",@$_),' ]'): (ref $_ || (length $_ < 50 ? "'$_'" : join('',"'",substr($_,0,10),"...'"))): '<undef>')if _debugging;REPARSE: if (ref eq 'ARRAY' || (!$cur_kid && ref eq 'CODE')){croak "Process control symbol ('|', '&') missing" if$cur_kid;croak "Can't spawn a subroutine on Win32" if Win32_MODE && ref eq "CODE";$cur_kid={TYPE=>'cmd',VAL=>$_,NUM=>@{$self->{KIDS}}+ 1,OPS=>[],PID=>'',RESULT=>undef,};push @{$self->{KIDS}},$cur_kid;$succinct=1}elsif (UNIVERSAL::isa($_,'IPC::Run::IO')){push @{$self->{IOS}},$_;$cur_kid=undef;$succinct=1}elsif (UNIVERSAL::isa($_,'IPC::Run::Timer')){push @{$self->{TIMERS}},$_;$cur_kid=undef;$succinct=1}elsif (/^(\d*)>&(\d+)$/){croak "No command before '$_'" unless$cur_kid;push @{$cur_kid->{OPS}},{TYPE=>'dup',KFD1=>$2,KFD2=>length $1 ? $1 : 1,};_debug "redirect operators now required" if _debugging_details;$succinct=!$first_parse}elsif (/^(\d*)<&(\d+)$/){croak "No command before '$_'" unless$cur_kid;push @{$cur_kid->{OPS}},{TYPE=>'dup',KFD1=>$2,KFD2=>length $1 ? $1 : 0,};$succinct=!$first_parse}elsif (/^(\d*)<&-$/){croak "No command before '$_'" unless$cur_kid;push @{$cur_kid->{OPS}},{TYPE=>'close',KFD=>length $1 ? $1 : 0,};$succinct=!$first_parse}elsif (/^(\d*) (<pipe)()            ()  ()  $/x || /^(\d*) (<pty) ((?:\s+\S+)?) (<) ()  $/x || /^(\d*) (<)    ()            ()  (.*)$/x){croak "No command before '$_'" unless$cur_kid;$succinct=!$first_parse;my$type=$2 .$4;my$kfd=length $1 ? $1 : 0;my$pty_id;if ($type eq '<pty<'){$pty_id=length $3 ? $3 : '0';require IO::Pty;$self->{PTYS}->{$pty_id}=undef}my$source=$5;my@filters;my$binmode;unless (length$source){if (!$succinct){while (@args > 1 && ((ref$args[1]&&!UNIVERSAL::isa$args[1],"IPC::Run::Timer")|| UNIVERSAL::isa$args[0],"IPC::Run::binmode_pseudo_filter")){if (UNIVERSAL::isa$args[0],"IPC::Run::binmode_pseudo_filter"){$binmode=shift(@args)->()}else {push@filters,shift@args}}}$source=shift@args;croak "'$_' missing a source" if _empty$source;_debug('Kid ',$cur_kid->{NUM},"'s input fd ",$kfd,' has ',scalar(@filters),' filters.')if _debugging_details && @filters};my IPC::Run::IO$pipe=IPC::Run::IO->_new_internal($type,$kfd,$pty_id,$source,$binmode,@filters);if ((ref$source eq 'GLOB' || UNIVERSAL::isa$source,'IO::Handle')&& $type !~ /^<p(ty<|ipe)$/){_debug "setting DONT_CLOSE" if _debugging_details;$pipe->{DONT_CLOSE}=1;_dont_inherit($source)if Win32_MODE}push @{$cur_kid->{OPS}},$pipe}elsif (/^()   (>>?)  (&)     ()      (.*)$/x || /^()   (&)    (>pipe) ()      ()  $/x || /^()   (>pipe)(&)     ()      ()  $/x || /^(\d*)()     (>pipe) ()      ()  $/x || /^()   (&)    (>pty)  ( \w*)> ()  $/x || /^(\d*)()     (>pty)  ( \w*)> ()  $/x || /^()   (&)    (>>?)   ()      (.*)$/x || /^(\d*)()     (>>?)   ()      (.*)$/x){croak "No command before '$_'" unless$cur_kid;$succinct=!$first_parse;my$type=($2 eq '>pipe' || $3 eq '>pipe' ? '>pipe' : $2 eq '>pty' || $3 eq '>pty' ? '>pty>' : '>');my$kfd=length $1 ? $1 : 1;my$trunc=!($2 eq '>>' || $3 eq '>>');my$pty_id=($2 eq '>pty' || $3 eq '>pty' ? length $4 ? $4 : 0 : undef);my$stderr_too=$2 eq '&' || $3 eq '&' || (!length $1 && substr($type,0,4)eq '>pty');my$dest=$5;my@filters;my$binmode=0;unless (length$dest){if (!$succinct){while (@args > 1 && ((ref$args[1]&&!UNIVERSAL::isa$args[1],"IPC::Run::Timer")|| UNIVERSAL::isa$args[0],"IPC::Run::binmode_pseudo_filter")){if (UNIVERSAL::isa$args[0],"IPC::Run::binmode_pseudo_filter"){$binmode=shift(@args)->()}else {unshift@filters,shift@args}}}$dest=shift@args;_debug('Kid ',$cur_kid->{NUM},"'s output fd ",$kfd,' has ',scalar(@filters),' filters.')if _debugging_details && @filters;if ($type eq '>pty>'){require IO::Pty;$self->{PTYS}->{$pty_id}=undef}}croak "'$_' missing a destination" if _empty$dest;my$pipe=IPC::Run::IO->_new_internal($type,$kfd,$pty_id,$dest,$binmode,@filters);$pipe->{TRUNC}=$trunc;if ((UNIVERSAL::isa($dest,'GLOB')|| UNIVERSAL::isa($dest,'IO::Handle'))&& $type !~ /^>(pty>|pipe)$/){_debug "setting DONT_CLOSE" if _debugging_details;$pipe->{DONT_CLOSE}=1}push @{$cur_kid->{OPS}},$pipe;push @{$cur_kid->{OPS}},{TYPE=>'dup',KFD1=>1,KFD2=>2,}if$stderr_too}elsif ($_ eq "|"){croak "No command before '$_'" unless$cur_kid;unshift @{$cur_kid->{OPS}},{TYPE=>'|',KFD=>1,};$succinct=1;$assumed_fd=1;$cur_kid=undef}elsif ($_ eq "&"){croak "No command before '$_'" unless$cur_kid;unshift @{$cur_kid->{OPS}},{TYPE=>'close',KFD=>0,};$succinct=1;$assumed_fd=0;$cur_kid=undef}elsif ($_ eq 'init'){croak "No command before '$_'" unless$cur_kid;push @{$cur_kid->{OPS}},{TYPE=>'init',SUB=>shift@args,}}elsif (!ref $_){$self->{$_}=shift@args}elsif ($_ eq 'init'){croak "No command before '$_'" unless$cur_kid;push @{$cur_kid->{OPS}},{TYPE=>'init',SUB=>shift@args,}}elsif ($succinct && $first_parse){unshift@args,$_;if (!$assumed_fd){$_="$assumed_fd<",}else {$_="$assumed_fd>",}_debug "assuming '",$_,"'" if _debugging_details;++$assumed_fd;$first_parse=0;goto REPARSE}else {croak join('','Unexpected ',(ref()? $_ : 'scalar'),' in harness() parameter ',$arg_count - @args)}};if ($@){push@errs,$@;_debug 'caught ',$@ if _debugging}}}die join('',@errs)if@errs;$self->{STATE}=_harnessed;return$self}sub _open_pipes {my IPC::Run$self=shift;my@errs;my@close_on_fail;my$pipe_read_fd;my@output_fds_accum;for (sort keys %{$self->{PTYS}}){_debug "opening pty '",$_,"'" if _debugging_details;my$pty=_pty;$self->{PTYS}->{$_}=$pty}for (@{$self->{IOS}}){eval {$_->init};if ($@){push@errs,$@;_debug 'caught ',$@ if _debugging}else {push@close_on_fail,$_}}for my$kid (@{$self->{KIDS}}){unless (ref$kid->{VAL}eq 'CODE'){$kid->{PATH}=_search_path$kid->{VAL}->[0]}if (defined$pipe_read_fd){_debug "placing write end of pipe on kid $kid->{NUM}'s stdin" if _debugging_details;unshift @{$kid->{OPS}},{TYPE=>'PIPE',KFD=>0,TFD=>$pipe_read_fd,};$pipe_read_fd=undef}@output_fds_accum=();for my$op (@{$kid->{OPS}}){my$ok=eval {if ($op->{TYPE}eq '<'){my$source=$op->{SOURCE};if (!ref$source){_debug("kid ",$kid->{NUM}," to read ",$op->{KFD}," from '" .$source,"' (read only)")if _debugging_details;croak "simulated open failure" if$self->{_simulate_open_failure};$op->{TFD}=_sysopen($source,O_RDONLY);push@close_on_fail,$op->{TFD}}elsif (UNIVERSAL::isa($source,'GLOB')|| UNIVERSAL::isa($source,'IO::Handle')){croak "Unopened filehandle in input redirect for $op->{KFD}" unless defined fileno$source;$op->{TFD}=fileno$source;_debug("kid ",$kid->{NUM}," to read ",$op->{KFD}," from fd ",$op->{TFD})if _debugging_details}elsif (UNIVERSAL::isa($source,'SCALAR')){_debug("kid ",$kid->{NUM}," to read ",$op->{KFD}," from SCALAR")if _debugging_details;$op->open_pipe($self->_debug_fd);push@close_on_fail,$op->{KFD},$op->{FD};my$s='';$op->{KIN_REF}=\$s}elsif (UNIVERSAL::isa($source,'CODE')){_debug('kid ',$kid->{NUM},' to read ',$op->{KFD},' from CODE')if _debugging_details;$op->open_pipe($self->_debug_fd);push@close_on_fail,$op->{KFD},$op->{FD};my$s='';$op->{KIN_REF}=\$s}else {croak("'" .ref($source)."' not allowed as a source for input redirection")}$op->_init_filters}elsif ($op->{TYPE}eq '<pipe'){_debug('kid to read ',$op->{KFD},' from a pipe IPC::Run opens and returns',)if _debugging_details;my ($r,$w)=$op->open_pipe($self->_debug_fd,$op->{SOURCE});_debug "caller will write to ",fileno$op->{SOURCE}if _debugging_details;$op->{TFD}=$r;$op->{FD}=undef;$op->_init_filters}elsif ($op->{TYPE}eq '<pty<'){_debug('kid to read ',$op->{KFD}," from pty '",$op->{PTY_ID},"'",)if _debugging_details;for my$source ($op->{SOURCE}){if (UNIVERSAL::isa($source,'SCALAR')){_debug("kid ",$kid->{NUM}," to read ",$op->{KFD}," from SCALAR via pty '",$op->{PTY_ID},"'")if _debugging_details;my$s='';$op->{KIN_REF}=\$s}elsif (UNIVERSAL::isa($source,'CODE')){_debug("kid ",$kid->{NUM}," to read ",$op->{KFD}," from CODE via pty '",$op->{PTY_ID},"'")if _debugging_details;my$s='';$op->{KIN_REF}=\$s}else {croak("'" .ref($source)."' not allowed as a source for '<pty<' redirection")}}$op->{FD}=$self->{PTYS}->{$op->{PTY_ID}}->fileno;$op->{TFD}=undef;$op->_init_filters}elsif ($op->{TYPE}eq '>'){my$dest=$op->{DEST};if (!ref$dest){_debug("kid ",$kid->{NUM}," to write ",$op->{KFD}," to '",$dest,"' (write only, create, ",($op->{TRUNC}? 'truncate' : 'append'),")")if _debugging_details;croak "simulated open failure" if$self->{_simulate_open_failure};$op->{TFD}=_sysopen($dest,(O_WRONLY | O_CREAT | ($op->{TRUNC}? O_TRUNC : O_APPEND)));if (Win32_MODE){POSIX::lseek($op->{TFD},0,POSIX::SEEK_END())}push@close_on_fail,$op->{TFD}}elsif (UNIVERSAL::isa($dest,'GLOB')){croak("Unopened filehandle in output redirect, command $kid->{NUM}")unless defined fileno$dest;my$old_fh=select($dest);$|=1;select($old_fh);$op->{TFD}=fileno$dest;_debug('kid to write ',$op->{KFD},' to handle ',$op->{TFD})if _debugging_details}elsif (UNIVERSAL::isa($dest,'SCALAR')){_debug("kid ",$kid->{NUM}," to write $op->{KFD} to SCALAR")if _debugging_details;$op->open_pipe($self->_debug_fd);push@close_on_fail,$op->{FD},$op->{TFD};$$dest='' if$op->{TRUNC}}elsif (UNIVERSAL::isa($dest,'CODE')){_debug("kid $kid->{NUM} to write $op->{KFD} to CODE")if _debugging_details;$op->open_pipe($self->_debug_fd);push@close_on_fail,$op->{FD},$op->{TFD}}else {croak("'" .ref($dest)."' not allowed as a sink for output redirection")}$output_fds_accum[$op->{KFD}]=$op;$op->_init_filters}elsif ($op->{TYPE}eq '>pipe'){_debug("kid ",$kid->{NUM}," to write ",$op->{KFD},' to a pipe IPC::Run opens and returns')if _debugging_details;my ($r,$w)=$op->open_pipe($self->_debug_fd,$op->{DEST});_debug "caller will read from ",fileno$op->{DEST}if _debugging_details;$op->{TFD}=$w;$op->{FD}=undef;$op->_init_filters;$output_fds_accum[$op->{KFD}]=$op}elsif ($op->{TYPE}eq '>pty>'){my$dest=$op->{DEST};if (UNIVERSAL::isa($dest,'SCALAR')){_debug("kid ",$kid->{NUM}," to write ",$op->{KFD}," to SCALAR via pty '",$op->{PTY_ID},"'")if _debugging_details;$$dest='' if$op->{TRUNC}}elsif (UNIVERSAL::isa($dest,'CODE')){_debug("kid ",$kid->{NUM}," to write ",$op->{KFD}," to CODE via pty '",$op->{PTY_ID},"'")if _debugging_details}else {croak("'" .ref($dest)."' not allowed as a sink for output redirection")}$op->{FD}=$self->{PTYS}->{$op->{PTY_ID}}->fileno;$op->{TFD}=undef;$output_fds_accum[$op->{KFD}]=$op;$op->_init_filters}elsif ($op->{TYPE}eq '|'){_debug("pipelining $kid->{NUM} and " .($kid->{NUM}+ 1))if _debugging_details;($pipe_read_fd,$op->{TFD})=_pipe;if (Win32_MODE){_dont_inherit($pipe_read_fd);_dont_inherit($op->{TFD})}@output_fds_accum=()}elsif ($op->{TYPE}eq '&'){@output_fds_accum=()}1};unless ($ok){push@errs,$@;_debug 'caught ',$@ if _debugging}}}if (@errs){for (@close_on_fail){_close($_);$_=undef}for (keys %{$self->{PTYS}}){next unless$self->{PTYS}->{$_};close$self->{PTYS}->{$_};$self->{PTYS}->{$_}=undef}die join('',@errs)}for (my$num=0;$num < $#{$self->{KIDS}};++$num ){for (reverse@output_fds_accum){next unless defined $_;_debug('kid ',$self->{KIDS}->[$num]->{NUM},' also to write ',$_->{KFD},' to ',ref $_->{DEST})if _debugging_details;unshift @{$self->{KIDS}->[$num]->{OPS}},$_}}@{$self->{PIPES}}=();$self->{RIN}='';$self->{WIN}='';$self->{EIN}='';$self->{PIN}='';for my$kid (@{$self->{KIDS}}){for (@{$kid->{OPS}}){if (defined $_->{FD}){_debug('kid ',$kid->{NUM},'[',$kid->{PID},"]'s ",$_->{KFD},' is my ',$_->{FD})if _debugging_details;vec($self->{$_->{TYPE}=~ /^</ ? 'WIN' : 'RIN' },$_->{FD},1)=1;push @{$self->{PIPES}},$_}}}for my$io (@{$self->{IOS}}){my$fd=$io->fileno;vec($self->{RIN},$fd,1)=1 if$io->mode =~ /r/;vec($self->{WIN},$fd,1)=1 if$io->mode =~ /w/;push @{$self->{PIPES}},$io}for my$pipe (@{$self->{PIPES}}){$pipe->{SOURCE_EMPTY}=0;$pipe->{PAUSED}=0;if ($pipe->{TYPE}=~ /^>/){my$pipe_reader=sub {my (undef,$out_ref)=@_;return undef unless defined$pipe->{FD};return 0 unless vec($self->{ROUT},$pipe->{FD},1);vec($self->{ROUT},$pipe->{FD},1)=0;_debug_desc_fd('reading from',$pipe)if _debugging_details;my$in=eval {_read($pipe->{FD})};if ($@){$in='';die $@ unless $@ =~ $_EIO || ($@ =~ /input or output/ && $^O =~ /aix/)|| (Win32_MODE && $@ =~ /Bad file descriptor/)}unless (length$in){$self->_clobber($pipe);return undef}my$pos=pos $$out_ref;$$out_ref .= $in;pos($$out_ref)=$pos;return 1};push @{$pipe->{FILTERS}},$pipe_reader;push @{$self->{TEMP_FILTERS}},$pipe_reader}else {my$pipe_writer=sub {my ($in_ref,$out_ref)=@_;return undef unless defined$pipe->{FD};return 0 unless vec($self->{WOUT},$pipe->{FD},1)|| $pipe->{PAUSED};vec($self->{WOUT},$pipe->{FD},1)=0;if (!length $$in_ref){if (!defined get_more_input){$self->_clobber($pipe);return undef}}unless (length $$in_ref){unless ($pipe->{PAUSED}){_debug_desc_fd('pausing',$pipe)if _debugging_details;vec($self->{WIN},$pipe->{FD},1)=0;vec($self->{PIN},$pipe->{FD},1)=1;$pipe->{PAUSED}=1}return 0}_debug_desc_fd('writing to',$pipe)if _debugging_details;my$c=_write($pipe->{FD},$$in_ref);substr($$in_ref,0,$c,'');return 1};unshift @{$pipe->{FILTERS}},$pipe_writer;push @{$self->{TEMP_FILTERS}},$pipe_writer}}}sub _dup2_gently {my IPC::Run$self=shift;my ($files,$fd1,$fd2)=@_;for (@$files){next unless defined $_->{TFD};$_->{TFD}=_dup($_->{TFD})if $_->{TFD}==$fd2}$self->{DEBUG_FD}=_dup$self->{DEBUG_FD}if defined$self->{DEBUG_FD}&& $self->{DEBUG_FD}==$fd2;_dup2_rudely($fd1,$fd2)}sub close_terminal {POSIX::setsid()|| croak "POSIX::setsid() failed";_debug "closing stdin, out, err" if _debugging_details;close STDIN;close STDERR;close STDOUT}sub _do_kid_and_exit {my IPC::Run$self=shift;my ($kid)=@_;my ($s1,$s2);if ($] < 5.008){$s1=Symbol::gensym();$s2=Symbol::gensym()}eval {local$cur_self=$self;if (_debugging){_set_child_debug_name(ref$kid->{VAL}eq "CODE" ? "CODE" : basename($kid->{VAL}->[0]))}my@needed=$self->{noinherit}? (): (1,1,1);$needed[$self->{SYNC_WRITER_FD}]=1;$needed[$self->{DEBUG_FD}]=1 if defined$self->{DEBUG_FD};for (@{$kid->{OPS}}){$needed[$_->{TFD}]=1 if defined $_->{TFD}}my@closed;if (%{$self->{PTYS}}){for (keys %{$self->{PTYS}}){_debug "Cleaning up parent's ptty '$_'" if _debugging_details;my$slave=$self->{PTYS}->{$_}->slave;$closed[$self->{PTYS}->{$_}->fileno ]=1;close$self->{PTYS}->{$_};$self->{PTYS}->{$_}=$slave}close_terminal;$closed[$_ ]=1 for (0..2)}for my$sibling (@{$self->{KIDS}}){for (@{$sibling->{OPS}}){if ($_->{TYPE}=~ /^.pty.$/){$_->{TFD}=$self->{PTYS}->{$_->{PTY_ID}}->fileno;$needed[$_->{TFD}]=1}}}_debug "open fds: ",join " ",keys%fds if _debugging_details;for (keys%fds){if (!$closed[$_]&&!$needed[$_]){_close($_);$closed[$_]=1}}my@lazy_close;for (@{$kid->{OPS}}){if (defined $_->{TFD}){unless ($_->{TFD}==$_->{KFD}){$self->_dup2_gently($kid->{OPS},$_->{TFD},$_->{KFD});push@lazy_close,$_->{TFD}}}elsif ($_->{TYPE}eq 'dup'){$self->_dup2_gently($kid->{OPS},$_->{KFD1},$_->{KFD2})unless $_->{KFD1}==$_->{KFD2}}elsif ($_->{TYPE}eq 'close'){for ($_->{KFD}){if (!$closed[$_]){_close($_);$closed[$_]=1;$_=undef}}}elsif ($_->{TYPE}eq 'init'){$_->{SUB}->()}}for (@lazy_close){unless ($closed[$_]){_close($_);$closed[$_]=1}}if (ref$kid->{VAL}ne 'CODE'){open$s1,">&=$self->{SYNC_WRITER_FD}" or croak "$! setting filehandle to fd SYNC_WRITER_FD";fcntl$s1,F_SETFD,1;if (defined$self->{DEBUG_FD}){open$s2,">&=$self->{DEBUG_FD}" or croak "$! setting filehandle to fd DEBUG_FD";fcntl$s2,F_SETFD,1}if (_debugging){my@cmd=($kid->{PATH},@{$kid->{VAL}}[1..$#{$kid->{VAL}}]);_debug 'execing ',join " ",map {/[\s\"]/ ? "'$_'" : $_}@cmd}die "exec failed: simulating exec() failure" if$self->{_simulate_exec_failure};_exec$kid->{PATH},@{$kid->{VAL}}[1..$#{$kid->{VAL}}];croak "exec failed: $!"}};if ($@){_write$self->{SYNC_WRITER_FD},$@;POSIX::exit 1}_close$self->{SYNC_WRITER_FD};_debug 'calling fork()ed CODE ref' if _debugging;POSIX::close$self->{DEBUG_FD}if defined$self->{DEBUG_FD};$kid->{VAL}->();$kid->{VAL}=undef;POSIX::exit 0}sub start {my$options;if (@_ && ref $_[-1]eq 'HASH'){$options=pop;require Data::Dumper;carp "Passing in options as a hash is deprecated:\n",Data::Dumper::Dumper($options)}my IPC::Run$self;if (@_==1 && UNIVERSAL::isa($_[0],__PACKAGE__)){$self=shift;$self->{$_}=$options->{$_}for keys %$options}else {$self=harness(@_,$options ? $options : ())}local$cur_self=$self;$self->kill_kill if$self->{STATE}==_started;_debug "** starting" if _debugging;$_->{RESULT}=undef for @{$self->{KIDS}};$self->{clear_ins}=1;IPC::Run::Win32Helper::optimize$self if Win32_MODE && $in_run;my@errs;for (@{$self->{TIMERS}}){eval {$_->start};if ($@){push@errs,$@;_debug 'caught ',$@ if _debugging}}eval {$self->_open_pipes};if ($@){push@errs,$@;_debug 'caught ',$@ if _debugging}if (!@errs){{my$ofh=select STDOUT;local $|=1;select$ofh}{my$ofh=select STDERR;local $|=1;select$ofh}for my$kid (@{$self->{KIDS}}){$kid->{RESULT}=undef;_debug "child: ",ref($kid->{VAL})eq "CODE" ? "CODE ref" : ("`",join(" ",map /[^\w.-]/ ? "'$_'" : $_,@{$kid->{VAL}}),"`")if _debugging_details;eval {croak "simulated failure of fork" if$self->{_simulate_fork_failure};unless (Win32_MODE){$self->_spawn($kid)}else {_debug('spawning ',join(' ',map("'$_'",($kid->{PATH},@{$kid->{VAL}}[1..$#{$kid->{VAL}}]))))if _debugging;_dont_inherit($self->{DEBUG_FD});($kid->{PID},$kid->{PROCESS})=IPC::Run::Win32Helper::win32_spawn([$kid->{PATH},@{$kid->{VAL}}[1..$#{$kid->{VAL}}]],$kid->{OPS},);_debug "spawn() = ",$kid->{PID}if _debugging}};if ($@){push@errs,$@;_debug 'caught ',$@ if _debugging}}}for my$pty (values %{$self->{PTYS}}){close$pty->slave}my@closed;for my$kid (@{$self->{KIDS}}){for (@{$kid->{OPS}}){my$close_it=eval {defined $_->{TFD}&&!$_->{DONT_CLOSE}&&!$closed[$_->{TFD}]&& (!Win32_MODE ||!$_->{RECV_THROUGH_TEMP_FILE})};if ($@){push@errs,$@;_debug 'caught ',$@ if _debugging}if ($close_it || $@){eval {_close($_->{TFD});$closed[$_->{TFD}]=1;$_->{TFD}=undef};if ($@){push@errs,$@;_debug 'caught ',$@ if _debugging}}}}confess "gak!" unless defined$self->{PIPES};if (@errs){eval {$self->_cleanup};warn $@ if $@;die join('',@errs)}$self->{STATE}=_started;return$self}sub adopt {my IPC::Run$self=shift;for my$adoptee (@_){push @{$self->{IOS}},@{$adoptee->{IOS}};push @{$self->{KIDS}},@{$adoptee->{KIDS}};push @{$self->{PIPES}},@{$adoptee->{PIPES}};$self->{PTYS}->{$_}=$adoptee->{PTYS}->{$_}for keys %{$adoptee->{PYTS}};push @{$self->{TIMERS}},@{$adoptee->{TIMERS}};$adoptee->{STATE}=_finished}}sub _clobber {my IPC::Run$self=shift;my ($file)=@_;_debug_desc_fd("closing",$file)if _debugging_details;my$doomed=$file->{FD};my$dir=$file->{TYPE}=~ /^</ ? 'WIN' : 'RIN';vec($self->{$dir},$doomed,1)=0;vec($self->{PIN},$doomed,1)=0;if ($file->{TYPE}=~ /^(.)pty.$/){if ($1 eq '>'){_debug_desc_fd "closing pty",$file if _debugging_details;close$self->{PTYS}->{$file->{PTY_ID}}if defined$self->{PTYS}->{$file->{PTY_ID}};$self->{PTYS}->{$file->{PTY_ID}}=undef}}elsif (UNIVERSAL::isa($file,'IPC::Run::IO')){$file->close unless$file->{DONT_CLOSE}}else {_close($doomed)}@{$self->{PIPES}}=grep defined $_->{FD}&& ($_->{TYPE}ne $file->{TYPE}|| $_->{FD}ne $doomed),@{$self->{PIPES}};$file->{FD}=undef}sub _select_loop {my IPC::Run$self=shift;my$io_occurred;my$not_forever=0.01;SELECT: while ($self->pumpable){if ($io_occurred && $self->{break_on_io}){_debug "exiting _select(): io occured and break_on_io set" if _debugging_details;last}my$timeout=$self->{non_blocking}? 0 : undef;if (@{$self->{TIMERS}}){my$now=time;my$time_left;for (@{$self->{TIMERS}}){next unless $_->is_running;$time_left=$_->check($now);return if defined$time_left &&!$time_left;$timeout=$time_left if!defined$timeout || $time_left < $timeout}}my$paused=0;for my$file (@{$self->{PIPES}}){next unless$file->{PAUSED}&& $file->{TYPE}=~ /^</;_debug_desc_fd("checking for more input",$file)if _debugging_details;my$did;1 while$did=$file->_do_filters($self);if (defined$file->{FD}&&!defined($did)|| $did){_debug_desc_fd("unpausing",$file)if _debugging_details;$file->{PAUSED}=0;vec($self->{WIN},$file->{FD},1)=1;vec($self->{PIN},$file->{FD},1)=0}else {++$paused}}if (_debugging_details){my$map=join('',map {my$out;$out='r' if vec($self->{RIN},$_,1);$out=$out ? 'b' : 'w' if vec($self->{WIN},$_,1);$out='p' if!$out && vec($self->{PIN},$_,1);$out=$out ? uc($out): 'x' if vec($self->{EIN},$_,1);$out='-' unless$out;$out}(0..1024));$map =~ s/((?:[a-zA-Z-]|\([^\)]*\)){12,}?)-*$/$1/;_debug 'fds for select: ',$map if _debugging_details}my$p=$self->pumpable;last unless$p;if ($p!=0 && (!defined$timeout || $timeout > 0.1)){$timeout=$not_forever;$not_forever *= 2;$not_forever=0.5 if$not_forever >= 0.5}if (!defined$timeout &&!(@{$self->{PIPES}}- $paused)){if ($self->{break_on_io}){_debug "exiting _select(): no I/O to do and timeout=forever" if _debugging;last}$timeout=$not_forever;$not_forever *= 2;$not_forever=0.5 if$not_forever >= 0.5}_debug 'timeout=',defined$timeout ? $timeout : 'forever' if _debugging_details;my$nfound;unless (Win32_MODE){$nfound=select($self->{ROUT}=$self->{RIN},$self->{WOUT}=$self->{WIN},$self->{EOUT}=$self->{EIN},$timeout)}else {my@in=map$self->{$_},qw(RIN WIN EIN);for (@in){$_=undef unless index((unpack "b*",$_),1)>= 0}$nfound=select($self->{ROUT}=$in[0],$self->{WOUT}=$in[1],$self->{EOUT}=$in[2],$timeout);for ($self->{ROUT},$self->{WOUT},$self->{EOUT}){$_="" unless defined $_}}last if!$nfound && $self->{non_blocking};if ($nfound < 0){if ($!==POSIX::EINTR){$self->{ROUT}=$self->{WOUT}=$self->{EOUT}='';$nfound=0}else {croak "$! in select"}}if (_debugging_details){my$map=join('',map {my$out;$out='r' if vec($self->{ROUT},$_,1);$out=$out ? 'b' : 'w' if vec($self->{WOUT},$_,1);$out=$out ? uc($out): 'x' if vec($self->{EOUT},$_,1);$out='-' unless$out;$out}(0..128));$map =~ s/((?:[a-zA-Z-]|\([^\)]*\)){12,}?)-*$/$1/;_debug "selected  ",$map}my@pipes=@{$self->{PIPES}};$io_occurred=$_->poll($self)? 1 : $io_occurred for@pipes}return}sub _cleanup {my IPC::Run$self=shift;_debug "cleaning up" if _debugging_details;for (values %{$self->{PTYS}}){next unless ref $_;eval {_debug "closing slave fd ",fileno $_->slave if _debugging_data;close $_->slave};carp $@ ." while closing ptys" if $@;eval {_debug "closing master fd ",fileno $_ if _debugging_data;close $_};carp $@ ." closing ptys" if $@}_debug "cleaning up pipes" if _debugging_details;$self->_clobber($self->{PIPES}->[0])while @{$self->{PIPES}};for my$kid (@{$self->{KIDS}}){_debug "cleaning up kid ",$kid->{NUM}if _debugging_details;if (!length$kid->{PID}){_debug 'never ran child ',$kid->{NUM},", can't reap" if _debugging;for my$op (@{$kid->{OPS}}){_close($op->{TFD})if defined$op->{TFD}&&!defined$op->{TEMP_FILE_HANDLE}}}elsif (!defined$kid->{RESULT}){_debug 'reaping child ',$kid->{NUM},' (pid ',$kid->{PID},')' if _debugging;my$pid=waitpid$kid->{PID},0;$kid->{RESULT}=$?;_debug 'reaped ',$pid,', $?=',$kid->{RESULT}if _debugging}_debug "cleaning up filters" if _debugging_details;for my$op (@{$kid->{OPS}}){@{$op->{FILTERS}}=grep {my$filter=$_;!grep$filter==$_,@{$self->{TEMP_FILTERS}}}@{$op->{FILTERS}}}for my$op (@{$kid->{OPS}}){$op->_cleanup($self)if UNIVERSAL::isa($op,"IPC::Run::IO")}}$self->{STATE}=_finished;@{$self->{TEMP_FILTERS}}=();_debug "done cleaning up" if _debugging_details;POSIX::close$self->{DEBUG_FD}if defined$self->{DEBUG_FD};$self->{DEBUG_FD}=undef}sub pump {die "pump() takes only a a single harness as a parameter" unless @_==1 && UNIVERSAL::isa($_[0],__PACKAGE__);my IPC::Run$self=shift;local$cur_self=$self;_debug "** pumping" if _debugging;$self->start if$self->{STATE}< _started;croak "process ended prematurely" unless$self->pumpable;$self->{auto_close_ins}=0;$self->{break_on_io}=1;$self->_select_loop;return$self->pumpable}sub pump_nb {my IPC::Run$self=shift;$self->{non_blocking}=1;my$r=eval {$self->pump};$self->{non_blocking}=0;die $@ if $@;return$r}sub pumpable {my IPC::Run$self=shift;return -1 if grep!$_->{PAUSED},@{$self->{PIPES}};$self->reap_nb;return 0 unless$self->_running_kids;select undef,undef,undef,0.0001;$self->reap_nb;return 0 unless$self->_running_kids;return -1}sub _running_kids {my IPC::Run$self=shift;return grep defined $_->{PID}&&!defined $_->{RESULT},@{$self->{KIDS}}}my$still_runnings;sub reap_nb {my IPC::Run$self=shift;local$cur_self=$self;for my$kid (@{$self->{KIDS}}){if (Win32_MODE){next if!defined$kid->{PROCESS}|| defined$kid->{RESULT};unless ($kid->{PROCESS}->Wait(0)){_debug "kid $kid->{NUM} ($kid->{PID}) still running" if _debugging_details;next}_debug "kid $kid->{NUM} ($kid->{PID}) exited" if _debugging;$kid->{PROCESS}->GetExitCode($kid->{RESULT})or croak "$! while GetExitCode()ing for Win32 process";unless (defined$kid->{RESULT}){$kid->{RESULT}="0 but true";$?=$kid->{RESULT}=0x0F}else {$?=$kid->{RESULT}<< 8}}else {next if!defined$kid->{PID}|| defined$kid->{RESULT};my$pid=waitpid$kid->{PID},POSIX::WNOHANG();unless ($pid){_debug "$kid->{NUM} ($kid->{PID}) still running" if _debugging_details;next}if ($pid < 0){_debug "No such process: $kid->{PID}\n" if _debugging;$kid->{RESULT}="unknown result, unknown PID"}else {_debug "kid $kid->{NUM} ($kid->{PID}) exited" if _debugging;confess "waitpid returned the wrong PID: $pid instead of $kid->{PID}" unless$pid=$kid->{PID};_debug "$kid->{PID} returned $?\n" if _debugging;$kid->{RESULT}=$?}}}}sub finish {my IPC::Run$self=shift;my$options=@_ && ref $_[-1]eq 'HASH' ? pop : {};local$cur_self=$self;_debug "** finishing" if _debugging;$self->{non_blocking}=0;$self->{auto_close_ins}=1;$self->{break_on_io}=0;while ($self->pumpable){$self->_select_loop($options)}$self->_cleanup;return!$self->full_result}sub _assert_finished {my IPC::Run$self=$_[0];croak "Harness not run" unless$self->{STATE}>= _finished;croak "Harness not finished running" unless$self->{STATE}==_finished}sub result {&_assert_finished;my IPC::Run$self=shift;if (@_){my ($which)=@_;croak("Only ",scalar(@{$self->{KIDS}})," child processes, no process $which")unless$which >= 0 && $which <= $#{$self->{KIDS}};return$self->{KIDS}->[$which]->{RESULT}>> 8}else {return undef unless @{$self->{KIDS}};for (@{$self->{KIDS}}){return $_->{RESULT}>> 8 if $_->{RESULT}>> 8}}}sub results {&_assert_finished;my IPC::Run$self=shift;return map {(0+$_->{RESULT})>> 8}@{$self->{KIDS}}}sub full_result {goto&result if @_ > 1;&_assert_finished;my IPC::Run$self=shift;return undef unless @{$self->{KIDS}};for (@{$self->{KIDS}}){return $_->{RESULT}if $_->{RESULT}}}sub full_results {&_assert_finished;my IPC::Run$self=shift;croak "Harness not run" unless$self->{STATE}>= _finished;croak "Harness not finished running" unless$self->{STATE}==_finished;return map $_->{RESULT},@{$self->{KIDS}}}use vars ('$filter_op','$filter_num',);sub binary(;$) {my$enable=@_ ? shift : 1;return bless sub {$enable},"IPC::Run::binmode_pseudo_filter"}sub new_chunker(;$) {my ($re)=@_;$re=$/ if _empty$re;$re=quotemeta($re)unless ref$re eq 'Regexp';$re=qr/\A(.*?$re)/s;return sub {my ($in_ref,$out_ref)=@_;return 0 if length $$out_ref;return input_avail && do {while (1){if ($$in_ref =~ s/$re//){$$out_ref .= $1;return 1}my$hmm=get_more_input;unless (defined$hmm){$$out_ref=$$in_ref;$$in_ref='';return length $$out_ref ? 1 : 0}return 0 if$hmm eq 0}}}}sub new_appender($) {my ($suffix)=@_;croak "\$suffix undefined" unless defined$suffix;return sub {my ($in_ref,$out_ref)=@_;return input_avail && do {$$out_ref=join('',$$out_ref,$$in_ref,$suffix);$$in_ref='';1}}}sub new_string_source {my$ref;if (@_ > 1){$ref=[@_ ],}else {$ref=shift}return ref$ref eq 'SCALAR' ? sub {my ($in_ref,$out_ref)=@_;return defined $$ref ? do {$$out_ref .= $$ref;my$r=length $$ref ? 1 : 0;$$ref=undef;$r}: undef}: sub {my ($in_ref,$out_ref)=@_;return @$ref ? do {my$s=shift @$ref;$$out_ref .= $s;length$s ? 1 : 0}: undef}}sub new_string_sink {my ($string_ref)=@_;return sub {my ($in_ref,$out_ref)=@_;return input_avail && do {$$string_ref .= $$in_ref;$$in_ref='';1}}}sub io {require IPC::Run::IO;IPC::Run::IO->new(@_)}sub timer;*timer=\&IPC::Run::Timer::timer;sub timeout;*timeout=\&IPC::Run::Timer::timeout;sub input_avail() {confess "Undefined FBUF ref for $filter_num+1" unless defined$filter_op->{FBUFS}->[$filter_num+1];length ${$filter_op->{FBUFS}->[$filter_num+1]}|| get_more_input}sub get_more_input() {++$filter_num;my$r=eval {confess "get_more_input() called and no more filters in chain" unless defined$filter_op->{FILTERS}->[$filter_num];$filter_op->{FILTERS}->[$filter_num]->($filter_op->{FBUFS}->[$filter_num+1],$filter_op->{FBUFS}->[$filter_num],)};--$filter_num;die $@ if $@;return$r}1;
IPC_RUN

$fatpacked{"IPC/Run/Debug.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IPC_RUN_DEBUG';
  package IPC::Run::Debug;use strict;use Exporter;use vars qw{$VERSION @ISA @EXPORT @EXPORT_OK %EXPORT_TAGS};BEGIN {$VERSION='0.90';@ISA=qw(Exporter);@EXPORT=qw(_debug _debug_desc_fd _debugging _debugging_data _debugging_details _debugging_gory_details _debugging_not_optimized _set_child_debug_name);@EXPORT_OK=qw(_debug_init _debugging_level _map_fds);%EXPORT_TAGS=(default=>\@EXPORT,all=>[@EXPORT,@EXPORT_OK ],)}my$disable_debugging=defined$ENV{IPCRUNDEBUG}&& (!$ENV{IPCRUNDEBUG}|| lc$ENV{IPCRUNDEBUG}eq "none");eval($disable_debugging ? <<'STUBS' : <<'SUBS')or die $@;
  sub _map_fds()                 { "" }
  sub _debug                     {}
  sub _debug_desc_fd             {}
  sub _debug_init                {}
  sub _set_child_debug_name      {}
  sub _debugging()               { 0 }
  sub _debugging_level()         { 0 }
  sub _debugging_data()          { 0 }
  sub _debugging_details()       { 0 }
  sub _debugging_gory_details()  { 0 }
  sub _debugging_not_optimized() { 0 }
  
  1;
  STUBS
  
  use POSIX;
  
  sub _map_fds {
     my $map = '';
     my $digit = 0;
     my $in_use;
     my $dummy;
     for my $fd (0..63) {
        ## I'd like a quicker way (less user, cpu & expecially sys and kernal
        ## calls) to detect open file descriptors.  Let me know...
        ## Hmmm, could do a 0 length read and check for bad file descriptor...
        ## but that segfaults on Win32
        my $test_fd = POSIX::dup( $fd );
        $in_use = defined $test_fd;
        POSIX::close $test_fd if $in_use;
        $map .= $in_use ? $digit : '-';
        $digit = 0 if ++$digit > 9;
     }
     warn "No fds open???" unless $map =~ /\d/;
     $map =~ s/(.{1,12})-*$/$1/;
     return $map;
  }
  
  use vars qw( $parent_pid );
  
  $parent_pid = $$;
  
  ## TODO: move debugging to it's own module and make it compile-time
  ## optimizable.
  
  ## Give kid process debugging nice names
  my $debug_name;
  
  sub _set_child_debug_name {
     $debug_name = shift;
  }
  
  ## There's a bit of hackery going on here.
  ##
  ## We want to have any code anywhere be able to emit
  ## debugging statements without knowing what harness the code is
  ## being called in/from, since we'd need to pass a harness around to
  ## everything.
  ##
  ## Thus, $cur_self was born.
  #
  my %debug_levels = (
     none    => 0,
     basic   => 1,
     data    => 2,
     details => 3,
     gore           => 4,
     gory_details   => 4,
     "gory details" => 4,
     gory           => 4,
     gorydetails    => 4,
     all     => 10,
     notopt  => 0,
  );
  
  my $warned;
  
  sub _debugging_level() {
     my $level = 0;
  
     $level = $IPC::Run::cur_self->{debug} || 0
        if $IPC::Run::cur_self
           && ( $IPC::Run::cur_self->{debug} || 0 ) >= $level;
  
     if ( defined $ENV{IPCRUNDEBUG} ) {
        my $v = $ENV{IPCRUNDEBUG};
        $v = $debug_levels{lc $v} if $v =~ /[a-zA-Z]/;
        unless ( defined $v ) {
  	 $warned ||= warn "Unknown debug level $ENV{IPCRUNDEBUG}, assuming 'basic' (1)\n";
  	 $v = 1;
        }
        $level = $v if $v > $level;
     }
     return $level;
  }
  
  sub _debugging_atleast($) {
     my $min_level = shift || 1;
  
     my $level = _debugging_level;
     
     return $level >= $min_level ? $level : 0;
  }
  
  sub _debugging()               { _debugging_atleast 1 }
  sub _debugging_data()          { _debugging_atleast 2 }
  sub _debugging_details()       { _debugging_atleast 3 }
  sub _debugging_gory_details()  { _debugging_atleast 4 }
  sub _debugging_not_optimized() { ( $ENV{IPCRUNDEBUG} || "" ) eq "notopt" }
  
  sub _debug_init {
     ## This routine is called only in spawned children to fake out the
     ## debug routines so they'll emit debugging info.
     $IPC::Run::cur_self = {};
     (  $parent_pid,
        $^T, 
        $IPC::Run::cur_self->{debug}, 
        $IPC::Run::cur_self->{DEBUG_FD}, 
        $debug_name 
     ) = @_;
  }
  
  
  sub _debug {
  #   return unless _debugging || _debugging_not_optimized;
  
     my $fd = defined &IPC::Run::_debug_fd
        ? IPC::Run::_debug_fd()
        : fileno STDERR;
  
     my $s;
     my $debug_id;
     $debug_id = join( 
        " ",
        join(
           "",
           defined $IPC::Run::cur_self ? "#$IPC::Run::cur_self->{ID}" : (),
           "($$)",
        ),
        defined $debug_name && length $debug_name ? $debug_name        : (),
     );
     my $prefix = join(
        "",
        "IPC::Run",
        sprintf( " %04d", time - $^T ),
        ( _debugging_details ? ( " ", _map_fds ) : () ),
        length $debug_id ? ( " [", $debug_id, "]" ) : (),
        ": ",
     );
  
     my $msg = join( '', map defined $_ ? $_ : "<undef>", @_ );
     chomp $msg;
     $msg =~ s{^}{$prefix}gm;
     $msg .= "\n";
     POSIX::write( $fd, $msg, length $msg );
  }
  
  
  my @fd_descs = ( 'stdin', 'stdout', 'stderr' );
  
  sub _debug_desc_fd {
     return unless _debugging;
     my $text = shift;
     my $op = pop;
     my $kid = $_[0];
  
  Carp::carp join " ", caller(0), $text, $op  if defined $op  && UNIVERSAL::isa( $op, "IO::Pty" );
  
     _debug(
        $text,
        ' ',
        ( defined $op->{FD}
           ? $op->{FD} < 3
              ? ( $fd_descs[$op->{FD}] )
              : ( 'fd ', $op->{FD} )
           : $op->{FD}
        ),
        ( defined $op->{KFD}
           ? (
              ' (kid',
              ( defined $kid ? ( ' ', $kid->{NUM}, ) : () ),
              "'s ",
              ( $op->{KFD} < 3
                 ? $fd_descs[$op->{KFD}]
                 : defined $kid
                    && defined $kid->{DEBUG_FD}
                    && $op->{KFD} == $kid->{DEBUG_FD}
                    ? ( 'debug (', $op->{KFD}, ')' )
                    : ( 'fd ', $op->{KFD} )
              ),
              ')',
           )
           : ()
        ),
     );
  }
  
  1;
  
  SUBS
IPC_RUN_DEBUG

$fatpacked{"IPC/Run/IO.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IPC_RUN_IO';
  package IPC::Run::IO;use strict;use Carp;use Fcntl;use Symbol;use IPC::Run::Debug;use IPC::Run qw(Win32_MODE);use vars qw{$VERSION};BEGIN {$VERSION='0.90';if (Win32_MODE){eval "use IPC::Run::Win32Helper; require IPC::Run::Win32IO; 1" or ($@ && die)or die "$!"}}sub _empty($);*_empty=\&IPC::Run::_empty;sub new {my$class=shift;$class=ref$class || $class;my ($external,$type,$internal)=(shift,shift,pop);croak "$class: '$_' is not a valid I/O operator" unless$type =~ /^(?:<<?|>>?)$/;my IPC::Run::IO$self=$class->_new_internal($type,undef,undef,$internal,undef,@_);if (!ref$external){$self->{FILENAME}=$external}elsif (ref eq 'GLOB' || UNIVERSAL::isa($external,'IO::Handle')){$self->{HANDLE}=$external;$self->{DONT_CLOSE}=1}else {croak "$class: cannot accept " .ref($external)." to do I/O with"}return$self}sub _new_internal {my$class=shift;$class=ref$class || $class;$class="IPC::Run::Win32IO" if Win32_MODE && $class eq "IPC::Run::IO";my IPC::Run::IO$self;$self=bless {},$class;my ($type,$kfd,$pty_id,$internal,$binmode,@filters)=@_;$self->{TYPE}=$type;$self->{KFD}=$kfd;$self->{PTY_ID}=$pty_id;$self->binmode($binmode);$self->{FILTERS}=[@filters ];if ($self->op =~ />/){croak "'$_' missing a destination" if _empty$internal;$self->{DEST}=$internal;if (UNIVERSAL::isa($self->{DEST},'CODE')){unshift(@{$self->{FILTERS}},sub {my ($in_ref)=@_;return IPC::Run::input_avail()&& do {$self->{DEST}->($$in_ref);$$in_ref='';1}})}}else {croak "'$_' missing a source" if _empty$internal;$self->{SOURCE}=$internal;if (UNIVERSAL::isa($internal,'CODE')){push(@{$self->{FILTERS}},sub {my ($in_ref,$out_ref)=@_;return 0 if length $$out_ref;return undef if$self->{SOURCE_EMPTY};my$in=$internal->();unless (defined$in){$self->{SOURCE_EMPTY}=1;return undef}return 0 unless length$in;$$out_ref=$in;return 1})}elsif (UNIVERSAL::isa($internal,'SCALAR')){push(@{$self->{FILTERS}},sub {my ($in_ref,$out_ref)=@_;return 0 if length $$out_ref;return$self->{HARNESS}->{auto_close_ins}? undef : 0 if IPC::Run::_empty ${$self->{SOURCE}}|| $self->{SOURCE_EMPTY};$$out_ref=$$internal;eval {$$internal=''}if$self->{HARNESS}->{clear_ins};$self->{SOURCE_EMPTY}=$self->{HARNESS}->{auto_close_ins};return 1})}}return$self}sub filename {my IPC::Run::IO$self=shift;$self->{FILENAME}=shift if @_;return$self->{FILENAME}}sub init {my IPC::Run::IO$self=shift;$self->{SOURCE_EMPTY}=0;${$self->{DEST}}='' if$self->mode =~ /r/ && ref$self->{DEST}eq 'SCALAR';$self->open if defined$self->filename;$self->{FD}=$self->fileno;if (!$self->{FILTERS}){$self->{FBUFS}=undef}else {@{$self->{FBUFS}}=map {my$s="";\$s}(@{$self->{FILTERS}},'');$self->{FBUFS}->[0]=$self->{DEST}if$self->{DEST}&& ref$self->{DEST}eq 'SCALAR';push @{$self->{FBUFS}},$self->{SOURCE}}return undef}my%open_flags=('>'=>O_RDONLY,'>>'=>O_RDONLY,'<'=>O_WRONLY | O_CREAT | O_TRUNC,'<<'=>O_WRONLY | O_CREAT | O_APPEND,);sub open {my IPC::Run::IO$self=shift;croak "IPC::Run::IO: Can't open() a file with no name" unless defined$self->{FILENAME};$self->{HANDLE}=gensym unless$self->{HANDLE};_debug "opening '",$self->filename,"' mode '",$self->mode,"'" if _debugging_data;sysopen($self->{HANDLE},$self->filename,$open_flags{$self->op},)or croak "IPC::Run::IO: $! opening '$self->{FILENAME}', mode '" .$self->mode ."'";return undef}sub _do_open {my$self=shift;my ($child_debug_fd,$parent_handle)=@_;if ($self->dir eq "<"){($self->{TFD},$self->{FD})=IPC::Run::_pipe_nb;if ($parent_handle){CORE::open$parent_handle,">&=$self->{FD}" or croak "$! duping write end of pipe for caller"}}else {($self->{FD},$self->{TFD})=IPC::Run::_pipe;if ($parent_handle){CORE::open$parent_handle,"<&=$self->{FD}" or croak "$! duping read end of pipe for caller"}}}sub open_pipe {my IPC::Run::IO$self=shift;croak "IPC::Run::IO: Can't pipe() when a file name has been set" if defined$self->{FILENAME};$self->_do_open(@_);return$self->dir eq "<" ? ($self->{TFD},$self->{FD}): ($self->{FD},$self->{TFD})}sub _cleanup {my$self=shift;undef$self->{FAKE_PIPE}}sub close {my IPC::Run::IO$self=shift;if (defined$self->{HANDLE}){close$self->{HANDLE}or croak("IPC::Run::IO: $! closing " .(defined$self->{FILENAME}? "'$self->{FILENAME}'" : "handle"))}else {IPC::Run::_close($self->{FD})}$self->{FD}=undef;return undef}sub fileno {my IPC::Run::IO$self=shift;my$fd=fileno$self->{HANDLE};croak("IPC::Run::IO: $! " .(defined$self->{FILENAME}? "'$self->{FILENAME}'" : "handle"))unless defined$fd;return$fd}sub mode {my IPC::Run::IO$self=shift;croak "IPC::Run::IO: unexpected arguments for mode(): @_" if @_;return ($self->{TYPE}=~ /</ ? 'w' : 'r').($self->{TYPE}=~ /<<|>>/ ? 'a' : '')}sub op {my IPC::Run::IO$self=shift;croak "IPC::Run::IO: unexpected arguments for op(): @_" if @_;return$self->{TYPE}}sub binmode {my IPC::Run::IO$self=shift;$self->{BINMODE}=shift if @_;return$self->{BINMODE}}sub dir {my IPC::Run::IO$self=shift;croak "IPC::Run::IO: unexpected arguments for dir(): @_" if @_;return substr$self->{TYPE},0,1}use vars ('$filter_op','$filter_num');sub _init_filters {my IPC::Run::IO$self=shift;confess "\$self not an IPC::Run::IO" unless UNIVERSAL::isa($self,"IPC::Run::IO");$self->{FBUFS}=[];$self->{FBUFS}->[0]=$self->{DEST}if$self->{DEST}&& ref$self->{DEST}eq 'SCALAR';return unless$self->{FILTERS}&& @{$self->{FILTERS}};push @{$self->{FBUFS}},map {my$s="";\$s}(@{$self->{FILTERS}},'');push @{$self->{FBUFS}},$self->{SOURCE}}sub poll {my IPC::Run::IO$self=shift;my ($harness)=@_;if (defined$self->{FD}){my$d=$self->dir;if ($d eq "<"){if (vec$harness->{WOUT},$self->{FD},1){_debug_desc_fd("filtering data to",$self)if _debugging_details;return$self->_do_filters($harness)}}elsif ($d eq ">"){if (vec$harness->{ROUT},$self->{FD},1){_debug_desc_fd("filtering data from",$self)if _debugging_details;return$self->_do_filters($harness)}}}return 0}sub _do_filters {my IPC::Run::IO$self=shift;($self->{HARNESS})=@_;my ($saved_op,$saved_num)=($IPC::Run::filter_op,$IPC::Run::filter_num);$IPC::Run::filter_op=$self;$IPC::Run::filter_num=-1;my$redos=0;my$r;{$@='';$r=eval {IPC::Run::get_more_input()};if(($@||'')=~ $IPC::Run::_EAGAIN && $redos++ < 200){select(undef,undef,undef,0.01);redo}}($IPC::Run::filter_op,$IPC::Run::filter_num)=($saved_op,$saved_num);$self->{HARNESS}=undef;die "ack ",$@ if $@;return$r}1;
IPC_RUN_IO

$fatpacked{"IPC/Run/Timer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IPC_RUN_TIMER';
  package IPC::Run::Timer;use strict;use Carp;use Fcntl;use Symbol;use Exporter;use vars qw($VERSION @ISA @EXPORT_OK %EXPORT_TAGS);BEGIN {$VERSION='0.90';@ISA=qw(Exporter);@EXPORT_OK=qw(check end_time exception expire interval is_expired is_reset is_running name reset start timeout timer);%EXPORT_TAGS=('all'=>\@EXPORT_OK)}require IPC::Run;use IPC::Run::Debug;my$resolution=1;sub _parse_time {for ($_[0]){return $_ unless defined $_;return $_ if /^\d*(?:\.\d*)?$/;my@f=reverse split(/[^\d\.]+/i);croak "IPC::Run: invalid time string '$_'" unless@f <= 4;my ($s,$m,$h,$d)=@f;return ((($d || 0)* 24 + ($h || 0))* 60 + ($m || 0))* 60 + ($s || 0)}}sub _calc_end_time {my IPC::Run::Timer$self=shift;my$interval=$self->interval;$interval += $resolution if$interval;$self->end_time($self->start_time + $interval)}sub timer {return IPC::Run::Timer->new(@_)}sub timeout {my$t=IPC::Run::Timer->new(@_);$t->exception("IPC::Run: timeout on " .$t->name)unless defined$t->exception;return$t}my$timer_counter;sub new {my$class=shift;$class=ref$class || $class;my IPC::Run::Timer$self=bless {},$class;$self->{STATE}=0;$self->{DEBUG}=0;$self->{NAME}="timer #" .++$timer_counter;while (@_){my$arg=shift;if ($arg =~ /^(?:\d+[^\a\d]){0,3}\d*(?:\.\d*)?$/){$self->interval($arg)}elsif ($arg eq 'exception'){$self->exception(shift)}elsif ($arg eq 'name'){$self->name(shift)}elsif ($arg eq 'debug'){$self->debug(shift)}else {croak "IPC::Run: unexpected parameter '$arg'"}}_debug$self->name .' constructed' if$self->{DEBUG}|| _debugging_details;return$self}sub check {my IPC::Run::Timer$self=shift;return undef if!$self->is_running;return 0 if$self->is_expired;my ($now)=@_;$now=_parse_time($now);$now=time unless defined$now;_debug("checking ",$self->name," (end time ",$self->end_time,") at ",$now)if$self->{DEBUG}|| _debugging_details;my$left=$self->end_time - $now;return$left if$left > 0;$self->expire;return 0}sub debug {my IPC::Run::Timer$self=shift;$self->{DEBUG}=shift if @_;return$self->{DEBUG}}sub end_time {my IPC::Run::Timer$self=shift;if (@_){$self->{END_TIME}=shift;_debug$self->name,' end_time set to ',$self->{END_TIME}if$self->{DEBUG}> 2 || _debugging_details}return$self->{END_TIME}}sub exception {my IPC::Run::Timer$self=shift;if (@_){$self->{EXCEPTION}=shift;_debug$self->name,' exception set to ',$self->{EXCEPTION}if$self->{DEBUG}|| _debugging_details}return$self->{EXCEPTION}}sub interval {my IPC::Run::Timer$self=shift;if (@_){$self->{INTERVAL}=_parse_time(shift);_debug$self->name,' interval set to ',$self->{INTERVAL}if$self->{DEBUG}> 2 || _debugging_details;$self->_calc_end_time if$self->state}return$self->{INTERVAL}}sub expire {my IPC::Run::Timer$self=shift;if (defined$self->state){_debug$self->name .' expired' if$self->{DEBUG}|| _debugging;$self->state(undef);croak$self->exception if$self->exception}return undef}sub is_running {my IPC::Run::Timer$self=shift;return$self->state ? 1 : 0}sub is_reset {my IPC::Run::Timer$self=shift;return defined$self->state && $self->state==0}sub is_expired {my IPC::Run::Timer$self=shift;return!defined$self->state}sub name {my IPC::Run::Timer$self=shift;$self->{NAME}=shift if @_;return defined$self->{NAME}? $self->{NAME}: defined$self->{EXCEPTION}? 'timeout' : 'timer'}sub reset {my IPC::Run::Timer$self=shift;$self->state(0);$self->end_time(undef);_debug$self->name .' reset' if$self->{DEBUG}|| _debugging;return undef}sub start {my IPC::Run::Timer$self=shift;my ($interval,$now)=map {_parse_time($_)}@_;$now=_parse_time($now);$now=time unless defined$now;$self->interval($interval)if defined$interval;$self->end_time(undef)if!$self->is_reset || $interval;croak "IPC::Run: no timer interval or end_time defined for " .$self->name unless defined$self->interval || defined$self->end_time;$self->state(1);$self->start_time($now);$self->_calc_end_time unless defined$self->end_time;_debug($self->name," started at ",$self->start_time,", with interval ",$self->interval,", end_time ",$self->end_time)if$self->{DEBUG}|| _debugging;return undef}sub start_time {my IPC::Run::Timer$self=shift;if (@_){$self->{START_TIME}=_parse_time(shift);_debug$self->name,' start_time set to ',$self->{START_TIME}if$self->{DEBUG}> 2 || _debugging}return$self->{START_TIME}}sub state {my IPC::Run::Timer$self=shift;if (@_){$self->{STATE}=shift;_debug$self->name,' state set to ',$self->{STATE}if$self->{DEBUG}> 2 || _debugging}return$self->{STATE}}1;
IPC_RUN_TIMER

$fatpacked{"Net/Server.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NET_SERVER';
  package Net::Server;use strict;use Socket qw(AF_INET AF_UNIX SOCK_DGRAM SOCK_STREAM);use IO::Socket ();use IO::Select ();use POSIX ();use Net::Server::Proto ();use Net::Server::Daemonize qw(check_pid_file create_pid_file safe_fork get_uid get_gid set_uid set_gid);our$VERSION='2.009';sub new {my$class=shift || die "Missing class";my$args=@_==1 ? shift : {@_};return bless {server=>{%$args}},$class}sub net_server_type {__PACKAGE__}sub get_property {$_[0]->{'server'}->{$_[1]}}sub set_property {$_[0]->{'server'}->{$_[1]}=$_[2]}sub run {my$self=ref($_[0])? shift(): shift->new;$self->{'server'}->{'_run_args'}=[@_==1 ? %{$_[0]}: @_];$self->_initialize;$self->post_configure;$self->post_configure_hook;$self->pre_bind;$self->bind;$self->post_bind_hook;$self->post_bind;$self->pre_loop_hook;$self->loop;$self->server_close}sub run_client_connection {my$self=shift;my$c=$self->{'server'}->{'client'};$self->post_accept($c);$self->get_client_info($c);$self->post_accept_hook($c);my$ok=$self->allow_deny($c)&& $self->allow_deny_hook($c);if ($ok){$self->process_request($c)}else {$self->request_denied_hook($c)}$self->post_process_request_hook($ok);$self->post_process_request;$self->post_client_connection_hook}sub _initialize {my$self=shift;my$prop=$self->{'server'}||={};$self->commandline($self->_get_commandline)if!eval {$self->commandline};$self->configure_hook;$self->configure;my@defaults=%{$self->default_values || {}};$self->process_args(\@defaults)if@defaults}sub commandline {my$self=shift;$self->{'server'}->{'commandline'}=ref($_[0])? shift : \@_ if @_;return$self->{'server'}->{'commandline'}|| die "commandline was not set during initialization"}sub _get_commandline {my$self=shift;my$script=$0;$script=$ENV{'PWD'}.'/'.$script if$script =~ m|^[^/]+/| && $ENV{'PWD'};$script =~ /^(.+)$/;return [$1,@ARGV]}sub configure_hook {}sub configure {my$self=shift;my$prop=$self->{'server'};my$template=($_[0]&& ref($_[0]))? shift : undef;$self->process_args(\@ARGV,$template)if@ARGV;$self->process_args($prop->{'_run_args'},$template)if$prop->{'_run_args'};if ($prop->{'conf_file'}){$self->process_args($self->_read_conf($prop->{'conf_file'}),$template)}else {my$def=$self->default_values || {};$self->process_args($self->_read_conf($def->{'conf_file'}),$template)if$def->{'conf_file'}}}sub default_values {{}}sub post_configure {my$self=shift;my$prop=$self->{'server'};$prop->{'log_level'}=2 if!defined($prop->{'log_level'})|| $prop->{'log_level'}!~ /^\d+$/;$prop->{'log_level'}=4 if$prop->{'log_level'}> 4;$self->initialize_logging;if ($prop->{'pid_file'}){if (!eval{check_pid_file($prop->{'pid_file'})}){warn $@ if!$ENV{'BOUND_SOCKETS'};$self->fatal(my$e=$@)}}if (!$prop->{'_is_inet'}){if ($prop->{'setsid'}|| length($prop->{'log_file'})){open(STDIN,'<','/dev/null')|| die "Cannot read /dev/null  [$!]";open(STDOUT,'>','/dev/null')|| die "Cannot write /dev/null [$!]"}}if (!$ENV{'BOUND_SOCKETS'}){if ($prop->{'setsid'}|| $prop->{'background'}){my$pid=eval {safe_fork()};$self->fatal(my$e=$@)if!defined$pid;exit(0)if$pid;$self->log(2,"Process Backgrounded")}POSIX::setsid()if$prop->{'setsid'}}if (length($prop->{'log_file'})&&!$prop->{'log_function'}){open STDERR,'>&_SERVER_LOG' || die "Cannot open STDERR to _SERVER_LOG [$!]"}elsif ($prop->{'setsid'}){open STDERR,'>&STDOUT' || die "Cannot open STDERR to STDOUT [$!]"}if ($prop->{'pid_file'}){if (eval {create_pid_file($prop->{'pid_file'})}){$prop->{'pid_file_unlink'}=1}else {$self->fatal(my$e=$@)}}$prop->{$_}=[]for grep {!ref$prop->{$_}}qw(allow deny cidr_allow cidr_deny)}sub initialize_logging {my$self=shift;my$prop=$self->{'server'};if (!defined($prop->{'log_file'})){$prop->{'log_file'}='';return}if ($prop->{'log_file'}=~ /^([a-zA-Z]\w*(?:::[a-zA-Z]\w*)*)$/){my$pkg="Net::Server::Log::$prop->{'log_file'}";(my$file="$pkg.pm")=~ s|::|/|g;if (eval {require$file}){$prop->{'log_function'}=$pkg->initialize($self);$prop->{'log_class'}=$pkg;return}elsif ($file =~ /::/ || grep {-e "$_/$file"}@INC){$self->fatal("Unable to load log module $pkg from file $file: $@")}}die "Unsecure filename \"$prop->{'log_file'}\"" if$prop->{'log_file'}!~ m|^([\:\w\.\-/\\]+)$|;$prop->{'log_file'}=$1;open(_SERVER_LOG,">>",$prop->{'log_file'})|| die "Couldn't open log file \"$prop->{'log_file'}\" [$!].";_SERVER_LOG->autoflush(1);push @{$prop->{'chown_files'}},$prop->{'log_file'}}sub post_configure_hook {}sub _server_type {ref($_[0])}sub pre_bind {my$self=shift;my$prop=$self->{'server'};my$super=$self->net_server_type;my$type=$self->_server_type;if ($self->isa('Net::Server::MultiType')){my$base=delete($prop->{'_recursive_multitype'})|| Net::Server::MultiType->net_server_type;$super="$super -> MultiType -> $base"}$type .= " (type $super)" if$type ne $super;$self->log(2,$self->log_time ." $type starting! pid($$)");$prop->{'sock'}=[grep {$_}map {$self->proto_object($_)}@{$self->prepared_ports}];$self->fatal("No valid socket parameters found")if!@{$prop->{'sock'}}}sub prepared_ports {my$self=shift;my$prop=$self->{'server'};my ($ports,$hosts,$protos,$ipvs)=@$prop{qw(port host proto ipv)};$ports ||=$prop->{'ports'};if (!defined($ports)|| (ref($ports)&&!@$ports)){$ports=$self->default_port;if (!defined($ports)|| (ref($ports)&&!@$ports)){$ports=default_port();$self->log(2,"Port Not Defined.  Defaulting to '$ports'")}}my%bound;my$bind=$prop->{'_bind'}=[];for my$_port (ref($ports)? @$ports : $ports){my$_host=ref($hosts)? $hosts->[@$bind >= @$hosts ? -1 : $#$bind + 1]: $hosts;my$_proto=ref($protos)? $protos->[@$bind >= @$protos ? -1 : $#$bind + 1]: $protos;my$_ipv=ref($ipvs)? $ipvs->[@$bind >= @$ipvs ? -1 : $#$bind + 1]: $ipvs;for my$info ($self->port_info($_port,$_host,$_proto,$_ipv)){my ($port,$host,$proto,$ipv)=@$info{qw(port host proto ipv)};if ($port ne "0" && $bound{"$host\e$port\e$proto\e$ipv"}++){$self->log(2,"Duplicate configuration (\U$proto\E) on [$host]:$port with IPv$ipv) - skipping");next}push @$bind,$info}}return$bind}sub port_info {my ($self,$port,$host,$proto,$ipv)=@_;return Net::Server::Proto->parse_info($port,$host,$proto,$ipv,$self)}sub proto_object {my ($self,$info)=@_;return Net::Server::Proto->object($info,$self)}sub bind {my$self=shift;my$prop=$self->{'server'};if (exists$ENV{'BOUND_SOCKETS'}){$self->restart_open_hook;$self->log(2,"Binding open file descriptors");my%map;for my$info (split /\s*;\s*/,$ENV{'BOUND_SOCKETS'}){my ($fd,$host,$port,$proto,$ipv,$orig)=split /\|/,$info;$orig=$port if!defined$orig;$fd=($fd =~ /^(\d+)$/)? $1 : $self->fatal("Bad file descriptor");$map{"$host|$orig|$proto|$ipv"}->{$fd}=$port}for my$sock (@{$prop->{'sock'}}){$sock->log_connect($self);if (my$ref=$map{$sock->hup_string}){my ($fd,$port)=each %$ref;$sock->reconnect($fd,$self,$port);delete$ref->{$fd};delete$map{$sock->hup_string}if!keys %$ref}else {$self->log(2,"Added new port configuration");$sock->connect($self)}}for my$str (keys%map){for my$fd (keys %{$map{$str}}){$self->log(2,"Closing un-mapped port ($str) on fd $fd");POSIX::close($fd)}}delete$ENV{'BOUND_SOCKETS'};$self->{'hup_waitpid'}=1}else {for my$sock (@{$prop->{'sock'}}){$sock->log_connect($self);$sock->connect($self)}}if (@{$prop->{'sock'}}> 1 || $prop->{'multi_port'}){$prop->{'multi_port'}=1;$prop->{'select'}=IO::Select->new;$prop->{'select'}->add($_)for @{$prop->{'sock'}}}else {$prop->{'multi_port'}=undef;$prop->{'select'}=undef}}sub post_bind_hook {}sub post_bind {my$self=shift;my$prop=$self->{'server'};if (!defined$prop->{'group'}){$self->log(1,"Group Not Defined.  Defaulting to EGID '$)'");$prop->{'group'}=$)}elsif ($prop->{'group'}=~ /^([\w-]+(?: [\w-]+)*)$/){$prop->{'group'}=eval {get_gid($1)};$self->fatal(my$e=$@)if $@}else {$self->fatal("Invalid group \"$prop->{'group'}\"")}if (!defined$prop->{'user'}){$self->log(1,"User Not Defined.  Defaulting to EUID '$>'");$prop->{'user'}=$>}elsif ($prop->{'user'}=~ /^([\w-]+)$/){$prop->{'user'}=eval {get_uid($1)};$self->fatal(my$e=$@)if $@}else {$self->fatal("Invalid user \"$prop->{'user'}\"")}if ($prop->{'group'}ne $) || $prop->{'user'}ne $>){my@chown_files;push@chown_files,map {$_->NS_port}grep {$_->NS_proto =~ /^UNIX/}@{$prop->{'sock'}};push@chown_files,$prop->{'pid_file'}if$prop->{'pid_file_unlink'};push@chown_files,$prop->{'lock_file'}if$prop->{'lock_file_unlink'};push@chown_files,@{$prop->{'chown_files'}|| []};my$uid=$prop->{'user'};my$gid=(split /\ /,$prop->{'group'})[0];for my$file (@chown_files){chown($uid,$gid,$file)|| $self->fatal("Couldn't chown \"$file\" [$!]")}}if ($prop->{'chroot'}){$self->fatal("Specified chroot \"$prop->{'chroot'}\" doesn't exist.")if!-d $prop->{'chroot'};$self->log(2,"Chrooting to $prop->{'chroot'}");chroot($prop->{'chroot'})|| $self->fatal("Couldn't chroot to \"$prop->{'chroot'}\": $!")}eval {if ($prop->{'group'}ne $)){$self->log(2,"Setting gid to \"$prop->{'group'}\"");set_gid($prop->{'group'})}if ($prop->{'user'}ne $>){$self->log(2,"Setting uid to \"$prop->{'user'}\"");set_uid($prop->{'user'})}};if ($@){if ($>==0){$self->fatal(my$e=$@)}elsif ($<==0){$self->log(2,"NOTICE: Effective UID changed, but Real UID is 0: $@")}else {$self->log(2,my$e=$@)}}$prop->{'requests'}=0;$SIG{'INT'}=$SIG{'TERM'}=$SIG{'QUIT'}=sub {$self->server_close};$SIG{'PIPE'}='IGNORE';$SIG{'CHLD'}=\&sig_chld;$SIG{'HUP'}=sub {$self->sig_hup}}sub sig_chld {1 while waitpid(-1,POSIX::WNOHANG())> 0;$SIG{'CHLD'}=\&sig_chld}sub pre_loop_hook {}sub loop {my$self=shift;while ($self->accept){$self->run_client_connection;last if$self->done}}sub accept {my$self=shift;my$prop=$self->{'server'};my$sock=undef;my$retries=30;while ($retries--){if ($prop->{'multi_port'}){return 0 if$prop->{'_HUP'};$sock=$self->accept_multi_port || next;return 0 if$prop->{'_HUP'};if ($self->can_read_hook($sock)){$retries++;next}}else {$sock=$prop->{'sock'}->[0]}$self->fatal("Received a bad sock!")if!defined$sock;if (SOCK_DGRAM==$sock->getsockopt(Socket::SOL_SOCKET(),Socket::SO_TYPE())){$prop->{'client'}=$sock;$prop->{'udp_true'}=1;$prop->{'udp_peer'}=$sock->recv($prop->{'udp_data'},$sock->NS_recv_len,$sock->NS_recv_flags)}else {delete$prop->{'udp_true'};$prop->{'client'}=$sock->accept()}return 0 if$prop->{'_HUP'};return 1 if$prop->{'client'};$self->log(2,"Accept failed with $retries tries left: $!");sleep(1)}$self->log(1,"Ran out of accept retries!");return undef}sub accept_multi_port {my@waiting=shift->{'server'}->{'select'}->can_read();return undef if!@waiting;return$waiting[rand@waiting]}sub can_read_hook {}sub post_accept {my$self=shift;my$prop=$self->{'server'};my$client=shift || $prop->{'client'};$prop->{'requests'}++;return if$prop->{'udp_true'};if (!$client){$self->log(1,"Client socket information could not be determined!");return}$client->post_accept()if$client->can("post_accept");if (!$prop->{'no_client_stdout'}){close STDIN;close STDOUT;if ($prop->{'tie_client_stdout'}|| ($client->can('tie_stdout')&& $client->tie_stdout)){open STDIN,'<','/dev/null' or die "Couldn't open STDIN to the client socket: $!";open STDOUT,'>','/dev/null' or die "Couldn't open STDOUT to the client socket: $!";tie*STDOUT,'Net::Server::TiedHandle',$client,$prop->{'tied_stdout_callback'}or die "Couldn't tie STDOUT: $!";tie*STDIN,'Net::Server::TiedHandle',$client,$prop->{'tied_stdin_callback'}or die "Couldn't tie STDIN: $!"}elsif (defined(my$fileno=fileno$prop->{'client'})){open STDIN,'<&',$fileno or die "Couldn't open STDIN to the client socket: $!";open STDOUT,'>&',$fileno or die "Couldn't open STDOUT to the client socket: $!"}else {*STDIN=\*{$client};*STDOUT=\*{$client}}STDIN->autoflush(1);STDOUT->autoflush(1);select STDOUT}}sub get_client_info {my$self=shift;my$prop=$self->{'server'};my$client=shift || $prop->{'client'};if ($client->NS_proto =~ /^UNIX/){delete @$prop{qw(sockaddr sockport peeraddr peerport peerhost)};$self->log(3,$self->log_time." CONNECT ".$client->NS_proto." Socket: \"".$client->NS_port."\"")if$prop->{'log_level'}&& 3 <= $prop->{'log_level'};return}if (my$sockname=$client->sockname){$prop->{'sockaddr'}=$client->sockhost;$prop->{'sockport'}=$client->sockport}else {@{$prop}{qw(sockaddr sockhost sockport)}=($ENV{'REMOTE_HOST'}|| '0.0.0.0','inet.test',0)}my$addr;if ($prop->{'udp_true'}){if ($client->sockdomain==AF_INET){($prop->{'peerport'},$addr)=Socket::sockaddr_in($prop->{'udp_peer'});$prop->{'peeraddr'}=Socket::inet_ntoa($addr)}else {($prop->{'peerport'},$addr)=Socket6::sockaddr_in6($prop->{'udp_peer'});$prop->{'peeraddr'}=Socket6->can('inet_ntop')? Socket6::inet_ntop($client->sockdomain,$addr): Socket::inet_ntoa($addr)}}elsif ($prop->{'peername'}=$client->peername){$addr=$client->peeraddr;$prop->{'peeraddr'}=$client->peerhost;$prop->{'peerport'}=$client->peerport}else {@{$prop}{qw(peeraddr peerhost peerport)}=('0.0.0.0','inet.test',0)}if ($addr && defined$prop->{'reverse_lookups'}){if ($INC{'Socket6.pm'}&& Socket6->can('getnameinfo')){my@res=Socket6::getnameinfo($addr,0);$prop->{'peerhost'}=$res[0]if@res > 1}else{$prop->{'peerhost'}=gethostbyaddr($addr,AF_INET)}}$self->log(3,$self->log_time ." CONNECT ".$client->NS_proto ." Peer: \"[$prop->{'peeraddr'}]:$prop->{'peerport'}\"" ." Local: \"[$prop->{'sockaddr'}]:$prop->{'sockport'}\"")if$prop->{'log_level'}&& 3 <= $prop->{'log_level'}}sub post_accept_hook {}sub allow_deny {my$self=shift;my$prop=$self->{'server'};my$sock=shift || $prop->{'client'};return 1 if$sock && $sock->NS_proto =~ /^UNIX/;return 1 if!@{$prop->{'allow'}}&&!@{$prop->{'deny'}}&&!@{$prop->{'cidr_allow'}}&&!@{$prop->{'cidr_deny'}};my$peeraddr=($prop->{'peeraddr'}=~ /^\s*::ffff:([0-9.]+\s*)$/)? $1 : $prop->{'peeraddr'};for (@{$prop->{'deny'}}){return 0 if$prop->{'reverse_lookups'}&& defined($prop->{'peerhost'})&& $prop->{'peerhost'}=~ /^$_$/;return 0 if$peeraddr =~ /^$_$/}if (@{$prop->{'cidr_deny'}}){require Net::CIDR;return 0 if Net::CIDR::cidrlookup($peeraddr,@{$prop->{'cidr_deny'}})}for (@{$prop->{'allow'}}){return 1 if$prop->{'reverse_lookups'}&& defined($prop->{'peerhost'})&& $prop->{'peerhost'}=~ /^$_$/;return 1 if$peeraddr =~ /^$_$/}if (@{$prop->{'cidr_allow'}}){require Net::CIDR;return 1 if Net::CIDR::cidrlookup($peeraddr,@{$prop->{'cidr_allow'}})}return 0}sub allow_deny_hook {1}sub request_denied_hook {}sub process_request {my$self=shift;my$prop=$self->{'server'};if ($prop->{'udp_true'}){my$client=shift || $prop->{'client'};if ($prop->{'udp_data'}=~ /dump/){require Data::Dumper;return$client->send(Data::Dumper::Dumper($self),0)}return$client->send("You said \"$prop->{'udp_data'}\"",0)}print "Welcome to \"".ref($self)."\" ($$)\015\012";my$previous_alarm=alarm 30;eval {local$SIG{'ALRM'}=sub {die "Timed Out!\n"};while (<STDIN>){s/[\r\n]+$//;print ref($self),":$$: You said \"$_\"\015\012";$self->log(5,$_);if (/get\s+(\w+)/){print "$1: $self->{'server'}->{$1}\015\012"}elsif (/dump/){require Data::Dumper;print Data::Dumper::Dumper($self)}elsif (/quit/){last}elsif (/exit/){$self->server_close}alarm 30}alarm($previous_alarm)};alarm 0;print "Timed Out.\015\012" if $@ eq "Timed Out!\n"}sub post_process_request_hook {}sub post_client_connection_hook {}sub post_process_request {my$self=shift;$self->close_client_stdout}sub close_client_stdout {my$self=shift;my$prop=$self->{'server'};return if$prop->{'udp_true'};if (!$prop->{'no_client_stdout'}){my$t=tied*STDOUT;if ($t){undef$t;untie*STDOUT};$t=tied*STDIN;if ($t){undef$t;untie*STDIN};open(STDIN,'<','/dev/null')|| die "Cannot read /dev/null  [$!]";open(STDOUT,'>','/dev/null')|| die "Cannot write /dev/null [$!]"}$prop->{'client'}->close}sub done {my$self=shift;$self->{'server'}->{'done'}=shift if @_;return$self->{'server'}->{'done'}}sub pre_fork_hook {}sub child_init_hook {}sub child_finish_hook {}sub run_dequeue {my$self=shift;$self->pre_fork_hook('dequeue');my$pid=fork;$self->fatal("Bad fork [$!]")if!defined$pid;if (!$pid){$SIG{'INT'}=$SIG{'TERM'}=$SIG{'QUIT'}=$SIG{'HUP'}=sub {$self->child_finish_hook('dequeue');exit};$SIG{'PIPE'}=$SIG{'TTIN'}=$SIG{'TTOU'}='DEFAULT';$self->child_init_hook('dequeue');$self->dequeue();$self->child_finish_hook('dequeue');exit}$self->log(4,"Running dequeue child $pid");$self->{'server'}->{'children'}->{$pid}->{'status'}='dequeue' if$self->{'server'}->{'children'}}sub default_port {20203}sub dequeue {}sub pre_server_close_hook {}sub server_close {my ($self,$exit_val)=@_;my$prop=$self->{'server'};$SIG{'INT'}='DEFAULT';if (defined($prop->{'ppid'})&& $prop->{'ppid'}!=$$ &&!defined($prop->{'no_close_by_child'})){$self->close_parent;exit}$self->pre_server_close_hook;$self->log(2,$self->log_time ." Server closing!");if ($prop->{'kind_quit'}&& $prop->{'children'}){$self->log(3,"Attempting a slow shutdown");$prop->{$_}=0 for qw(min_servers max_servers);$self->hup_children;while (1){Net::Server::SIG::check_sigs();$self->coordinate_children if$self->can('coordinate_children');last if!keys %{$self->{'server'}->{'children'}};sleep 1}}if ($prop->{'_HUP'}&& $prop->{'leave_children_open_on_hup'}){$self->hup_children}else {$self->close_children()if$prop->{'children'};$self->post_child_cleanup_hook}if (defined($prop->{'lock_file'})&& -e $prop->{'lock_file'}&& defined($prop->{'lock_file_unlink'})){unlink($prop->{'lock_file'})|| $self->log(1,"Couldn't unlink \"$prop->{'lock_file'}\" [$!]")}if (defined($prop->{'pid_file'})&& -e $prop->{'pid_file'}&&!$prop->{'_HUP'}&& defined($prop->{'pid_file_unlink'})){unlink($prop->{'pid_file'})|| $self->log(1,"Couldn't unlink \"$prop->{'pid_file'}\" [$!]")}if ($prop->{'_HUP'}){$self->restart_close_hook();$self->hup_server}$self->shutdown_sockets;return$self if$prop->{'no_exit_on_close'};$self->server_exit($exit_val)}sub server_exit {my ($self,$exit_val)=@_;exit($exit_val || 0)}sub shutdown_sockets {my$self=shift;my$prop=$self->{'server'};for my$sock (@{$prop->{'sock'}}){$sock->shutdown(2);unlink$sock->NS_port if$sock->NS_proto =~ /^UNIX/}$prop->{'sock'}=[];return 1}sub close_parent {my$self=shift;my$prop=$self->{'server'};die "Missing parent pid (ppid)" if!$prop->{'ppid'};kill 2,$prop->{'ppid'}}sub close_children {my$self=shift;my$prop=$self->{'server'};return unless$prop->{'children'}&& scalar keys %{$prop->{'children'}};for my$pid (keys %{$prop->{'children'}}){$self->log(4,"Kill TERM pid $pid");if (kill(15,$pid)||!kill(0,$pid)){$self->delete_child($pid)}}1 while waitpid(-1,POSIX::WNOHANG())> 0}sub is_prefork {0}sub hup_children {my$self=shift;my$prop=$self->{'server'};return unless defined$prop->{'children'}&& scalar keys %{$prop->{'children'}};return if!$self->is_prefork;$self->log(2,"Sending children hup signal");for my$pid (keys %{$prop->{'children'}}){$self->log(4,"Kill HUP pid $pid");kill(1,$pid)or $self->log(2,"Failed to kill pid $pid: $!")}}sub post_child_cleanup_hook {}sub sig_hup {my$self=shift;my$prop=$self->{'server'};$self->log(2,"Received a SIG HUP");my$i=0;my@fd;$prop->{'_HUP'}=[];for my$sock (@{$prop->{'sock'}}){my$fd=POSIX::dup($sock->fileno)|| $self->fatal("Cannot duplicate the socket [$!]");$prop->{'_HUP'}->[$i]=IO::Socket::INET->new;$prop->{'_HUP'}->[$i]->fdopen($fd,'w')|| $self->fatal("Cannot open to file descriptor [$!]");require Fcntl;$prop->{'_HUP'}->[$i]->fcntl(Fcntl::F_SETFD(),my$flags="");push@fd,$fd .'|'.$sock->hup_string;$sock->close();$i++}delete$prop->{'select'};$ENV{'BOUND_SOCKETS'}=join "; ",@fd;if ($prop->{'leave_children_open_on_hup'}&& scalar keys %{$prop->{'children'}}){$ENV{'HUP_CHILDREN'}=join "\n",map {"$_\t$prop->{'children'}->{$_}->{'status'}"}sort keys %{$prop->{'children'}}}}sub hup_server {my$self=shift;$self->log(0,$self->log_time()." Re-exec server during HUP");delete@ENV{$self->hup_delete_env_keys};exec @{$self->commandline}}sub hup_delete_env_keys {return qw(PATH)}sub restart_open_hook {}sub restart_close_hook {}sub fatal {my ($self,$error)=@_;my ($package,$file,$line)=caller;$self->fatal_hook($error,$package,$file,$line);$self->log(0,$self->log_time ." $error\n  at line $line in file $file");$self->server_close(1)}sub fatal_hook {}sub log {my ($self,$level,$msg,@therest)=@_;my$prop=$self->{'server'};return if!$prop->{'log_level'};return if$level =~ /^\d+$/ && $level > $prop->{'log_level'};$msg=sprintf($msg,@therest)if@therest;if ($prop->{'log_function'}){return if eval {$prop->{'log_function'}->($level,$msg);1};my$err=$@;if ($prop->{'log_class'}&& $prop->{'log_class'}->can('handle_error')){$prop->{'log_class'}->handle_log_error($self,$err,[$level,$msg])}else {$self->handle_log_error($err,[$level,$msg])}}return if$level !~ /^\d+$/;$self->write_to_log_hook($level,$msg)}sub handle_log_error {my ($self,$error)=@_;die$error}sub handle_syslog_error {&handle_log_error}sub write_to_log_hook {my ($self,$level,$msg)=@_;my$prop=$self->{'server'};chomp$msg;$msg =~ s/([^\n\ -\~])/sprintf("%%%02X",ord($1))/eg;if ($prop->{'log_file'}){print _SERVER_LOG$msg,"\n"}elsif ($prop->{'setsid'}){}else {my$old=select STDERR;print$msg."\n";select$old}}sub log_time {my ($sec,$min,$hour,$day,$mon,$year)=localtime;return sprintf "%04d/%02d/%02d-%02d:%02d:%02d",$year + 1900,$mon + 1,$day,$hour,$min,$sec}sub options {my$self=shift;my$ref=shift || {};my$prop=$self->{'server'};for (qw(port host proto ipv allow deny cidr_allow cidr_deny)){if (!defined$prop->{$_}){$prop->{$_}=[]}elsif (!ref$prop->{$_}){$prop->{$_}=[$prop->{$_}]}$ref->{$_}=$prop->{$_}}for (qw(conf_file user group chroot log_level log_file pid_file background setsid listen reverse_lookups no_close_by_child no_client_stdout tie_client_stdout tied_stdout_callback tied_stdin_callback leave_children_open_on_hup)){$ref->{$_}=\$prop->{$_}}return$ref}sub process_args {my ($self,$args,$template)=@_;$self->options($template={})if!$template ||!ref$template;if (!$_[2]&&!scalar(keys %$template)&&!$self->{'server'}->{'_no_options'}++){warn "Configuration options were empty - skipping any commandline, config file, or run argument parsing.\n"}my%previously_set;for (my$i=0;$i < @$args;$i++){if ($args->[$i]=~ /^(?:--)?(\w+)(?:[=\ ](\S+))?$/ && exists$template->{$1}){my ($key,$val)=($1,$2);splice @$args,$i,1;if (!defined$val){if ($i > $#$args || ($args->[$i]&& $args->[$i]=~ /^--\w+/)){$val=1}else {$val=splice @$args,$i,1;$val=$val->[0]if ref($val)eq 'ARRAY' && @$val==1 && ref($template->{$key})ne 'ARRAY'}}$i--;$val =~ s/%([A-F0-9])/chr(hex $1)/eig if!ref$val;if (ref$template->{$key}eq 'ARRAY'){if (!defined$previously_set{$key}){$previously_set{$key}=scalar @{$template->{$key}}}next if$previously_set{$key};push @{$template->{$key}},ref($val)eq 'ARRAY' ? @$val : $val}else {if (!defined$previously_set{$key}){$previously_set{$key}=defined(${$template->{$key}})? 1 : 0}next if$previously_set{$key};die "Found multiple values on the configuration item \"$key\" which expects only one value" if ref($val)eq 'ARRAY';${$template->{$key}}=$val}}}}sub _read_conf {my ($self,$file)=@_;my@args;$file=($file =~ m|^([\w\.\-\/\\\:]+)$|)? $1 : $self->fatal("Unsecure filename \"$file\"");open my$fh,'<',$file or do {$self->fatal("Couldn't open conf \"$file\" [$!]")if$ENV{'BOUND_SOCKETS'};warn "Couldn't open conf \"$file\" [$!]\n"};while (defined(my$line=<$fh>)){push@args,$1,$2 if$line =~ m/^\s* ((?:--)?\w+) (?:\s*[=:]\s*|\s+) (\S+)/x}close$fh;return \@args}sub other_child_died_hook {}sub delete_child_hook {}sub delete_child {my ($self,$pid)=@_;my$prop=$self->{'server'};return$self->other_child_died_hook($pid)if!exists$prop->{'children'}->{$pid};if ($prop->{'child_communication'}){if ($prop->{'children'}->{$pid}->{'sock'}){$prop->{'child_select'}->remove($prop->{'children'}->{$pid}->{'sock'});$prop->{'children'}->{$pid}->{'sock'}->close}}$self->delete_child_hook($pid);delete$prop->{'children'}->{$pid}}sub sig_pass {my ($self,$sig)=@_;for my$chld (keys %{$self->{'server'}->{'children'}}){$self->log(4,"signaling $chld with $sig");kill($sig,$chld)|| $self->log(1,"child $chld not signaled with $sig")}}sub register_sig_pass {my$self=shift;my$ref=$self->{'server'}->{'sig_passthrough'}|| [];$ref=[$ref]if!ref$ref;$self->fatal('invalid sig_passthrough')if ref$ref ne 'ARRAY';return if!@$ref;$self->log(4,"sig_passthrough option found");require Net::Server::SIG;for my$sig (map {split /\s*,\s*/,$_}@$ref){my$code=Net::Server::SIG::sig_is_registered($sig);if ($code){$self->log(2,"Installing passthrough for $sig even though it is already registered.")}else {$code=ref($SIG{$sig})eq 'CODE' ? $SIG{$sig}: undef}Net::Server::SIG::register_sig($sig=>sub {$self->sig_pass($sig);$code->($sig)if$code});$self->log(2,"Installed passthrough for $sig")}}package Net::Server::TiedHandle;sub TIEHANDLE {my$pkg=shift;return bless [@_],$pkg}sub READLINE {my$s=shift;$s->[1]? $s->[1]->($s->[0],'getline',@_): $s->[0]->getline}sub SAY {my$s=shift;$s->[1]? $s->[1]->($s->[0],'say',@_): $s->[0]->say(@_)}sub PRINT {my$s=shift;$s->[1]? $s->[1]->($s->[0],'print',@_): $s->[0]->print(@_)}sub PRINTF {my$s=shift;$s->[1]? $s->[1]->($s->[0],'printf',@_): $s->[0]->printf(@_)}sub READ {my$s=shift;$s->[1]? $s->[1]->($s->[0],'read',@_): $s->[0]->read(@_)}sub WRITE {my$s=shift;$s->[1]? $s->[1]->($s->[0],'write',@_): $s->[0]->write(@_)}sub SYSREAD {my$s=shift;$s->[1]? $s->[1]->($s->[0],'sysread',@_): $s->[0]->sysread(@_)}sub SYSWRITE {my$s=shift;$s->[1]? $s->[1]->($s->[0],'syswrite',@_): $s->[0]->syswrite(@_)}sub SEEK {my$s=shift;$s->[1]? $s->[1]->($s->[0],'seek',@_): $s->[0]->seek(@_)}sub BINMODE {}sub FILENO {}sub CLOSE {my$s=shift;$s->[1]? $s->[1]->($s->[0],'close',@_): $s->[0]->close(@_)}1;
NET_SERVER

$fatpacked{"Net/Server/Daemonize.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NET_SERVER_DAEMONIZE';
  package Net::Server::Daemonize;use strict;use base qw(Exporter);use POSIX qw(SIGINT SIG_BLOCK SIG_UNBLOCK);our$VERSION="0.06";our@EXPORT_OK=qw(check_pid_file create_pid_file unlink_pid_file is_root_user get_uid get_gid set_uid set_gid set_user safe_fork daemonize);sub check_pid_file ($) {my$pid_file=shift;return 1 if!-e $pid_file;open my$fh,'<',$pid_file or die "Couldn't open existant pid_file \"$pid_file\" [$!]\n";my$current_pid=<$fh>;close$fh;$current_pid=($current_pid =~ /^(\d{1,10})/)? $1 : die "Couldn't find pid in existing pid_file";my$exists;if ($$==$current_pid){warn "Pid_file created by this same process. Doing nothing.\n";return 1}elsif (-d "/proc/$$"){$exists=-e "/proc/$current_pid"}elsif (kill 0,$current_pid){$exists=1}die "Pid_file already exists for running process ($current_pid)... aborting\n" if$exists;warn "Pid_file \"$pid_file\" already exists.  Overwriting!\n";unlink$pid_file || die "Couldn't remove pid_file \"$pid_file\" [$!]\n";return 1}sub create_pid_file ($) {my$pid_file=shift;check_pid_file($pid_file);open my$fh,'>',$pid_file or die "Couldn't open pid file \"$pid_file\" [$!].\n";print$fh "$$\n";close$fh;die "Pid_file \"$pid_file\" not created.\n" if!-e $pid_file;return 1}sub unlink_pid_file ($) {my$pid_file=shift;return 1 if!-e $pid_file;open my$fh,'<',$pid_file or die "Couldn't open existant pid_file \"$pid_file\" [$!]\n";my$current_pid=<$fh>;close$fh;chomp$current_pid;die "Process $$ doesn't own pid_file \"$pid_file\". Can't remove it.\n" if$current_pid ne $$;unlink($pid_file)|| die "Couldn't unlink pid_file \"$pid_file\" [$!]\n";return 1}sub is_root_user () {my$id=get_uid('root');return!defined($id)|| $<==$id || $>==$id}sub get_uid ($) {my$user=shift;my$uid=($user =~ /^(\d+)$/)? $1 : getpwnam($user);die "No such user \"$user\"\n" unless defined$uid;return$uid}sub get_gid {my@gid;for my$group (split(/[, ]+/,join(" ",@_))){if($group =~ /^\d+$/){push@gid,$group}else{my$id=getgrnam($group);die "No such group \"$group\"\n" unless defined$id;push@gid,$id}}die "No group found in arguments.\n" unless@gid;return join(" ",$gid[0],@gid)}sub set_uid {my$uid=get_uid(shift());POSIX::setuid($uid);if ($<!=$uid || $>!=$uid){$<=$>=$uid;if ($<!=$uid){die "Couldn't become uid \"$uid\": $!\n"}}return 1}sub set_gid {my$gids=get_gid(@_);my$gid=(split /\s+/,$gids)[0];eval {$)=$gids};POSIX::setgid($gid);if (!grep {$gid==$_}split /\s+/,$(){die "Couldn't become gid \"$gid\": $!\n"}return 1}sub set_user {my ($user,@group)=@_;set_gid(@group)|| return undef;set_uid($user)|| return undef;return 1}sub safe_fork () {my$sigset=POSIX::SigSet->new(SIGINT);POSIX::sigprocmask(SIG_BLOCK,$sigset)or die "Can't block SIGINT for fork: [$!]\n";my$pid=fork;die "Couldn't fork: [$!]" if!defined$pid;$SIG{'INT'}='DEFAULT';POSIX::sigprocmask(SIG_UNBLOCK,$sigset)or die "Can't unblock SIGINT for fork: [$!]\n";return$pid}sub daemonize ($$$) {my ($user,$group,$pid_file)=@_;check_pid_file($pid_file)if defined$pid_file;my$uid=get_uid($user);my$gid=get_gid($group);$gid=(split /\s+/,$gid)[0];my$pid=safe_fork();exit(0)if$pid;create_pid_file($pid_file)if defined$pid_file;chown($uid,$gid,$pid_file)if defined$pid_file;set_user($uid,$gid);open STDIN,'<','/dev/null' or die "Can't open STDIN from /dev/null: [$!]\n";open STDOUT,'>','/dev/null' or die "Can't open STDOUT to /dev/null: [$!]\n";open STDERR,'>&STDOUT' or die "Can't open STDERR to STDOUT: [$!]\n";chdir '/' or die "Can't chdir to \"/\": [$!]";POSIX::setsid();$SIG{'INT'}=sub {HUNTSMAN($pid_file)}if defined$pid_file;return 1}sub HUNTSMAN {my$path=shift;unlink$path;eval {require Unix::Syslog;Unix::Syslog::syslog(Unix::Syslog::LOG_ERR(),"Exiting on INT signal.")};exit}1;
NET_SERVER_DAEMONIZE

$fatpacked{"Net/Server/Multiplex.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NET_SERVER_MULTIPLEX';
  package Net::Server::Multiplex;use strict;use base qw(Net::Server);use Net::Server::SIG qw(register_sig check_sigs);use Carp qw(confess);eval {require IO::Multiplex;import IO::Multiplex 1.05};$@ && warn "Module IO::Multiplex is required for Multiplex.";our$VERSION=$Net::Server::VERSION;sub net_server_type {__PACKAGE__}sub loop {my$self=shift;my$prop=$self->{server};my$mux=IO::Multiplex->new;$self->{mux}=$mux;for my$sock (@{$prop->{sock}}){if (Net::Server::SOCK_DGRAM==$sock->getsockopt(Socket::SOL_SOCKET(),Socket::SO_TYPE())){$mux->add($sock)}else {$mux->listen($sock)}}$mux->set_callback_object(Net::Server::Multiplex::MUX->init($self));register_sig(PIPE=>sub {$self->log(4,"SIG$_[0] received")},INT=>sub {$self->server_close()},TERM=>sub {$self->server_close()},QUIT=>sub {$self->server_close()},HUP=>sub {$self->sig_hup()},CHLD=>sub {$self->sig_chld()},);if (defined$prop->{check_for_dequeue}){$mux->set_timeout($prop->{sock}->[0],$prop->{check_for_dequeue})}$mux->loop(sub {my ($rdready,$wrready)=@_;check_sigs();$mux->endloop if$prop->{_HUP}})}sub sig_hup {my$self=shift;my$prop=$self->{server};if (my$mux=$self->{mux}){for my$sock (@{$prop->{sock}}){$mux->remove($sock)}}return$self->SUPER::sig_hup(@_)}sub setup_client_connection {my ($self,$mux)=@_;my$prop=$self->{server};$prop->{requests}++;if (!$prop->{no_client_stdout}){*STDIN=\*{$prop->{client}}}$self->get_client_info;$self->post_accept_hook;unless($self->allow_deny && $self->allow_deny_hook){$self->request_denied_hook;if (!$prop->{no_client_stdout}){close (STDOUT)}return 0}return 1}sub run_dequeue {confess "&$Net::Server::Multiplex::MUX::ISA[0]\::run_dequeue never defined"}sub mux_connection {}sub mux_input {confess "&$Net::Server::Multiplex::MUX::ISA[0]\::mux_input never defined"}sub mux_eof {}sub mux_close {}sub mux_timeout {confess "&$Net::Server::Multiplex::MUX::ISA[0]\::mux_timeout never defined"}package Net::Server::Multiplex::MUX;use strict;our$VERSION=$Net::Server::Multiplex::VERSION;our@ISA=qw(Net::Server::Multiplex);sub init {my$package=shift;my$net_server=shift;@ISA=(ref$net_server);my$self=bless {net_server=>$net_server,}=>$package;return$self}sub new {my$package=shift;my$net_server=shift;my$self=bless {net_server=>$net_server,peeraddr=>$net_server->{server}->{peeraddr},connected=>time,},$package;return$self}sub log {shift->{net_server}->log(@_)}sub mux_connection {my ($self,$mux,$fh)=@_;my$net_server=$self->{net_server};$net_server->{server}->{client}=$fh;$self->_link_stdout($mux,$fh);if ($net_server->setup_client_connection($mux)){my$client_object=Net::Server::Multiplex::MUX->new($net_server,$fh);$mux->set_callback_object($client_object,$fh);$client_object->SUPER::mux_connection($mux,$fh)}$self->_unlink_stdout();return}sub mux_input {my ($self,$mux,$fh,$in_ref)=@_;$self->_link_stdout($mux,$fh);$self->SUPER::mux_input($mux,$fh,$in_ref);$self->_unlink_stdout();return}sub mux_eof {my ($self,$mux,$fh,$in_ref)=@_;$self->_link_stdout($mux,$fh);$self->SUPER::mux_eof($mux,$fh,$in_ref);$self->_unlink_stdout();$mux->shutdown($fh,1);return}sub mux_close {my ($self,$mux,$fh)=@_;$self->{net_server}->post_process_request_hook;$self->SUPER::mux_close($mux,$fh);return}sub mux_timeout {my ($self,$mux,$fh)=@_;if (my$check=$self->{net_server}->{server}->{check_for_dequeue}){$self->{net_server}->run_dequeue();$mux->set_timeout($fh,$check)}else {$self->_link_stdout($mux,$fh);$self->SUPER::mux_timeout($mux,$fh);$self->_unlink_stdout()}return}sub _link_stdout {my ($self,$mux,$fh)=@_;return if$self->{net_server}->{server}->{no_client_stdout};if (tied *$fh){tie (*STDOUT,(ref tied *$fh),$mux,$fh)}else {*STDOUT=*$fh}}sub _unlink_stdout {my$self=shift;return if$self->{net_server}->{server}->{no_client_stdout};my$x=tied*STDOUT;if ($x){undef$x;untie*STDOUT}}1;
NET_SERVER_MULTIPLEX

$fatpacked{"Net/Server/Proto.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NET_SERVER_PROTO';
  package Net::Server::Proto;use strict;use warnings;use Socket ();my$requires_ipv6=0;sub parse_info {my ($class,$port,$host,$proto,$ipv,$server)=@_;my$info;if (ref($port)eq 'HASH'){die "Missing port in hashref passed in port argument.\n" if!$port->{'port'};$info=$port}else {$info={};$info->{'unix_type'}=$1 if$port =~ s{ (?<=[\w*\]]) [,|\s:/]+ (sock_stream|sock_dgram) \b }{}x;$ipv=$1 if$port =~ s{ (?<=[\w*\]]) [,|\s:/]+ IPv([*\d]+) }{}xi;$ipv .= $1 if$port =~ s{ (?<=[\w*\]]) [,|\s:/]+ IPv([*\d]+) }{}xi;$proto=$1 if$port =~ s{ (?<=[\w*\]]) [,|\s:/]+ (tcp|udp|ssl|ssleay|unix|unixdgram|\w+(?: ::\w+)+) $ }{}xi || $port =~ s{ / (\w+) $ }{}x;$host=$1 if$port =~ s{ ^ (.*?)      [,|\s:]+  (?= \w+ $) }{}x;$info->{'port'}=$port}$info->{'port'}||=0;$info->{'host'}||=(defined($host)&& length($host))? $host : '*';$ipv=$1 if$info->{'host'}=~ s{ (?<=[\w*\]]) [,|\s:/]+ IPv([*\d]+) }{}xi;$ipv .= $1 if$info->{'host'}=~ s{ (?<=[\w*\]]) [,|\s:/]+ IPv([*\d]+) }{}xi;if ($info->{'host'}=~ m{^ \[ ([\w/.\-:]+ | \*?) \] $ }x){$info->{'host'}=length($1)? $1 : '*'}elsif ($info->{'host'}=~ m{^    ([\w/.\-:]+ | \*?)    $ }x){$info->{'host'}=$1}else {$server->fatal("Could not determine host from \"$info->{'host'}\"")}$info->{'proto'}||=$proto || 'tcp';$ipv=$1 if$info->{'proto'}=~ s{ (?<=[\w*\]]) [,|\s:/]+ IPv([*\d]+) }{}xi;$ipv .= $1 if$info->{'proto'}=~ s{ (?<=[\w*\]]) [,|\s:/]+ IPv([*\d]+) }{}xi;if ($info->{'proto'}=~ /^(\w+ (?:::\w+)*)$/x){$info->{'proto'}=$1}else {$server->fatal("Could not determine proto from \"$proto\"")}$proto=lc$info->{'proto'};if ($info->{'proto'}=~ /^UNIX/i){return ({%$info,ipv=>'*'})}$ipv=$info->{'ipv'}|| $ipv || $ENV{'IPV'}|| '';$ipv=join '',@$ipv if ref($ipv)eq 'ARRAY';$server->fatal("Invalid ipv parameter - must contain 4, 6, or *")if$ipv && $ipv !~ /[46*]/;my@_info;if (!$ipv || $ipv =~ /[*]/){my@rows=eval {$class->get_addr_info(@$info{qw(host port proto)})};$server->fatal($@ || "Could not find valid addresses for [$info->{'host'}]:$info->{'port'} with ipv set to '*'")if!@rows;for my$row (@rows){my ($host,$port,$ipv,$warn)=@$row;push@_info,{host=>$host,port=>$port,ipv=>$ipv,proto=>$info->{'proto'},$warn ? (warn=>$warn): ()};$requires_ipv6++ if$ipv ne '4' && $proto ne 'ssl'}if (@rows > 1 && $rows[0]->[1]==0){$server->log(2,"Determining auto-assigned port (0) for host $info->{'host'} (prebind)");my$sock=$class->object($_info[-1],$server);$sock->connect($server);@$_{qw(port orig_port)}=($sock->NS_port,0)for@_info}for my$_info (@_info){$server->log(2,"Resolved [$info->{'host'}]:$info->{'port'} to [$_info->{'host'}]:$_info->{'port'}, IPv$_info->{'ipv'}")if$_info->{'host'}ne $info->{'host'}|| $_info->{'port'}ne $info->{'port'};$server->log(2,delete$_info->{'warn'})if$_info->{'warn'}}}elsif ($ipv =~ /6/ || $info->{'host'}=~ /:/){push@_info,{%$info,ipv=>'6'};$requires_ipv6++ if$proto ne 'ssl';push@_info,{%$info,ipv=>'4'}if$ipv =~ /4/ && $info->{'host'}!~ /:/}else {push@_info,{%$info,ipv=>'4'}}return@_info}sub get_addr_info {my ($class,$host,$port,$proto)=@_;$host='*' if!defined$host;$port=0 if!defined$port;$proto='tcp' if!defined$proto;return ([$host,$port,'*'])if$proto =~ /UNIX/i;$port=(getservbyname($port,$proto))[2]or die "Could not determine port number from host [$host]:$_[2]\n" if$port =~ /\D/;my@info;if ($host =~ /^\d+(?:\.\d+){3}$/){my$addr=Socket::inet_aton($host)or die "Unresolveable host [$host]:$port: invalid ip\n";push@info,[Socket::inet_ntoa($addr),$port,4]}elsif (!$ENV{'NO_IPV6'}&& eval {require Socket6;require IO::Socket::INET6}){my$proto_id=getprotobyname(lc($proto)eq 'udp' ? 'udp' : 'tcp');my$socktype=lc($proto)eq 'udp' ? Socket::SOCK_DGRAM(): Socket::SOCK_STREAM();my@res=Socket6::getaddrinfo($host eq '*' ? '' : $host,$port,Socket::AF_UNSPEC(),$socktype,$proto_id,Socket6::AI_PASSIVE());die "Unresolveable [$host]:$port: $res[0]\n" if@res < 5;while (@res >= 5){my ($afam,$socktype,$proto,$saddr,$canonname)=splice@res,0,5;my@res2=Socket6::getnameinfo($saddr,Socket6::NI_NUMERICHOST()| Socket6::NI_NUMERICSERV());die "getnameinfo failed on [$host]:$port: $res2[0]\n" if@res2 < 2;my ($ip,$port)=@res2;my$ipv=($afam==Socket6::AF_INET6())? 6 : ($afam==Socket::AF_INET())? 4 : '*';push@info,[$ip,$port,$ipv]}my%ipv6mapped=map {$_->[0]eq '::' ? ('0.0.0.0'=>$_): $_->[0]=~ /^::ffff:(\d+(?:\.\d+){3})$/ ? ($1=>$_): ()}@info;if ((scalar(keys%ipv6mapped)&& grep {$ipv6mapped{$_->[0]}}@info)&& not my$only=$class->_bindv6only){for my$i4 (@info){my$i6=$ipv6mapped{$i4->[0]}|| next;if ($host eq '*' && $i6->[0]eq '::' &&!length($only)&&!eval{IO::Socket::INET6->new->configure({LocalAddr=>'',LocalPort=>0,Listen=>1,ReuseAddr=>1,Domain=>Socket6::AF_INET6()})or die $!}){$i4->[3]="Host [*] resolved to IPv6 address [::] but IO::Socket::INET6->new fails: $@";$i6->[0]=''}else {$i6->[3]="Not including resolved host [$i4->[0]] IPv4 because it ".(length($only)? 'will' : 'should')." be handled by [$i6->[0]] IPv6";$i4->[0]=''}}@info=grep {length $_->[0]}@info}}elsif ($host =~ /:/){die "Unresolveable host [$host]:$port - could not load IO::Socket::INET6: $@"}else {my@addr;if ($host eq '*'){push@addr,Socket::INADDR_ANY()}else {(undef,undef,undef,undef,@addr)=gethostbyname($host);die "Unresolveable host [$host]:$port via IPv4 gethostbyname\n" if!@addr}push@info,[Socket::inet_ntoa($_),$port,4]for@addr}return@info}sub _bindv6only {my$class=shift;my$val=$class->_sysctl('net.ipv6.bindv6only');$val=$class->_sysctl('net.inet6.ip6.v6only')if!length($val);return$val}sub _sysctl {my ($class,$key)=@_;(my$file="/proc/sys/$key")=~ y|.|/|;if (-e $file){open my$fh,"<",$file or return '';my$val=<$fh> || return '';chomp$val;return$val}elsif (-x "/sbin/sysctl"){my$val=(split /\s+/,`/sbin/sysctl -n $key 2>/dev/null`)[0];return defined($val)? $val : ''}return ''}sub object {my ($class,$info,$server)=@_;my$proto_class=$info->{'proto'};if ($proto_class !~ /::/){$server->fatal("Invalid proto class \"$proto_class\"")if$proto_class !~ /^\w+$/;$proto_class="Net::Server::Proto::" .uc($proto_class)}(my$file="${proto_class}.pm")=~ s|::|/|g;$server->fatal("Unable to load module for proto \"$proto_class\": $@")if!eval {require$file};return$proto_class->object($info,$server)}sub requires_ipv6 {my ($class,$server)=@_;return if!$requires_ipv6;if (!$INC{'IO/Socket/INET6.pm'}){eval {require Socket6;require IO::Socket::INET6}or $server->fatal("Port configuration using IPv6 could not be started becauses of Socket6 library issues: $@")}return 1}1;
NET_SERVER_PROTO

$fatpacked{"Net/Server/Proto/SSL.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NET_SERVER_PROTO_SSL';
  package Net::Server::Proto::SSL;use strict;use warnings;BEGIN {if (!eval {require IO::Socket::SSL}){die "Module IO::Socket::SSL is required for SSL - you may alternately try SSLEAY. $@"}}our@ISA=qw(IO::Socket::SSL);our$AUTOLOAD;my@ssl_args=qw(SSL_use_cert SSL_verify_mode SSL_key_file SSL_cert_file SSL_ca_path SSL_ca_file SSL_cipher_list SSL_passwd_cb SSL_max_getline_length SSL_error_callback);sub NS_proto {'SSL'}sub NS_port {my$sock=shift;${*$sock}{'NS_port'}=shift if @_;return ${*$sock}{'NS_port'}}sub NS_host {my$sock=shift;${*$sock}{'NS_host'}=shift if @_;return ${*$sock}{'NS_host'}}sub NS_ipv {my$sock=shift;${*$sock}{'NS_ipv'}=shift if @_;return ${*$sock}{'NS_ipv'}}sub NS_listen {my$sock=shift;${*$sock}{'NS_listen'}=shift if @_;return ${*$sock}{'NS_listen'}}sub object {my ($class,$info,$server)=@_;my$ssl=$server->{'server'}->{'ssl_args'}||=do {my%temp=map {$_=>undef}@ssl_args;$server->configure({map {$_=>\$temp{$_}}@ssl_args});\%temp};my@sock=$class->SUPER::new();for my$sock (@sock){$sock->NS_host($info->{'host'});$sock->NS_port($info->{'port'});$sock->NS_ipv($info->{'ipv'});$sock->NS_listen(defined($info->{'listen'})? $info->{'listen'}: defined($server->{'server'}->{'listen'})? $server->{'server'}->{'listen'}: Socket::SOMAXCONN());${*$sock}{'NS_orig_port'}=$info->{'orig_port'}if defined$info->{'orig_port'};my%seen;for my$key (grep {!$seen{$_}++}(@ssl_args,sort grep {/^SSL_/}keys %$info)){my$val=defined($info->{$key})? $info->{$key}: defined($ssl->{$key})? $ssl->{$key}: $server->can($key)? $server->$key($info->{'host'},$info->{'port'},'SSL'): undef;next if!defined$val;$sock->$key($val)if defined$val}}return wantarray ? @sock : $sock[0]}sub log_connect {my ($sock,$server)=@_;$server->log(2,"Binding to ".$sock->NS_proto." port ".$sock->NS_port." on host ".$sock->NS_host." with IPv".($sock->NS_ipv))}sub connect {my ($sock,$server)=@_;my$host=$sock->NS_host;my$port=$sock->NS_port;my$ipv=$sock->NS_ipv;my$lstn=$sock->NS_listen;$sock->SUPER::configure({LocalPort=>$port,Proto=>'tcp',Listen=>$lstn,ReuseAddr=>1,Reuse=>1,(($host ne '*')? (LocalAddr=>$host): ()),($sock->isa('IO::Socket::INET6')? (Domain=>($ipv eq '6')? Socket6::AF_INET6(): ($ipv eq '4')? Socket::AF_INET(): Socket::AF_UNSPEC()): ()),(map {$_=>$sock->$_()}grep {/^SSL_/}keys %{*$sock}),SSL_server=>1,})or $server->fatal("Cannot connect to SSL port $port on $host [$!]");if ($port eq '0' and $port=$sock->sockport){$server->log(2,"  Bound to auto-assigned port $port");${*$sock}{'NS_orig_port'}=$sock->NS_port;$sock->NS_port($port)}elsif ($port =~ /\D/ and $port=$sock->sockport){$server->log(2,"  Bound to service port ".$sock->NS_port()."($port)");${*$sock}{'NS_orig_port'}=$sock->NS_port;$sock->NS_port($port)}}sub reconnect {my ($sock,$fd,$server,$port)=@_;$server->log(3,"Reassociating file descriptor $fd with ".$sock->NS_proto." on [".$sock->NS_host."]:".$sock->NS_port.", using IPv".$sock->NS_ipv);$sock->configure_SSL({(map {$_=>$sock->$_()}grep {/^SSL_/}keys %{*$sock}),SSL_server=>1,});$sock->IO::Socket::INET::fdopen($fd,'w')or $server->fatal("Error opening to file descriptor ($fd) [$!]");if ($sock->isa("IO::Socket::INET6")){my$ipv=$sock->NS_ipv;${*$sock}{'io_socket_domain'}=($ipv eq '6')? Socket6::AF_INET6(): ($ipv eq '4')? Socket::AF_INET(): Socket::AF_UNSPEC()}if ($port ne $sock->NS_port){$server->log(2,"  Re-bound to previously assigned port $port");${*$sock}{'NS_orig_port'}=$sock->NS_port;$sock->NS_port($port)}}sub accept {my ($sock,$class)=@_;my ($client,$peername);my$code=$sock->isa('IO::Socket::INET6')? 'IO::Socket::INET6'->can('accept'): 'IO::Socket::INET'->can('accept');if (wantarray){($client,$peername)=$code->($sock,$class || ref($sock))}else {$client=$code->($sock,$class || ref($sock))}${*$client}{'_parent_sock'}=$sock;if (defined$client){$client->NS_proto($sock->NS_proto);$client->NS_ipv($sock->NS_ipv);$client->NS_host($sock->NS_host);$client->NS_port($sock->NS_port)}return wantarray ? ($client,$peername): $client}sub hup_string {my$sock=shift;return join "|",$sock->NS_host,$sock->NS_port,$sock->NS_proto,'ipv'.$sock->NS_ipv,(defined(${*$sock}{'NS_orig_port'})? ${*$sock}{'NS_orig_port'}: ())}sub show {my$sock=shift;my$t="Ref = \"".ref($sock)."\" (".$sock->hup_string.")\n";for my$prop (qw(SSLeay_context SSLeay_is_client)){$t .= "  $prop = \"" .$sock->$prop()."\"\n"}return$t}sub AUTOLOAD {my$sock=shift;my$prop=$AUTOLOAD =~ /::([^:]+)$/ ? $1 : die "Missing property in AUTOLOAD.";die "Unknown method or property [$prop]" if$prop !~ /^(SSL_\w+)$/;no strict 'refs';*{__PACKAGE__."::${prop}"}=sub {my$sock=shift;if (@_){${*$sock}{$prop}=shift;return delete ${*$sock}{$prop}if!defined ${*$sock}{$prop}}else {return ${*$sock}{$prop}}};return$sock->$prop(@_)}sub tie_stdout {1}sub post_accept {my$client=shift;$client->_accept_ssl if!${*$client}{'_accept_ssl'}}sub _accept_ssl {my$client=shift;${*$client}{'_accept_ssl'}=1;my$sock=delete(${*$client}{'_parent_sock'})|| die "Could not get handshake from accept\n";$sock->accept_SSL($client)|| die "Could not finalize SSL connection with client handle ($@)\n"}sub read_until {my ($client,$bytes,$end_qr)=@_;die "One of bytes or end_qr should be defined for TCP read_until\n" if!defined($bytes)&&!defined($end_qr);$client->_accept_ssl if!${*$client}{'_accept_ssl'};my$content='';my$ok=0;while (1){$client->read($content,1,length($content));if (defined($bytes)&& length($content)>= $bytes){$ok=2;last}elsif (defined($end_qr)&& $content =~ $end_qr){$ok=1;last}}return wantarray ? ($ok,$content): $content}1;
NET_SERVER_PROTO_SSL

$fatpacked{"Net/Server/Proto/SSLEAY.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NET_SERVER_PROTO_SSLEAY';
  package Net::Server::Proto::SSLEAY;use strict;use warnings;use IO::Socket::INET;use Fcntl ();use Errno ();use Socket ();BEGIN {eval {require Net::SSLeay;1}or warn "Module Net::SSLeay is required for SSLeay.";for my$sub (qw(load_error_strings SSLeay_add_ssl_algorithms ENGINE_load_builtin_engines ENGINE_register_all_complete randomize)){Net::SSLeay->can($sub)->()}eval {[Fcntl::F_GETFL(),Fcntl::F_SETFL(),Fcntl::O_NONBLOCK()]}|| die "Could not access Fcntl constant while loading ".__PACKAGE__.": $@"}our@ISA=qw(IO::Socket::INET);our$AUTOLOAD;my@ssl_args=qw(SSL_use_cert SSL_verify_mode SSL_key_file SSL_cert_file SSL_ca_path SSL_ca_file SSL_cipher_list SSL_passwd_cb SSL_max_getline_length SSL_error_callback);sub NS_proto {'SSLEAY'}sub NS_port {my$sock=shift;${*$sock}{'NS_port'}=shift if @_;return ${*$sock}{'NS_port'}}sub NS_host {my$sock=shift;${*$sock}{'NS_host'}=shift if @_;return ${*$sock}{'NS_host'}}sub NS_ipv {my$sock=shift;${*$sock}{'NS_ipv'}=shift if @_;return ${*$sock}{'NS_ipv'}}sub NS_listen {my$sock=shift;${*$sock}{'NS_listen'}=shift if @_;return ${*$sock}{'NS_listen'}}sub object {my ($class,$info,$server)=@_;my$ssl=$server->{'server'}->{'ssl_args'}||=do {my%temp=map {$_=>undef}@ssl_args;$server->configure({map {$_=>\$temp{$_}}@ssl_args});\%temp};@ISA=qw(IO::Socket::INET6) if$ISA[0]eq 'IO::Socket::INET' && Net::Server::Proto->requires_ipv6($server);my@sock=$class->SUPER::new();for my$sock (@sock){$sock->NS_host($info->{'host'});$sock->NS_port($info->{'port'});$sock->NS_ipv($info->{'ipv'});$sock->NS_listen(defined($info->{'listen'})? $info->{'listen'}: defined($server->{'server'}->{'listen'})? $server->{'server'}->{'listen'}: Socket::SOMAXCONN());${*$sock}{'NS_orig_port'}=$info->{'orig_port'}if defined$info->{'orig_port'};for my$key (@ssl_args){my$val=defined($info->{$key})? $info->{$key}: defined($ssl->{$key})? $ssl->{$key}: $server->can($key)? $server->$key($info->{'host'},$info->{'port'},'SSLEAY'): undef;next if!defined$val;$sock->$key($val)if defined$val}}return wantarray ? @sock : $sock[0]}sub log_connect {my ($sock,$server)=@_;$server->log(2,"Binding to ".$sock->NS_proto." port ".$sock->NS_port." on host ".$sock->NS_host." with IPv".$sock->NS_ipv)}sub connect {my ($sock,$server)=@_;my$host=$sock->NS_host;my$port=$sock->NS_port;my$ipv=$sock->NS_ipv;my$lstn=$sock->NS_listen;$sock->SUPER::configure({LocalPort=>$port,Proto=>'tcp',Listen=>$lstn,ReuseAddr=>1,Reuse=>1,(($host ne '*')? (LocalAddr=>$host): ()),($sock->isa("IO::Socket::INET6")? (Domain=>($ipv eq '6')? Socket6::AF_INET6(): ($ipv eq '4')? Socket::AF_INET(): Socket::AF_UNSPEC()): ()),})|| $server->fatal("Can't connect to SSLEAY port $port on $host [$!]");if ($port eq '0' and $port=$sock->sockport){$server->log(2,"  Bound to auto-assigned port $port");${*$sock}{'NS_orig_port'}=$sock->NS_port;$sock->NS_port($port)}elsif ($port =~ /\D/ and $port=$sock->sockport){$server->log(2,"  Bound to service port ".$sock->NS_port()."($port)");${*$sock}{'NS_orig_port'}=$sock->NS_port;$sock->NS_port($port)}$sock->bind_SSL($server)}sub reconnect {my ($sock,$fd,$server,$port)=@_;$server->log(3,"Reassociating file descriptor $fd with ".$sock->NS_proto." on [".$sock->NS_host."]:".$sock->NS_port.", using IPv".$sock->NS_ipv);my$resp=$sock->fdopen($fd,'w')or $server->fatal("Error opening to file descriptor ($fd) [$!]");if ($sock->isa("IO::Socket::INET6")){my$ipv=$sock->NS_ipv;${*$sock}{'io_socket_domain'}=($ipv eq '6')? Socket6::AF_INET6(): ($ipv eq '4')? Socket::AF_INET(): Socket::AF_UNSPEC()}$sock->bind_SSL($server);if ($port ne $sock->NS_port){$server->log(2,"  Re-bound to previously assigned port $port");${*$sock}{'NS_orig_port'}=$sock->NS_port;$sock->NS_port($port)}return$resp}sub bind_SSL {my ($sock,$server)=@_;my$ctx=Net::SSLeay::CTX_new();$sock->SSLeay_check_fatal("SSLeay bind_SSL CTX_new");Net::SSLeay::CTX_set_options($ctx,Net::SSLeay::OP_ALL());$sock->SSLeay_check_fatal("SSLeay bind_SSL CTX_set_options");Net::SSLeay::CTX_set_mode($ctx,0x11);$sock->SSLeay_check_fatal("SSLeay bind_SSL CTX_set_mode");my$file_key=$sock->SSL_key_file || die "SSLeay missing SSL_key_file on ".$sock->hup_string.".\n";my$file_cert=$sock->SSL_cert_file || die "SSLeay missing SSL_cert_file on ".$sock->hup_string>".\n";Net::SSLeay::CTX_use_RSAPrivateKey_file($ctx,$file_key,Net::SSLeay::FILETYPE_PEM());$sock->SSLeay_check_fatal("SSLeay bind_SSL CTX_use_RSAPrivateKey_file");Net::SSLeay::CTX_use_certificate_file($ctx,$file_cert,Net::SSLeay::FILETYPE_PEM());$sock->SSLeay_check_fatal("SSLeay bind_SSL CTX_use_certificate_file");$sock->SSLeay_context($ctx)}sub close {my$sock=shift;if ($sock->SSLeay_is_client){Net::SSLeay::free($sock->SSLeay)}else {Net::SSLeay::CTX_free($sock->SSLeay_context)}$sock->SSLeay_check_fatal("SSLeay close free");return$sock->SUPER::close(@_)}sub accept {my ($sock,$class)=(@_);my ($client,$peername);if (wantarray){($client,$peername)=$sock->SUPER::accept($class)}else {$client=$sock->SUPER::accept($class)}if (defined$client){$client->NS_proto($sock->NS_proto);$client->NS_ipv($sock->NS_ipv);$client->NS_host($sock->NS_host);$client->NS_port($sock->NS_port);$client->SSLeay_context($sock->SSLeay_context);$client->SSLeay_is_client(1)}return wantarray ? ($client,$peername): $client}sub post_accept {my$client=shift;$client->SSLeay}sub SSLeay {my$client=shift;if (!exists ${*$client}{'SSLeay'}){die "SSLeay refusing to accept on non-client socket" if!$client->SSLeay_is_client;$client->autoflush(1);my$f=fcntl($client,Fcntl::F_GETFL(),0)|| die "SSLeay - fcntl get: $!\n";fcntl($client,Fcntl::F_SETFL(),$f | Fcntl::O_NONBLOCK())|| die "SSLeay - fcntl set: $!\n";my$ssl=Net::SSLeay::new($client->SSLeay_context);$client->SSLeay_check_fatal("SSLeay new");Net::SSLeay::set_fd($ssl,$client->fileno);$client->SSLeay_check_fatal("SSLeay set_fd");Net::SSLeay::accept($ssl);$client->SSLeay_check_fatal("SSLeay accept");${*$client}{'SSLeay'}=$ssl}return if!defined wantarray;return ${*$client}{'SSLeay'}}sub SSLeay_check_fatal {my ($client,$msg)=@_;if (my$err=$client->SSLeay_check_error($msg,1)){my ($file,$pkg,$line)=caller;die "$msg at $file line $line\n  ".join('  ',@$err)}}sub SSLeay_check_error {my ($client,$msg,$fatal)=@_;my@err;while (my$n=Net::SSLeay::ERR_get_error()){push@err,"$n. ".Net::SSLeay::ERR_error_string($n)."\n"}if (@err){my$cb=$client->SSL_error_callback;$cb->($client,$msg,\@err,($fatal ? 'is_fatal' : ()))if$cb;return \@err}return}sub read_until {my ($client,$bytes,$end_qr,$non_greedy)=@_;my$ssl=$client->SSLeay;my$content=${*$client}{'SSLeay_buffer'};$content='' if!defined$content;my$ok=0;OUTER: while (1){if (!length($content)){}elsif (defined($bytes)&& length($content)>= $bytes){${*$client}{'SSLeay_buffer'}=substr($content,$bytes,length($content),'');$ok=2;last}elsif (defined($end_qr)&& $content =~ m/$end_qr/g){my$n=pos($content);${*$client}{'SSLeay_buffer'}=substr($content,$n,length($content),'');$ok=1;last}my$n_empty=0;while (1){my$n=16384;$n -= ($bytes - length($content))if$non_greedy && ($bytes - length($content))< $n;my$buf=Net::SSLeay::read($ssl,16384);if ($client->SSLeay_check_error('SSLeay read_until read')){last OUTER}die "SSLeay read_until: $!\n" if!defined($buf)&&!$!{EAGAIN}&&!$!{EINTR}&&!$!{ENOBUFS};last if!defined($buf);if (!length($buf)){last OUTER if!length($buf)&& $n_empty++}else {$content .= $buf;if ($non_greedy && length($content)==$bytes){$ok=3;last}}}}return wantarray ? ($ok,$content): $content}sub read {my ($client,$buf,$size,$offset)=@_;my ($ok,$read)=$client->read_until($size,undef,1);substr($_[1],$offset || 0,defined($buf)? length($buf): 0,$read);return length$read}sub sysread {my ($client,$buf,$length,$offset)=@_;$length=length$buf unless defined$length;$offset=0 unless defined$offset;my$ssl=$client->SSLeay;my$data=Net::SSLeay::read($ssl,$length);return if $!{EAGAIN}|| $!{EINTR};die "SSLeay print: $!\n" unless defined$data;$length=length($data);$$buf='' if!defined$buf;if ($offset > length($$buf)){$$buf .= "\0" x ($offset - length($buf))}substr($$buf,$offset,length($$buf),$data);return$length}sub error {my$client=shift;return ${*$client}{'_error'}}sub syswrite {my ($client,$buf,$length,$offset)=@_;delete ${*$client}{'_error'};$length=length$buf unless defined$length;$offset=0 unless defined$offset;my$ssl=$client->SSLeay;my$write=Net::SSLeay::write_partial($ssl,$offset,$length,$buf);return if $!{EAGAIN}|| $!{EINTR};if ($write < 0){${*$client}{'_error'}="SSLeay print: $!\n";return}return$write}sub getline {my$client=shift;my ($ok,$line)=$client->read_until($client->SSL_max_getline_length,$/);return$line}sub getlines {my$client=shift;my@lines;while (1){my ($ok,$line)=$client->read_until($client->SSL_max_getline_length,$/);push@lines,$line;last if$ok!=1}return@lines}sub print {my$client=shift;delete ${*$client}{'_error'};my$buf=@_==1 ? $_[0]: join('',@_);my$ssl=$client->SSLeay;while (length$buf){vec(my$vec='',$client->fileno,1)=1;select(undef,$vec,undef,undef);my$write=Net::SSLeay::write($ssl,$buf);return 0 if$client->SSLeay_check_error('SSLeay write');if ($write==-1 &&!$!{EAGAIN}&&!$!{EINTR}&&!$!{ENOBUFS}){${*$client}{'_error'}="SSLeay print: $!\n";return}substr($buf,0,$write,"")if$write > 0}return 1}sub printf {my$client=shift;$client->print(sprintf(shift,@_))}sub say {my$client=shift;$client->print(@_,"\n")}sub write {my$client=shift;my$buf=shift;$buf=substr($buf,$_[1]|| 0,$_[0])if @_;$client->print($buf)}sub seek {my$client=shift;my ($pos,$whence)=@_;if ($whence){$!="Seek from $whence of non-zero is not supported.";return 0}my$n=$client->read(my$buf,$pos);if ($n!=$pos){$|="Couldn't seek to $pos ($n)\n";return 0}return 1}sub poll_cb {my ($self,$cb)=@_;return$cb->($self)}sub hup_string {my$sock=shift;return join "|",$sock->NS_host,$sock->NS_port,$sock->NS_proto,"ipv".$sock->NS_ipv,(defined(${*$sock}{'NS_orig_port'})? ${*$sock}{'NS_orig_port'}: ())}sub show {my$sock=shift;my$t="Ref = \"".ref($sock)."\" (".$sock->hup_string.")\n";for my$prop (qw(SSLeay_context SSLeay_is_client)){$t .= "  $prop = \"" .$sock->$prop()."\"\n"}return$t}sub AUTOLOAD {my$sock=shift;my$prop=$AUTOLOAD =~ /::([^:]+)$/ ? $1 : die "Missing property in AUTOLOAD.";die "Unknown method or property [$prop]" if$prop !~ /^(SSLeay_context|SSLeay_is_client|SSL_\w+)$/;no strict 'refs';*{__PACKAGE__."::${prop}"}=sub {my$sock=shift;if (@_){${*$sock}{$prop}=shift;return delete ${*$sock}{$prop}if!defined ${*$sock}{$prop}}else {return ${*$sock}{$prop}}};return$sock->$prop(@_)}sub tie_stdout {1}1;
NET_SERVER_PROTO_SSLEAY

$fatpacked{"Net/Server/Proto/TCP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NET_SERVER_PROTO_TCP';
  package Net::Server::Proto::TCP;use strict;use warnings;use IO::Socket::INET;use Net::Server::Proto;our@ISA=qw(IO::Socket::INET);sub NS_proto {'TCP'}sub NS_port {my$sock=shift;${*$sock}{'NS_port'}=shift if @_;return ${*$sock}{'NS_port'}}sub NS_host {my$sock=shift;${*$sock}{'NS_host'}=shift if @_;return ${*$sock}{'NS_host'}}sub NS_ipv {my$sock=shift;${*$sock}{'NS_ipv'}=shift if @_;return ${*$sock}{'NS_ipv'}}sub NS_listen {my$sock=shift;${*$sock}{'NS_listen'}=shift if @_;return ${*$sock}{'NS_listen'}}sub object {my ($class,$info,$server)=@_;@ISA=qw(IO::Socket::INET6) if$ISA[0]eq 'IO::Socket::INET' && Net::Server::Proto->requires_ipv6($server);my@sock=$class->SUPER::new();for my$sock (@sock){$sock->NS_host($info->{'host'});$sock->NS_port($info->{'port'});$sock->NS_ipv($info->{'ipv'});$sock->NS_listen(defined($info->{'listen'})? $info->{'listen'}: defined($server->{'server'}->{'listen'})? $server->{'server'}->{'listen'}: Socket::SOMAXCONN());${*$sock}{'NS_orig_port'}=$info->{'orig_port'}if defined$info->{'orig_port'}}return wantarray ? @sock : $sock[0]}sub log_connect {my ($sock,$server)=@_;$server->log(2,"Binding to ".$sock->NS_proto." port ".$sock->NS_port." on host ".$sock->NS_host." with IPv".$sock->NS_ipv)}sub connect {my ($sock,$server)=@_;my$host=$sock->NS_host;my$port=$sock->NS_port;my$ipv=$sock->NS_ipv;my$lstn=$sock->NS_listen;$sock->SUPER::configure({LocalPort=>$port,Proto=>'tcp',Listen=>$lstn,ReuseAddr=>1,Reuse=>1,(($host ne '*')? (LocalAddr=>$host): ()),($sock->isa("IO::Socket::INET6")? (Domain=>($ipv eq '6')? Socket6::AF_INET6(): ($ipv eq '4')? Socket::AF_INET(): Socket::AF_UNSPEC()): ()),})|| $server->fatal("Can't connect to TCP port $port on $host [$!]");if ($port eq '0' and $port=$sock->sockport){$server->log(2,"  Bound to auto-assigned port $port");${*$sock}{'NS_orig_port'}=$sock->NS_port;$sock->NS_port($port)}elsif ($port =~ /\D/ and $port=$sock->sockport){$server->log(2,"  Bound to service port ".$sock->NS_port()."($port)");${*$sock}{'NS_orig_port'}=$sock->NS_port;$sock->NS_port($port)}}sub reconnect {my ($sock,$fd,$server,$port)=@_;$server->log(3,"Reassociating file descriptor $fd with ".$sock->NS_proto." on [".$sock->NS_host."]:".$sock->NS_port.", using IPv".$sock->NS_ipv);$sock->fdopen($fd,'w')or $server->fatal("Error opening to file descriptor ($fd) [$!]");if ($sock->isa("IO::Socket::INET6")){my$ipv=$sock->NS_ipv;${*$sock}{'io_socket_domain'}=($ipv eq '6')? Socket6::AF_INET6(): ($ipv eq '4')? Socket::AF_INET(): Socket::AF_UNSPEC()}if ($port ne $sock->NS_port){$server->log(2,"  Re-bound to previously assigned port $port");${*$sock}{'NS_orig_port'}=$sock->NS_port;$sock->NS_port($port)}}sub accept {my ($sock,$class)=(@_);my ($client,$peername);if (wantarray){($client,$peername)=$sock->SUPER::accept($class)}else {$client=$sock->SUPER::accept($class)}if (defined$client){$client->NS_port($sock->NS_port)}return wantarray ? ($client,$peername): $client}sub poll_cb {my ($self,$cb)=@_;return$cb->($self)}sub read_until {my ($client,$bytes,$end_qr)=@_;die "One of bytes or end_qr should be defined for TCP read_until\n" if!defined($bytes)&&!defined($end_qr);my$content='';my$ok=0;while (1){$client->read($content,1,length($content));if (defined($bytes)&& length($content)>= $bytes){$ok=2;last}elsif (defined($end_qr)&& $content =~ $end_qr){$ok=1;last}}return wantarray ? ($ok,$content): $content}sub hup_string {my$sock=shift;return join "|",$sock->NS_host,$sock->NS_port,$sock->NS_proto,'ipv'.$sock->NS_ipv,(defined(${*$sock}{'NS_orig_port'})? ${*$sock}{'NS_orig_port'}: ())}sub show {my$sock=shift;return "Ref = \"".ref($sock)."\" (".$sock->hup_string.")\n"}1;
NET_SERVER_PROTO_TCP

$fatpacked{"Net/Server/Proto/UDP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NET_SERVER_PROTO_UDP';
  package Net::Server::Proto::UDP;use strict;use base qw(Net::Server::Proto::TCP);my@udp_args=qw(udp_recv_len udp_recv_flags udp_broadcast);sub NS_proto {'UDP'}sub NS_recv_len {my$sock=shift;${*$sock}{'NS_recv_len'}=shift if @_;return ${*$sock}{'NS_recv_len'}}sub NS_recv_flags {my$sock=shift;${*$sock}{'NS_recv_flags'}=shift if @_;return ${*$sock}{'NS_recv_flags'}}sub NS_broadcast {my$sock=shift;${*$sock}{'NS_broadcast'}=shift if @_;return ${*$sock}{'NS_broadcast'}}sub object {my ($class,$info,$server)=@_;@Net::Server::Proto::TCP::ISA=qw(IO::Socket::INET6) if$Net::Server::Proto::TCP::ISA[0]eq 'IO::Socket::INET' && Net::Server::Proto->requires_ipv6($server);my$udp=$server->{'server'}->{'udp_args'}||=do {my%temp=map {$_=>undef}@udp_args;$server->configure({map {$_=>\$temp{$_}}@udp_args});\%temp};my$len=defined($info->{'udp_recv_len'})? $info->{'udp_recv_len'}: defined($udp->{'udp_recv_len'})? $udp->{'udp_recv_len'}: 4096;$len=($len =~ /^(\d+)$/)? $1 : 4096;my$flg=defined($info->{'udp_recv_flags'})? $info->{'udp_recv_flags'}: defined($udp->{'udp_recv_flags'})? $udp->{'udp_recv_flags'}: 0;$flg=($flg =~ /^(\d+)$/)? $1 : 0;my@sock=$class->SUPER::new();for my$sock (@sock){$sock->NS_host($info->{'host'});$sock->NS_port($info->{'port'});$sock->NS_ipv($info->{'ipv'});$sock->NS_recv_len($len);$sock->NS_recv_flags($flg);$sock->NS_broadcast(exists($info->{'udp_broadcast'})? $info->{'udp_broadcast'}: $udp->{'upd_broadcast'});${*$sock}{'NS_orig_port'}=$info->{'orig_port'}if defined$info->{'orig_port'}}return wantarray ? @sock : $sock[0]}sub connect {my ($sock,$server)=@_;my$host=$sock->NS_host;my$port=$sock->NS_port;my$ipv=$sock->NS_ipv;$sock->SUPER::configure({LocalPort=>$port,Proto=>'udp',ReuseAddr=>1,Reuse=>1,(($host ne '*')? (LocalAddr=>$host): ()),($sock->isa("IO::Socket::INET6")? (Domain=>($ipv eq '6')? Socket6::AF_INET6(): ($ipv eq '4')? Socket::AF_INET(): Socket::AF_UNSPEC()): ()),($sock->NS_broadcast ? (Broadcast=>1): ()),})or $server->fatal("Cannot bind to UDP port $port on $host [$!]");if ($port eq 0 and $port=$sock->sockport){$server->log(2,"  Bound to auto-assigned port $port");${*$sock}{'NS_orig_port'}=$sock->NS_port;$sock->NS_port($port)}elsif ($port =~ /\D/ and $port=$sock->sockport){$server->log(2,"  Bound to service port ".$sock->NS_port()."($port)");${*$sock}{'NS_orig_port'}=$sock->NS_port;$sock->NS_port($port)}}1;
NET_SERVER_PROTO_UDP

$fatpacked{"Net/Server/Proto/UNIX.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NET_SERVER_PROTO_UNIX';
  package Net::Server::Proto::UNIX;use strict;use base qw(IO::Socket::UNIX);use Socket qw(SOCK_STREAM SOCK_DGRAM);sub NS_proto {'UNIX'}sub NS_port {my$sock=shift;${*$sock}{'NS_port'}=shift if @_;return ${*$sock}{'NS_port'}}sub NS_host {'*'}sub NS_ipv {'*'}sub NS_listen {my$sock=shift;${*$sock}{'NS_listen'}=shift if @_;return ${*$sock}{'NS_listen'}}sub NS_unix_type {'SOCK_STREAM'}sub NS_unix_path {shift->NS_port}sub object {my ($class,$info,$server)=@_;if ($class eq __PACKAGE__){$server->configure({unix_type=>\$server->{'server'}->{'unix_type'},unix_path=>\$server->{'server'}->{'unix_path'},})if!exists$server->{'server'}->{'unix_type'};my$u_type=uc(defined($info->{'unix_type'})? $info->{'unix_type'}: defined($server->{'server'}->{'unix_type'})? $server->{'server'}->{'unix_type'}: 'SOCK_STREAM');if ($u_type eq 'SOCK_DGRAM' || $u_type eq ''.SOCK_DGRAM()){require Net::Server::Proto::UNIXDGRAM;return Net::Server::Proto::UNIXDGRAM->object($info,$server)}elsif ($u_type ne 'SOCK_STREAM' && $u_type ne ''.SOCK_STREAM()){$server->fatal("Invalid type for UNIX socket ($u_type)... must be SOCK_STREAM or SOCK_DGRAM")}$info->{'port'}||=$info->{'unix_path'}=$server->{'server'}->{'unix_path'}}my$sock=$class->SUPER::new();my$port=$info->{'port'}=~ m{^ ([\w\.\-\*\/]+) $ }x ? $1 : $server->fatal("Insecure filename");$sock->NS_port($port);$sock->NS_listen(defined($info->{'listen'})? $info->{'listen'}: defined($server->{'server'}->{'listen'})? $server->{'server'}->{'listen'}: Socket::SOMAXCONN());return$sock}sub connect {my ($sock,$server)=@_;my$path=$sock->NS_port;$server->fatal("Can't connect to UNIX socket at file $path [$!]")if -e $path &&!unlink$path;$sock->SUPER::configure({Local=>$path,Type=>SOCK_STREAM,Listen=>$sock->NS_listen,})or $server->fatal("Can't connect to UNIX socket at file $path [$!]")}sub log_connect {my ($sock,$server)=@_;$server->log(2,"Binding to ".$sock->NS_proto." socket file \"".$sock->NS_port."\"")}sub reconnect {my ($sock,$fd,$server)=@_;$sock->fdopen($fd,'w')or $server->fatal("Error opening to file descriptor ($fd) [$!]")}sub hup_string {my$sock=shift;return join "|",$sock->NS_host,$sock->NS_port,$sock->NS_proto,$sock->NS_ipv}sub show {my$sock=shift;return "Ref = \"".ref($sock)."\" (".$sock->hup_string.")\n"}sub read_until {my ($client,$bytes,$end_qr)=@_;die "One of bytes or end_qr should be defined for UNIX read_until\n" if!defined($bytes)&&!defined($end_qr);my$content='';my$ok=0;while (1){$client->read($content,1,length($content));if (defined($bytes)&& length($content)>= $bytes){$ok=2;last}elsif (defined($end_qr)&& $content =~ $end_qr){$ok=1;last}}return wantarray ? ($ok,$content): $content}1;
NET_SERVER_PROTO_UNIX

$fatpacked{"Net/Server/Proto/UNIXDGRAM.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NET_SERVER_PROTO_UNIXDGRAM';
  package Net::Server::Proto::UNIXDGRAM;use strict;use base qw(Net::Server::Proto::UNIX);use Socket qw(SOCK_DGRAM);my@udp_args=qw(udp_recv_len udp_recv_flags udp_broadcast);sub NS_proto {'UNIXDGRAM'}sub NS_recv_len {my$sock=shift;${*$sock}{'NS_recv_len'}=shift if @_;return ${*$sock}{'NS_recv_len'}}sub NS_recv_flags {my$sock=shift;${*$sock}{'NS_recv_flags'}=shift if @_;return ${*$sock}{'NS_recv_flags'}}sub NS_unix_type {'SOCK_DGRAM'}sub object {my ($class,$info,$server)=@_;my$udp=$server->{'server'}->{'udp_args'}||=do {my%temp=map {$_=>undef}@udp_args;$server->configure({map {$_=>\$temp{$_}}@udp_args});\%temp};my$len=defined($info->{'udp_recv_len'})? $info->{'udp_recv_len'}: defined($udp->{'udp_recv_len'})? $udp->{'udp_recv_len'}: 4096;$len=($len =~ /^(\d+)$/)? $1 : 4096;my$flg=defined($info->{'udp_recv_flags'})? $info->{'udp_recv_flags'}: defined($udp->{'udp_recv_flags'})? $udp->{'udp_recv_flags'}: 0;$flg=($flg =~ /^(\d+)$/)? $1 : 0;my$sock=$class->SUPER::new();my$port=$info->{'port'}=~ m{^ ([\w\.\-\*\/]+) $ }x ? $1 : $server->fatal("Insecure filename");$sock->NS_port($port);$sock->NS_recv_len($len);$sock->NS_recv_flags($flg);return$sock}sub connect {my ($sock,$server)=@_;my$path=$sock->NS_port;$server->fatal("Can't connect to UNIXDGRAM socket at file $path [$!]")if -e $path &&!unlink$path;$sock->SUPER::configure({Local=>$path,Type=>SOCK_DGRAM,})or $server->fatal("Can't connect to UNIXDGRAM socket at file $path [$!]")}1;
NET_SERVER_PROTO_UNIXDGRAM

$fatpacked{"Net/Server/SIG.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NET_SERVER_SIG';
  package Net::Server::SIG;use strict;use vars qw($VERSION @ISA @EXPORT_OK %_SIG %_SIG_SUB);use Exporter ();$VERSION='0.03';@ISA=qw(Exporter);@EXPORT_OK=qw(register_sig unregister_sig check_sigs);sub register_sig {die 'Usage: register_sig( SIGNAME => \&code_ref )' if @_ % 2;if (@_ > 2){register_sig(shift(),shift())while @_;return}my$sig=shift;my$code_ref=shift;my$ref=ref($code_ref);if (!$ref){if ($code_ref eq 'DEFAULT'){delete$_SIG{$sig};delete$_SIG_SUB{$sig};$SIG{$sig}='DEFAULT'}elsif ($code_ref eq 'IGNORE'){delete$_SIG{$sig};delete$_SIG_SUB{$sig};$SIG{$sig}='IGNORE'}else {die "Scalar argument limited to \"DEFAULT\" and \"IGNORE\"."}}elsif ($ref eq 'CODE'){$_SIG{$sig}=0;$_SIG_SUB{$sig}=$code_ref;$SIG{$sig}=sub{$Net::Server::SIG::_SIG{$sig}=1}}else {die "Unsupported sig type -- must be 'DEFAULT' or a code ref."}}sub unregister_sig {register_sig(shift(),'DEFAULT')}sub check_sigs {my@found;for my$sig (keys%_SIG){next if!$_SIG{$sig};$_SIG{$sig}=0;push@found,$sig;$_SIG_SUB{$sig}->($sig)}return@found}sub sig_is_registered {my$sig=shift;return$_SIG_SUB{$sig}}1;
NET_SERVER_SIG

$fatpacked{"Statistics/Descriptive/Discrete.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'STATISTICS_DESCRIPTIVE_DISCRETE';
  package Statistics::Descriptive::Discrete;use strict;use warnings;use Carp;use SelfLoader qw();use vars qw($VERSION $REVISION $AUTOLOAD $DEBUG %autosubs);$VERSION='0.07';$REVISION='$Revision: 1.14 $';$DEBUG=0;%autosubs=(count=>undef,mean=>undef,sum=>undef,uniq=>undef,mode=>undef,median=>undef,min=>undef,max=>undef,standard_deviation=>undef,sample_range=>undef,variance=>undef,text=>undef,);sub new {my$proto=shift;my$class=ref($proto)|| $proto;my$self={};$self->{permitted}=\%autosubs;$self->{data}=();$self->{dirty}=1;bless ($self,$class);print __PACKAGE__,"->new(",join(',',@_),")\n" if$DEBUG;return$self}sub add_data {my$self=shift;print __PACKAGE__,"->add_data(",join(',',@_),")\n" if$DEBUG;my$val=shift;while (defined$val){$val += 0;$self->{data}{$val}++;$self->{dirty}++;$val=shift}}sub add_data_tuple {my$self=shift;print __PACKAGE__,"->add_data_tuple(",join(',',@_),")\n" if$DEBUG;carp "argument list must have even number of elements" if @_ % 2;my$val=shift;my$count=shift;while (defined$count){$val += 0;$self->{data}{$val}+= $count;$self->{dirty}++;$val=shift;$count=shift}}sub _all_stats {my$self=shift;print __PACKAGE__,"->_all_stats(",join(',',@_),")\n" if$DEBUG;my$count=0;$count += $_ foreach (values %{$self->{data}});my$uniq=keys %{$self->{data}};my$default=(keys %{$self->{data}})[0];$default=0 if (!defined$default);my$max=$default;my$min=$default;my$mode=$default;my$moden=0;my$sum=0;for (keys %{$self->{data}}){my$n=$self->{data}{$_};$sum += $_ * $n;$min=$_ if $_ < $min;$max=$_ if $_ > $max;if ($n > $moden){$mode=$_;$moden=$n}}my$mean=0;$mean=$sum/$count if ($count);my$stddev=0;my$variance=0;if ($count > 1){for my$val (keys %{$self->{data}}){$stddev += $self->{data}{$val}* (($val - $mean)** 2)}$variance=$stddev / ($count - 1);$stddev=sqrt($variance)}my$odd=$count % 2;my$even=!$odd;my$k=$odd ? ($count-1)/2 : $count/2;my$median=0;my$temp=0;MEDIAN: foreach my$val (sort {$a <=> $b}(keys %{$self->{data}})){for (1..$self->{data}{$val}){$temp++;if (($temp==$k)&& $even){$median += $val}elsif ($temp==$k+1){$median += $val;$median /= 2 if$even;last MEDIAN}}}$self->{count}=$count;$self->{uniq}=$uniq;$self->{sum}=$sum;$self->{standard_deviation}=$stddev;$self->{variance}=$variance;$self->{min}=$min;$self->{max}=$max;$self->{sample_range}=$max - $min;$self->{mean}=$mean;$self->{median}=$median;$self->{mode}=$mode;$self->{dirty}=0}sub set_text {my$self=shift;$self->{text}=shift}sub get_data {my$self=shift;print __PACKAGE__,"->get_data(",join(',',@_),")\n" if$DEBUG;my@data;for my$val (sort {$a <=> $b}(keys %{$self->{data}})){push@data,$val foreach (1..$self->{data}{$val})}return@data}sub frequency_distribution {my$self=shift;print __PACKAGE__,"->frequency_distribution(",join(',',@_),")\n" if$DEBUG;my$partitions=shift;my$minbin=shift;my$binsize=shift;if (defined$partitions && ($partitions==0)){$self->{frequency_partitions}=0;%{$self->{frequency}}=%{$self->{data}};return %{$self->{frequency}}}return undef unless$partitions >= 1;$self->_all_stats()if$self->{dirty};return undef if$self->{count}< 2;my ($interval,$iter,$max);if (defined$minbin && defined$binsize){$iter=$minbin;$max=$minbin+$partitions*$binsize - $binsize;$interval=$binsize;$iter -= $interval}else {$iter=$self->{min};$max=$self->{max};$interval=$self->{sample_range}/$partitions}my@k;my%bins;while (($iter += $interval)< $max){$bins{$iter}=0;push@k,$iter}$bins{$max}=0;push@k,$max;VALUE: foreach my$val (keys %{$self->{data}}){for my$k (@k){if ($val <= $k){$bins{$k}+= $self->{data}{$val};next VALUE}}}%{$self->{frequency}}=%bins;$self->{frequency_partitions}=$partitions;return %{$self->{frequency}}}sub AUTOLOAD {my$self=shift;my$type=ref($self)or croak "$self is not an object";my$name=$AUTOLOAD;$name =~ s/.*://;return if$name eq "DESTROY";unless (exists$self->{permitted}{$name}){croak "Can't access `$name' field in class $type"}print __PACKAGE__,"->AUTOLOAD $name\n" if$DEBUG;$self->_all_stats()if$self->{dirty};return$self->{$name}}1;
STATISTICS_DESCRIPTIVE_DISCRETE

$fatpacked{"String/ShellQuote.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'STRING_SHELLQUOTE';
  package String::ShellQuote;use strict;use vars qw($VERSION @ISA @EXPORT);require Exporter;$VERSION='1.04';@ISA=qw(Exporter);@EXPORT=qw(shell_quote shell_quote_best_effort shell_comment_quote);sub croak {require Carp;goto&Carp::croak}sub _shell_quote_backend {my@in=@_;my@err=();if (0){require RS::Handy;print RS::Handy::data_dump(\@in)}return \@err,'' unless@in;my$ret='';my$saw_non_equal=0;for (@in){if (!defined $_ or $_ eq ''){$_="''";next}if (s/\x00//g){push@err,"No way to quote string containing null (\\000) bytes"}my$escape=0;if (/=/){if (!$saw_non_equal){$escape=1}}else {$saw_non_equal=1}if (m|[^\w!%+,\-./:=@^]|){$escape=1}if ($escape || (!$saw_non_equal && /=/)){s/'/'\\''/g;s|((?:'\\''){2,})|q{'"} . (q{'} x (length($1) / 4)) . q{"'}|ge;$_="'$_'";s/^''//;s/''$//}}continue {$ret .= "$_ "}chop$ret;return \@err,$ret}sub shell_quote {my ($rerr,$s)=_shell_quote_backend @_;if (@$rerr){my%seen;@$rerr=grep {!$seen{$_}++}@$rerr;my$s=join '',map {"shell_quote(): $_\n"}@$rerr;chomp$s;croak$s}return$s}sub shell_quote_best_effort {my ($rerr,$s)=_shell_quote_backend @_;return$s}sub shell_comment_quote {return '' unless @_;unless (@_==1){croak "Too many arguments to shell_comment_quote " ."(got " .@_ ." expected 1)"}local $_=shift;s/\n/\n#/g;return $_}1;
STRING_SHELLQUOTE

$fatpacked{"Text/Balanced.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEXT_BALANCED';
  package Text::Balanced;use 5.005;use strict;use Exporter ();use SelfLoader;use vars qw { $VERSION @ISA %EXPORT_TAGS};BEGIN {$VERSION='2.03';@ISA='Exporter';%EXPORT_TAGS=(ALL=>[qw{&extract_delimited &extract_bracketed &extract_quotelike &extract_codeblock &extract_variable &extract_tagged &extract_multiple &gen_delimited_pat &gen_extract_tagged &delimited_pat} ],)}Exporter::export_ok_tags('ALL');sub _match_bracketed($$$$$$);sub _match_variable($$);sub _match_codeblock($$$$$$$);sub _match_quotelike($$$$);sub _failmsg {my ($message,$pos)=@_;$@=bless {error=>$message,pos=>$pos,},'Text::Balanced::ErrorMsg'}sub _fail {my ($wantarray,$textref,$message,$pos)=@_;_failmsg$message,$pos if$message;return (undef,$$textref,undef)if$wantarray;return undef}sub _succeed {$@=undef;my ($wantarray,$textref)=splice @_,0,2;my ($extrapos,$extralen)=@_ > 18 ? splice(@_,-2,2): (0,0);my ($startlen,$oppos)=@_[5,6];my$remainderpos=$_[2];if ($wantarray){my@res;while (my ($from,$len)=splice @_,0,2){push@res,substr($$textref,$from,$len)}if ($extralen){my$extra=substr($res[0],$extrapos-$oppos,$extralen,"\n");$res[1]="$extra$res[1]";eval {substr($$textref,$remainderpos,0)=$extra;substr($$textref,$extrapos,$extralen,"\n")};pos($$textref)=$remainderpos-$extralen+1}else {pos($$textref)=$remainderpos}return@res}else {my$match=substr($$textref,$_[0],$_[1]);substr($match,$extrapos-$_[0]-$startlen,$extralen,"")if$extralen;my$extra=$extralen ? substr($$textref,$extrapos,$extralen)."\n" : "";eval {substr($$textref,$_[4],$_[1]+$_[5])=$extra};pos($$textref)=$_[4];return$match}}sub gen_delimited_pat($;$) {my ($dels,$escs)=@_;return "" unless$dels =~ /\S/;$escs='\\' unless$escs;$escs .= substr($escs,-1)x (length($dels)-length($escs));my@pat=();my$i;for ($i=0;$i<length$dels;$i++){my$del=quotemeta substr($dels,$i,1);my$esc=quotemeta substr($escs,$i,1);if ($del eq $esc){push@pat,"$del(?:[^$del]*(?:(?:$del$del)[^$del]*)*)$del"}else {push@pat,"$del(?:[^$esc$del]*(?:$esc.[^$esc$del]*)*)$del"}}my$pat=join '|',@pat;return "(?:$pat)"}*delimited_pat=\&gen_delimited_pat;sub extract_delimited (;$$$$) {my$textref=defined $_[0]? \$_[0]: \$_;my$wantarray=wantarray;my$del=defined $_[1]? $_[1]: qq{\'\"\`};my$pre=defined $_[2]? $_[2]: '\s*';my$esc=defined $_[3]? $_[3]: qq{\\};my$pat=gen_delimited_pat($del,$esc);my$startpos=pos $$textref || 0;return _fail($wantarray,$textref,"Not a delimited pattern",0)unless $$textref =~ m/\G($pre)($pat)/gc;my$prelen=length($1);my$matchpos=$startpos+$prelen;my$endpos=pos $$textref;return _succeed$wantarray,$textref,$matchpos,$endpos-$matchpos,$endpos,length($$textref)-$endpos,$startpos,$prelen}sub extract_bracketed (;$$$) {my$textref=defined $_[0]? \$_[0]: \$_;my$ldel=defined $_[1]? $_[1]: '{([<';my$pre=defined $_[2]? $_[2]: '\s*';my$wantarray=wantarray;my$qdel="";my$quotelike;$ldel =~ s/'//g and $qdel .= q{'};$ldel =~ s/"//g and $qdel .= q{"};$ldel =~ s/`//g and $qdel .= q{`};$ldel =~ s/q//g and $quotelike=1;$ldel =~ tr/[](){}<>\0-\377/[[(({{<</ds;my$rdel=$ldel;unless ($rdel =~ tr/[({</])}>/){return _fail$wantarray,$textref,"Did not find a suitable bracket in delimiter: \"$_[1]\"",0}my$posbug=pos;$ldel=join('|',map {quotemeta $_}split('',$ldel));$rdel=join('|',map {quotemeta $_}split('',$rdel));pos=$posbug;my$startpos=pos $$textref || 0;my@match=_match_bracketed($textref,$pre,$ldel,$qdel,$quotelike,$rdel);return _fail ($wantarray,$textref)unless@match;return _succeed ($wantarray,$textref,$match[2],$match[5]+2,@match[8,9],@match[0,1],)}sub _match_bracketed($$$$$$) {my ($textref,$pre,$ldel,$qdel,$quotelike,$rdel)=@_;my ($startpos,$ldelpos,$endpos)=(pos $$textref=pos $$textref||0);unless ($$textref =~ m/\G$pre/gc){_failmsg "Did not find prefix: /$pre/",$startpos;return}$ldelpos=pos $$textref;unless ($$textref =~ m/\G($ldel)/gc){_failmsg "Did not find opening bracket after prefix: \"$pre\"",pos $$textref;pos $$textref=$startpos;return}my@nesting=($1);my$textlen=length $$textref;while (pos $$textref < $textlen){next if $$textref =~ m/\G\\./gcs;if ($$textref =~ m/\G($ldel)/gc){push@nesting,$1}elsif ($$textref =~ m/\G($rdel)/gc){my ($found,$brackettype)=($1,$1);if ($#nesting < 0){_failmsg "Unmatched closing bracket: \"$found\"",pos $$textref;pos $$textref=$startpos;return}my$expected=pop(@nesting);$expected =~ tr/({[</)}]>/;if ($expected ne $brackettype){_failmsg qq{Mismatched closing bracket: expected "$expected" but found "$found"},pos $$textref;pos $$textref=$startpos;return}last if $#nesting < 0}elsif ($qdel && $$textref =~ m/\G([$qdel])/gc){$$textref =~ m/\G[^\\$1]*(?:\\.[^\\$1]*)*(\Q$1\E)/gsc and next;_failmsg "Unmatched embedded quote ($1)",pos $$textref;pos $$textref=$startpos;return}elsif ($quotelike && _match_quotelike($textref,"",1,0)){next}else {$$textref =~ m/\G(?:[a-zA-Z0-9]+|.)/gcs}}if ($#nesting>=0){_failmsg "Unmatched opening bracket(s): " .join("..",@nesting)."..",pos $$textref;pos $$textref=$startpos;return}$endpos=pos $$textref;return ($startpos,$ldelpos-$startpos,$ldelpos,1,$ldelpos+1,$endpos-$ldelpos-2,$endpos-1,1,$endpos,length($$textref)-$endpos,)}sub _revbracket($) {my$brack=reverse $_[0];$brack =~ tr/[({</])}>/;return$brack}my$XMLNAME=q{[a-zA-Z_:][a-zA-Z0-9_:.-]*};sub extract_tagged (;$$$$$) {my$textref=defined $_[0]? \$_[0]: \$_;my$ldel=$_[1];my$rdel=$_[2];my$pre=defined $_[3]? $_[3]: '\s*';my%options=defined $_[4]? %{$_[4]}: ();my$omode=defined$options{fail}? $options{fail}: '';my$bad=ref($options{reject})eq 'ARRAY' ? join('|',@{$options{reject}}): defined($options{reject})? $options{reject}: '' ;my$ignore=ref($options{ignore})eq 'ARRAY' ? join('|',@{$options{ignore}}): defined($options{ignore})? $options{ignore}: '' ;if (!defined$ldel){$ldel='<\w+(?:' .gen_delimited_pat(q{'"}).'|[^>])*>'}$@=undef;my@match=_match_tagged($textref,$pre,$ldel,$rdel,$omode,$bad,$ignore);return _fail(wantarray,$textref)unless@match;return _succeed wantarray,$textref,$match[2],$match[3]+$match[5]+$match[7],@match[8..9,0..1,2..7]}sub _match_tagged {my ($textref,$pre,$ldel,$rdel,$omode,$bad,$ignore)=@_;my$rdelspec;my ($startpos,$opentagpos,$textpos,$parapos,$closetagpos,$endpos)=(pos($$textref)=pos($$textref)||0);unless ($$textref =~ m/\G($pre)/gc){_failmsg "Did not find prefix: /$pre/",pos $$textref;goto failed}$opentagpos=pos($$textref);unless ($$textref =~ m/\G$ldel/gc){_failmsg "Did not find opening tag: /$ldel/",pos $$textref;goto failed}$textpos=pos($$textref);if (!defined$rdel){$rdelspec=substr($$textref,$-[0],$+[0]- $-[0]);unless ($rdelspec =~ s/\A([[(<{]+)($XMLNAME).*/ quotemeta "$1\/$2". _revbracket($1) /oes){_failmsg "Unable to construct closing tag to match: $rdel",pos $$textref;goto failed}}else {$rdelspec=eval "qq{$rdel}" || do {my$del;for (qw,~ ! ^ & * ) _ + - = } ] : " ; ' > . ? / | ',){next if$rdel =~ /\Q$_/;$del=$_;last}unless ($del){use Carp;croak "Can't interpolate right delimiter $rdel"}eval "qq$del$rdel$del"}}while (pos($$textref)< length($$textref)){next if $$textref =~ m/\G\\./gc;if ($$textref =~ m/\G(\n[ \t]*\n)/gc){$parapos=pos($$textref)- length($1)unless defined$parapos}elsif ($$textref =~ m/\G($rdelspec)/gc){$closetagpos=pos($$textref)-length($1);goto matched}elsif ($ignore && $$textref =~ m/\G(?:$ignore)/gc){next}elsif ($bad && $$textref =~ m/\G($bad)/gcs){pos($$textref)-= length($1);goto short if ($omode eq 'PARA' || $omode eq 'MAX');_failmsg "Found invalid nested tag: $1",pos $$textref;goto failed}elsif ($$textref =~ m/\G($ldel)/gc){my$tag=$1;pos($$textref)-= length($tag);unless (_match_tagged(@_)){goto short if$omode eq 'PARA' || $omode eq 'MAX';_failmsg "Found unbalanced nested tag: $tag",pos $$textref;goto failed}}else {$$textref =~ m/./gcs}}short: $closetagpos=pos($$textref);goto matched if$omode eq 'MAX';goto failed unless$omode eq 'PARA';if (defined$parapos){pos($$textref)=$parapos}else {$parapos=pos($$textref)}return ($startpos,$opentagpos-$startpos,$opentagpos,$textpos-$opentagpos,$textpos,$parapos-$textpos,$parapos,0,$parapos,length($$textref)-$parapos,);matched: $endpos=pos($$textref);return ($startpos,$opentagpos-$startpos,$opentagpos,$textpos-$opentagpos,$textpos,$closetagpos-$textpos,$closetagpos,$endpos-$closetagpos,$endpos,length($$textref)-$endpos,);failed: _failmsg "Did not find closing tag",pos $$textref unless $@;pos($$textref)=$startpos;return}sub extract_variable (;$$) {my$textref=defined $_[0]? \$_[0]: \$_;return ("","","")unless defined $$textref;my$pre=defined $_[1]? $_[1]: '\s*';my@match=_match_variable($textref,$pre);return _fail wantarray,$textref unless@match;return _succeed wantarray,$textref,@match[2..3,4..5,0..1]}sub _match_variable($$) {my ($textref,$pre)=@_;my$startpos=pos($$textref)=pos($$textref)||0;unless ($$textref =~ m/\G($pre)/gc){_failmsg "Did not find prefix: /$pre/",pos $$textref;return}my$varpos=pos($$textref);unless ($$textref =~ m{\G\$\s*(?!::)(\d+|[][&`'+*./|,";%=~:?!\@<>()-]|\^[a-z]?)}gci){unless ($$textref =~ m/\G((\$#?|[*\@\%]|\\&)+)/gc){_failmsg "Did not find leading dereferencer",pos $$textref;pos $$textref=$startpos;return}my$deref=$1;unless ($$textref =~ m/\G\s*(?:::|')?(?:[_a-z]\w*(?:::|'))*[_a-z]\w*/gci or _match_codeblock($textref,"",'\{','\}','\{','\}',0)or $deref eq '$#' or $deref eq '$$'){_failmsg "Bad identifier after dereferencer",pos $$textref;pos $$textref=$startpos;return}}while (1){next if $$textref =~ m/\G\s*(?:->)?\s*[{]\w+[}]/gc;next if _match_codeblock($textref,qr/\s*->\s*(?:[_a-zA-Z]\w+\s*)?/,qr/[({[]/,qr/[)}\]]/,qr/[({[]/,qr/[)}\]]/,0);next if _match_codeblock($textref,qr/\s*/,qr/[{[]/,qr/[}\]]/,qr/[{[]/,qr/[}\]]/,0);next if _match_variable($textref,'\s*->\s*');next if $$textref =~ m/\G\s*->\s*\w+(?![{([])/gc;last}my$endpos=pos($$textref);return ($startpos,$varpos-$startpos,$varpos,$endpos-$varpos,$endpos,length($$textref)-$endpos)}sub extract_codeblock (;$$$$$) {my$textref=defined $_[0]? \$_[0]: \$_;my$wantarray=wantarray;my$ldel_inner=defined $_[1]? $_[1]: '{';my$pre=defined $_[2]? $_[2]: '\s*';my$ldel_outer=defined $_[3]? $_[3]: $ldel_inner;my$rd=$_[4];my$rdel_inner=$ldel_inner;my$rdel_outer=$ldel_outer;my$posbug=pos;for ($ldel_inner,$ldel_outer){tr/[]()<>{}\0-\377/[[((<<{{/ds}for ($rdel_inner,$rdel_outer){tr/[]()<>{}\0-\377/]]))>>}}/ds}for ($ldel_inner,$ldel_outer,$rdel_inner,$rdel_outer){$_='('.join('|',map {quotemeta $_}split('',$_)).')'}pos=$posbug;my@match=_match_codeblock($textref,$pre,$ldel_outer,$rdel_outer,$ldel_inner,$rdel_inner,$rd);return _fail($wantarray,$textref)unless@match;return _succeed($wantarray,$textref,@match[2..3,4..5,0..1])}sub _match_codeblock($$$$$$$) {my ($textref,$pre,$ldel_outer,$rdel_outer,$ldel_inner,$rdel_inner,$rd)=@_;my$startpos=pos($$textref)=pos($$textref)|| 0;unless ($$textref =~ m/\G($pre)/gc){_failmsg qq{Did not match prefix /$pre/ at"} .substr($$textref,pos($$textref),20).q{..."},pos $$textref;return}my$codepos=pos($$textref);unless ($$textref =~ m/\G($ldel_outer)/gc){_failmsg qq{Did not find expected opening bracket at "} .substr($$textref,pos($$textref),20).q{..."},pos $$textref;pos $$textref=$startpos;return}my$closing=$1;$closing =~ tr/([<{/)]>}/;my$matched;my$patvalid=1;while (pos($$textref)< length($$textref)){$matched='';if ($rd && $$textref =~ m#\G(\Q(?)\E|\Q(s?)\E|\Q(s)\E)#gc){$patvalid=0;next}if ($$textref =~ m/\G\s*#.*/gc){next}if ($$textref =~ m/\G\s*($rdel_outer)/gc){unless ($matched=($closing && $1 eq $closing)){next if $1 eq '>';_failmsg q{Mismatched closing bracket at "} .substr($$textref,pos($$textref),20).qq{...". Expected '$closing'},pos $$textref}last}if (_match_variable($textref,'\s*')|| _match_quotelike($textref,'\s*',$patvalid,$patvalid)){$patvalid=0;next}if ($$textref =~ m#\G\s*(?!$ldel_inner)
  					( [-+*x/%^&|.]=?
  					| [!=]~
  					| =(?!>)
  					| (\*\*|&&|\|\||<<|>>)=?
  					| split|grep|map|return
  					| [([]
  					)#gcx){$patvalid=1;next}if (_match_codeblock($textref,'\s*',$ldel_inner,$rdel_inner,$ldel_inner,$rdel_inner,$rd)){$patvalid=1;next}if ($$textref =~ m/\G\s*$ldel_outer/gc){_failmsg q{Improperly nested codeblock at "} .substr($$textref,pos($$textref),20).q{..."},pos $$textref;last}$patvalid=0;$$textref =~ m/\G\s*(\w+|[-=>]>|.|\Z)/gc}continue {$@=undef}unless ($matched){_failmsg 'No match found for opening bracket',pos $$textref unless $@;return}my$endpos=pos($$textref);return ($startpos,$codepos-$startpos,$codepos,$endpos-$codepos,$endpos,length($$textref)-$endpos,)}my%mods=('none'=>'[cgimsox]*','m'=>'[cgimsox]*','s'=>'[cegimsox]*','tr'=>'[cds]*','y'=>'[cds]*','qq'=>'','qx'=>'','qw'=>'','qr'=>'[imsx]*','q'=>'',);sub extract_quotelike (;$$) {my$textref=$_[0]? \$_[0]: \$_;my$wantarray=wantarray;my$pre=defined $_[1]? $_[1]: '\s*';my@match=_match_quotelike($textref,$pre,1,0);return _fail($wantarray,$textref)unless@match;return _succeed($wantarray,$textref,$match[2],$match[18]-$match[2],@match[18,19],@match[0,1],@match[2..17],@match[20,21],)};sub _match_quotelike($$$$) {my ($textref,$pre,$rawmatch,$qmark)=@_;my ($textlen,$startpos,$oppos,$preld1pos,$ld1pos,$str1pos,$rd1pos,$preld2pos,$ld2pos,$str2pos,$rd2pos,$modpos)=(length($$textref),pos($$textref)=pos($$textref)|| 0);unless ($$textref =~ m/\G($pre)/gc){_failmsg qq{Did not find prefix /$pre/ at "} .substr($$textref,pos($$textref),20).q{..."},pos $$textref;return}$oppos=pos($$textref);my$initial=substr($$textref,$oppos,1);if ($initial && $initial =~ m|^[\"\'\`]| || $rawmatch && $initial =~ m|^/| || $qmark && $initial =~ m|^\?|){unless ($$textref =~ m/ \Q$initial\E [^\\$initial]* (\\.[^\\$initial]*)* \Q$initial\E /gcsx){_failmsg qq{Did not find closing delimiter to match '$initial' at "} .substr($$textref,$oppos,20).q{..."},pos $$textref;pos $$textref=$startpos;return}$modpos=pos($$textref);$rd1pos=$modpos-1;if ($initial eq '/' || $initial eq '?'){$$textref =~ m/\G$mods{none}/gc}my$endpos=pos($$textref);return ($startpos,$oppos-$startpos,$oppos,0,$oppos,1,$oppos+1,$rd1pos-$oppos-1,$rd1pos,1,$modpos,0,$modpos,0,$modpos,0,$modpos,$endpos-$modpos,$endpos,$textlen-$endpos,)}unless ($$textref =~ m{\G(\b(?:m|s|qq|qx|qw|q|qr|tr|y)\b(?=\s*\S)|<<)}gc){_failmsg q{No quotelike operator found after prefix at "} .substr($$textref,pos($$textref),20).q{..."},pos $$textref;pos $$textref=$startpos;return}my$op=$1;$preld1pos=pos($$textref);if ($op eq '<<'){$ld1pos=pos($$textref);my$label;if ($$textref =~ m{\G([A-Za-z_]\w*)}gc){$label=$1}elsif ($$textref =~ m{ \G ' ([^'\\]* (?:\\.[^'\\]*)*) '
  				     | \G " ([^"\\]* (?:\\.[^"\\]*)*) "
  				     | \G ` ([^`\\]* (?:\\.[^`\\]*)*) `
  				     }gcsx){$label=$+}else {$label=""}my$extrapos=pos($$textref);$$textref =~ m{.*\n}gc;$str1pos=pos($$textref)--;unless ($$textref =~ m{.*?\n(?=\Q$label\E\n)}gc){_failmsg qq{Missing here doc terminator ('$label') after "} .substr($$textref,$startpos,20).q{..."},pos $$textref;pos $$textref=$startpos;return}$rd1pos=pos($$textref);$$textref =~ m{\Q$label\E\n}gc;$ld2pos=pos($$textref);return ($startpos,$oppos-$startpos,$oppos,length($op),$ld1pos,$extrapos-$ld1pos,$str1pos,$rd1pos-$str1pos,$rd1pos,$ld2pos-$rd1pos,$ld2pos,0,$ld2pos,0,$ld2pos,0,$ld2pos,0,$ld2pos,$textlen-$ld2pos,$extrapos,$str1pos-$extrapos,)}$$textref =~ m/\G\s*/gc;$ld1pos=pos($$textref);$str1pos=$ld1pos+1;unless ($$textref =~ m/\G(\S)/gc){_failmsg "No block delimiter found after quotelike $op",pos $$textref;pos $$textref=$startpos;return}pos($$textref)=$ld1pos;my ($ldel1,$rdel1)=("\Q$1","\Q$1");if ($ldel1 =~ /[[(<{]/){$rdel1 =~ tr/[({</])}>/;defined(_match_bracketed($textref,"",$ldel1,"","",$rdel1))|| do {pos $$textref=$startpos;return};$ld2pos=pos($$textref);$rd1pos=$ld2pos-1}else {$$textref =~ /\G$ldel1[^\\$ldel1]*(\\.[^\\$ldel1]*)*$ldel1/gcs || do {pos $$textref=$startpos;return};$ld2pos=$rd1pos=pos($$textref)-1}my$second_arg=$op =~ /s|tr|y/ ? 1 : 0;if ($second_arg){my ($ldel2,$rdel2);if ($ldel1 =~ /[[(<{]/){unless ($$textref =~ /\G\s*(\S)/gc){_failmsg "Missing second block for quotelike $op",pos $$textref;pos $$textref=$startpos;return}$ldel2=$rdel2="\Q$1";$rdel2 =~ tr/[({</])}>/}else {$ldel2=$rdel2=$ldel1}$str2pos=$ld2pos+1;if ($ldel2 =~ /[[(<{]/){pos($$textref)--;defined(_match_bracketed($textref,"",$ldel2,"","",$rdel2))|| do {pos $$textref=$startpos;return}}else {$$textref =~ /[^\\$ldel2]*(\\.[^\\$ldel2]*)*$ldel2/gcs || do {pos $$textref=$startpos;return}}$rd2pos=pos($$textref)-1}else {$ld2pos=$str2pos=$rd2pos=$rd1pos}$modpos=pos $$textref;$$textref =~ m/\G($mods{$op})/gc;my$endpos=pos $$textref;return ($startpos,$oppos-$startpos,$oppos,length($op),$ld1pos,1,$str1pos,$rd1pos-$str1pos,$rd1pos,1,$ld2pos,$second_arg,$str2pos,$rd2pos-$str2pos,$rd2pos,$second_arg,$modpos,$endpos-$modpos,$endpos,$textlen-$endpos,)}my$def_func=[sub {extract_variable($_[0],'')},sub {extract_quotelike($_[0],'')},sub {extract_codeblock($_[0],'{}','')},];sub extract_multiple (;$$$$) {my$textref=defined($_[0])? \$_[0]: \$_;my$posbug=pos;my ($lastpos,$firstpos);my@fields=();{my@func=defined $_[1]? @{$_[1]}: @{$def_func};my$max=defined $_[2]&& $_[2]>0 ? $_[2]: 1_000_000_000;my$igunk=$_[3];pos $$textref ||=0;unless (wantarray){use Carp;carp "extract_multiple reset maximal count to 1 in scalar context" if $^W && defined($_[2])&& $max > 1;$max=1}my$unkpos;my$func;my$class;my@class;for$func (@func){if (ref($func)eq 'HASH'){push@class,(keys %$func)[0];$func=(values %$func)[0]}else {push@class,undef}}FIELD: while (pos($$textref)< length($$textref)){my ($field,$rem);my@bits;for my$i (0..$#func){my$pref;$func=$func[$i];$class=$class[$i];$lastpos=pos $$textref;if (ref($func)eq 'CODE'){($field,$rem,$pref)=@bits=$func->($$textref)}elsif (ref($func)eq 'Text::Balanced::Extractor'){@bits=$field=$func->extract($$textref)}elsif($$textref =~ m/\G$func/gc){@bits=$field=defined($1)? $1 : substr($$textref,$-[0],$+[0]- $-[0])}$pref ||="";if (defined($field)&& length($field)){if (!$igunk){$unkpos=$lastpos if length($pref)&&!defined($unkpos);if (defined$unkpos){push@fields,substr($$textref,$unkpos,$lastpos-$unkpos).$pref;$firstpos=$unkpos unless defined$firstpos;undef$unkpos;last FIELD if@fields==$max}}push@fields,$class ? bless (\$field,$class): $field;$firstpos=$lastpos unless defined$firstpos;$lastpos=pos $$textref;last FIELD if@fields==$max;next FIELD}}if ($$textref =~ /\G(.)/gcs){$unkpos=pos($$textref)-1 unless$igunk || defined$unkpos}}if (defined$unkpos){push@fields,substr($$textref,$unkpos);$firstpos=$unkpos unless defined$firstpos;$lastpos=length $$textref}last}pos $$textref=$lastpos;return@fields if wantarray;$firstpos ||=0;eval {substr($$textref,$firstpos,$lastpos-$firstpos)="";pos $$textref=$firstpos};return$fields[0]}sub gen_extract_tagged {my$ldel=$_[0];my$rdel=$_[1];my$pre=defined $_[2]? $_[2]: '\s*';my%options=defined $_[3]? %{$_[3]}: ();my$omode=defined$options{fail}? $options{fail}: '';my$bad=ref($options{reject})eq 'ARRAY' ? join('|',@{$options{reject}}): defined($options{reject})? $options{reject}: '' ;my$ignore=ref($options{ignore})eq 'ARRAY' ? join('|',@{$options{ignore}}): defined($options{ignore})? $options{ignore}: '' ;if (!defined$ldel){$ldel='<\w+(?:' .gen_delimited_pat(q{'"}).'|[^>])*>'}my$posbug=pos;for ($ldel,$pre,$bad,$ignore){$_=qr/$_/ if $_}pos=$posbug;my$closure=sub {my$textref=defined $_[0]? \$_[0]: \$_;my@match=Text::Balanced::_match_tagged($textref,$pre,$ldel,$rdel,$omode,$bad,$ignore);return _fail(wantarray,$textref)unless@match;return _succeed wantarray,$textref,$match[2],$match[3]+$match[5]+$match[7],@match[8..9,0..1,2..7]};bless$closure,'Text::Balanced::Extractor'}package Text::Balanced::Extractor;sub extract($$) {&{$_[0]}($_[1])}package Text::Balanced::ErrorMsg;use overload '""'=>sub {"$_[0]->{error}, detected at offset $_[0]->{pos}"};1;
TEXT_BALANCED

$fatpacked{"Tie/IxHash.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TIE_IXHASH';
  require 5.005;package Tie::IxHash;use strict;use integer;require Tie::Hash;use vars qw/@ISA $VERSION/;@ISA=qw(Tie::Hash);$VERSION=$VERSION='1.23';sub TIEHASH {my($c)=shift;my($s)=[];$s->[0]={};$s->[1]=[];$s->[2]=[];$s->[3]=0;bless$s,$c;$s->Push(@_)if @_;return$s}sub FETCH {my($s,$k)=(shift,shift);return exists($s->[0]{$k})? $s->[2][$s->[0]{$k}]: undef}sub STORE {my($s,$k,$v)=(shift,shift,shift);if (exists$s->[0]{$k}){my($i)=$s->[0]{$k};$s->[1][$i]=$k;$s->[2][$i]=$v;$s->[0]{$k}=$i}else {push(@{$s->[1]},$k);push(@{$s->[2]},$v);$s->[0]{$k}=$#{$s->[1]}}}sub DELETE {my($s,$k)=(shift,shift);if (exists$s->[0]{$k}){my($i)=$s->[0]{$k};for ($i+1..$#{$s->[1]}){$s->[0]{$s->[1][$_]}--}if ($i==$s->[3]-1){$s->[3]--}delete$s->[0]{$k};splice @{$s->[1]},$i,1;return (splice(@{$s->[2]},$i,1))[0]}return undef}sub EXISTS {exists $_[0]->[0]{$_[1]}}sub FIRSTKEY {$_[0][3]=0;&NEXTKEY}sub NEXTKEY {return $_[0][1][$_[0][3]++ ]if ($_[0][3]<= $#{$_[0][1]});return undef}sub new {TIEHASH(@_)}sub Clear {my$s=shift;$s->[0]={};$s->[1]=[];$s->[2]=[];$s->[3]=0;return}sub Push {my($s)=shift;while (@_){$s->STORE(shift,shift)}return scalar(@{$s->[1]})}sub Push2 {my($s)=shift;$s->Splice($#{$s->[1]}+1,0,@_);return scalar(@{$s->[1]})}sub Pop {my($s)=shift;my($k,$v,$i);$k=pop(@{$s->[1]});$v=pop(@{$s->[2]});if (defined$k){delete$s->[0]{$k};return ($k,$v)}return undef}sub Pop2 {return $_[0]->Splice(-1)}sub Shift {my($s)=shift;my($k,$v,$i);$k=shift(@{$s->[1]});$v=shift(@{$s->[2]});if (defined$k){delete$s->[0]{$k};for (keys %{$s->[0]}){$s->[0]{$_}--}return ($k,$v)}return undef}sub Shift2 {return $_[0]->Splice(0,1)}sub Unshift {my($s)=shift;my($k,$v,@k,@v,$len,$i);while (@_){($k,$v)=(shift,shift);if (exists$s->[0]{$k}){$i=$s->[0]{$k};$s->[1][$i]=$k;$s->[2][$i]=$v;$s->[0]{$k}=$i}else {push(@k,$k);push(@v,$v);$len++}}if (defined$len){for (keys %{$s->[0]}){$s->[0]{$_}+= $len}$i=0;for (@k){$s->[0]{$_}=$i++}unshift(@{$s->[1]},@k);return unshift(@{$s->[2]},@v)}return scalar(@{$s->[1]})}sub Unshift2 {my($s)=shift;$s->Splice(0,0,@_);return scalar(@{$s->[1]})}sub Splice {my($s,$start,$len)=(shift,shift,shift);my($k,$v,@k,@v,@r,$i,$siz);my($end);($start,$end,$len)=$s->_lrange($start,$len);if (defined$start){if ($len > 0){my(@k)=splice(@{$s->[1]},$start,$len);my(@v)=splice(@{$s->[2]},$start,$len);while (@k){$k=shift(@k);delete$s->[0]{$k};push(@r,$k,shift(@v))}for ($start..$#{$s->[1]}){$s->[0]{$s->[1][$_]}-= $len}}while (@_){($k,$v)=(shift,shift);if (exists$s->[0]{$k}){$i=$s->[0]{$k};$s->[1][$i]=$k;$s->[2][$i]=$v;$s->[0]{$k}=$i}else {push(@k,$k);push(@v,$v);$siz++}}if (defined$siz){for ($start..$#{$s->[1]}){$s->[0]{$s->[1][$_]}+= $siz}$i=$start;for (@k){$s->[0]{$_}=$i++}splice(@{$s->[1]},$start,0,@k);splice(@{$s->[2]},$start,0,@v)}}return@r}sub Delete {my($s)=shift;for (@_){$s->DELETE($_)}}sub Replace {my($s)=shift;my($i,$v,$k)=(shift,shift,shift);if (defined$i and $i <= $#{$s->[1]}and $i >= 0){if (defined$k){delete$s->[0]{$s->[1][$i]};$s->DELETE($k);$s->[1][$i]=$k;$s->[2][$i]=$v;$s->[0]{$k}=$i;return$k}else {$s->[2][$i]=$v;return$s->[1][$i]}}return undef}sub _lrange {my($s)=shift;my($offset,$len)=@_;my($start,$end);my($size)=$#{$s->[1]}+1;return undef unless defined$offset;if($offset < 0){$start=$offset + $size;$start=0 if$start < 0}else {($offset > $size)? ($start=$size): ($start=$offset)}if (defined$len){$len=-$len if$len < 0;$len=$size - $start if$len > $size - $start}else {$len=$size - $start}$end=$start + $len - 1;return ($start,$end,$len)}sub Keys {my($s)=shift;return (@_==1 ? $s->[1][$_[0]]: (@_ ? @{$s->[1]}[@_]: @{$s->[1]}))}sub Values {my($s)=shift;return (@_==1 ? $s->[2][$_[0]]: (@_ ? @{$s->[2]}[@_]: @{$s->[2]}))}sub Indices {my($s)=shift;return (@_==1 ? $s->[0]{$_[0]}: @{$s->[0]}{@_})}sub Length {return scalar @{$_[0]->[1]}}sub Reorder {my($s)=shift;my(@k,@v,%x,$i);return unless @_;$i=0;for (@_){if (exists$s->[0]{$_}){push(@k,$_);push(@v,$s->[2][$s->[0]{$_}]);$x{$_}=$i++}}$s->[1]=\@k;$s->[2]=\@v;$s->[0]=\%x;return$s}sub SortByKey {my($s)=shift;$s->Reorder(sort$s->Keys)}sub SortByValue {my($s)=shift;$s->Reorder(sort {$s->FETCH($a)cmp $s->FETCH($b)}$s->Keys)}1;
TIE_IXHASH

$fatpacked{"Tk/ROTextHighlight.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TK_ROTEXTHIGHLIGHT';
  package Tk::ROTextHighlight;use vars qw($VERSION);$VERSION='1.1.1';use base qw(Tk::Derived Tk::ROText);use strict;use Storable;use File::Basename;my$blockHighlight=0;my$nodoEvent=0;Construct Tk::Widget 'ROTextHighlight';sub Populate {my ($cw,$args)=@_;$cw->SUPER::Populate($args);$cw->ConfigSpecs(-autoindent=>[qw/PASSIVE autoindent Autoindent/,0],-match=>[qw/PASSIVE match Match/,'[]{}()'],-matchoptions=>[qw/METHOD matchoptions Matchoptions/,[-background=>'red',-foreground=>'yellow']],-indentchar=>[qw/PASSIVE indentchar Indentchar/,"\t"],-disablemenu=>[qw/PASSIVE disablemenu Disablemenu/,0],-commentchar=>[qw/PASSIVE commentchar Commentchar/,"#"],-colorinf=>[qw/PASSIVE undef undef/,[]],-colored=>[qw/PASSIVE undef undef/,0],-syntax=>[qw/PASSIVE syntax Syntax/,'None'],-rules=>[qw/PASSIVE undef undef/,undef],-rulesdir=>[qw/PASSIVE rulesdir Rulesdir/,''],-updatecall=>[qw/PASSIVE undef undef/,sub {}],-noRulesMenu=>[qw/PASSIVE undef undef/,0],-noSyntaxMenu=>[qw/PASSIVE undef undef/,0],-noRulesEditMenu=>[qw/PASSIVE undef undef/,0],-noSaveRulesMenu=>[qw/PASSIVE undef undef/,0],-noPlugInit=>[qw/PASSIVE undef undef/,0],-highlightInBackground=>[qw/PASSIVE undef undef/,0],DEFAULT=>['SELF' ],);$cw->bind('<Configure>',sub {$cw->highlightVisual});$cw->bind('<Return>',sub {$cw->doAutoIndent});$cw->markSet('match','0.0');$cw->bind('<Control-p>',\&jumpToMatchingChar)}sub jumpToMatchingChar {my$cw=shift;$cw->markSet('insert',$cw->index('insert'));my$pm=-1;eval {$pm=$cw->index('MyMatch')};if ($pm >= 0){my$prevMatch=$cw->index('insert');$prevMatch .= '.0' unless ($prevMatch =~ /\./o);$cw->markSet('insert',$cw->index('MyMatch'));$cw->see('insert');$cw->markSet('MyMatch',$prevMatch)}}sub ClassInit {my ($class,$w)=@_;$class->SUPER::ClassInit($w);$w->bind($class,'<Control-p>',sub {});return$class}sub clipboardCopy {my$cw=shift;my@ranges=$cw->tagRanges('sel');if (@ranges){$cw->SUPER::clipboardCopy(@_)}}sub clipboardCut {my$cw=shift;my@ranges=$cw->tagRanges('sel');if (@ranges){$cw->SUPER::clipboardCut(@_)}}sub clipboardPaste {my$cw=shift;my@ranges=$cw->tagRanges('sel');if (@ranges){$cw->tagRemove('sel','1.0','end');return}$cw->SUPER::clipboardPaste(@_)}sub delete {my$cw=shift;my$begin=$_[0];if (defined($begin)){$begin=$cw->linenumber($begin)}else {$begin=$cw->linenumber('insert')};my$end=$_[1];if (defined($end)){$end=$cw->linenumber($end)}else {$end=$begin};$cw->SUPER::delete(@_);$cw->highlightCheck($begin,$end)}sub doAutoIndent {my$cw=shift;if ($cw->cget('-autoindent')){my$i=$cw->index('insert linestart');if ($cw->compare($i,">",'0.0')){my$s=$cw->get("$i - 1 lines","$i - 1 lines lineend");$s =~ /^(\s*)/o;if ($1){$cw->insert('insert',$1)}$cw->insert('insert',$cw->cget('-indentchar'))if ($s =~ /\{\s*$/o)}}}sub EditMenuItems {my$cw=shift;return [@{$cw->SUPER::EditMenuItems},"-",["command"=>'Comment',-command=>[$cw=>'selectionComment']],["command"=>'Uncomment',-command=>[$cw=>'selectionUnComment']],"-",["command"=>'Indent',-command=>[$cw=>'selectionIndent']],["command"=>'Unindent',-command=>[$cw=>'selectionUnIndent']],]}sub EmptyDocument {my$cw=shift;my@r=$cw->SUPER::EmptyDocument(@_);$cw->highlightPurge(1);return@r}sub highlight {my ($cw,$begin,$end)=@_;$blockHighlight=1;if (not defined($end)){$end=$begin + 1};my@sel=$cw->tagRanges('sel');while ($begin < $end){$cw->highlightLine($begin);$begin++};$blockHighlight=0;return$begin}sub highlightCheck {my ($cw,$begin,$end)=@_;my$col=$cw->cget('-colored');my$cli=$cw->cget('-colorinf');if ($begin <= $col){if ($begin < $end){$cw->highlightPurge($begin)}else {my$hlt=$cw->highlightPlug;my$i=$cli->[$begin];$cw->highlight($begin);if (($col < $cw->linenumber('end'))and (not $hlt->stateCompare($i))){$cw->highlightPurge($begin)}};$cw->matchCheck}else {$cw->highlightVisual}}sub highlightLine {my ($cw,$num)=@_;my$hlt=$cw->highlightPlug;my$cli=$cw->cget('-colorinf');my$k=$cli->[$num - 1];$hlt->stateSet(@$k);my$begin="$num.0";my$end=$cw->index("$num.0 lineend");my$rl=$hlt->rules;for my$tn (@$rl){$cw->tagRemove($tn->[0],$begin,$end)}my$txt=$cw->get($begin,$end);my@v;if ($txt){my$pos=0;my$start=0;my@h=$hlt->highlight("$txt\n");while (@h ne 0){$start=$pos;$pos += shift@h;my$tag=shift@h;$cw->tagAdd($tag,"$num.$start","$num.$pos")};$cw->DoOneEvent(2)unless ($nodoEvent ||!$cw->cget('-highlightInBackground'))};$cli->[$num]=[$hlt->stateGet ]}sub highlightPlug {my$cw=shift;my$plug=$cw->Subwidget('formatter');my$syntax=$cw->cget('-syntax');$syntax =~ s/\:\:.*$//o;my$rules=$cw->cget('-rules');if (not defined($plug)){$plug=$cw->highlightPlugInit}elsif (ref($syntax)){if ($syntax ne $plug){$plug=$cw->highlightPlugInit}}elsif ($syntax ne $plug->syntax){$cw->rulesDelete;$plug=$cw->highlightPlugInit;$cw->highlightPurge(1)}elsif (defined($rules)){if ($#{$rules}>= 0 && $rules ne $plug->rules){$cw->rulesDelete;$plug->rules($rules);$cw->rulesConfigure;$cw->highlightPurge(1)}}else {$cw->rulesDelete;$cw->highlightPlugInit;$cw->highlightPurge(1)}return$plug}sub highlightPlugInit {my$cw=shift;my$syntax=$cw->cget('-syntax');if (not defined($cw->cget('-rules'))){$cw->rulesFetch};my$plug;my$lang='';if (ref($syntax)){$plug=$syntax}else {$lang=$1 if ($syntax =~ s/\:\:(.*)$//o);my@opt=();if (my$rules=$cw->cget('-rules')){push(@opt,$rules)}my$evalStr="require Tk::TextHighlight::$syntax; \$plug = new Tk::TextHighlight::$syntax(" .($lang ? "'$lang', " : '')."\@opt);";eval$evalStr;unless ($@ ||!defined($plug)||!defined($plug->rules)|| $cw->cget('-noPlugInit')){my$rules=$plug->rules;$cw->configure(-rules=>\@$rules)}}$cw->Advertise('formatter',$plug);$cw->rulesConfigure;my$bg=$cw->cget(-background);my ($red,$green,$blue)=$cw->rgb($bg);my@rgb=sort {$b <=> $a}($red,$green,$blue);my$max=$rgb[0]+$rgb[1];my$daytime=1;my$currentrules=$plug->rules;if ($max <= 52500){$daytime=0;for (my$k=0;$k<=$#{$currentrules};$k++){if ($currentrules->[$k]->[2]eq 'black'){$cw->setRule($currentrules->[$k]->[0],$currentrules->[$k]->[1],'white')}}}for (my$k=0;$k<=$#{$currentrules};$k++){if (defined($currentrules->[$k]->[2])and $currentrules->[$k]->[2]eq $bg){$cw->setRule($currentrules->[$k]->[0],$currentrules->[$k]->[1],($daytime ? 'black' : 'white'))}};$cw->update;unless ($cw->cget('-noSyntaxMenu')){my@kateMenus;my$ViewSyntaxMenu=$cw->menu->entrycget('View','-menu')->entrycget('Syntax','-menu');my$lastMenuIndex=$ViewSyntaxMenu->index('end');my$var;for my$i (0..$lastMenuIndex){if ($ViewSyntaxMenu->type($i)=~ /radiobutton/o){$var=$ViewSyntaxMenu->entrycget($i,'-variable');tie $$var,'Tk::Configure',$cw,'-syntax';unless (ref($syntax)){$$var=$lang ? ($syntax.'::'.$lang): $syntax}last}}}return$plug}sub highlightPlugList {my$cw=shift;my@ml=();my$haveKate=0;for my$d (@INC){my@fl=<$d/Tk/TextHighlight/*.pm>;for my$file (@fl){my ($name,$path,$suffix)=fileparse($file,"\.pm");if ($name eq 'Kate'){eval 'use Syntax::Highlight::Engine::Kate; $haveKate = 1; 1' unless ($haveKate);if ($haveKate){unless (grep {($name eq $_)}@ml){push(@ml,$name)}}}elsif ($name !~ /^(?:None|Template|RulesEditor)/o){unless (grep {($name eq $_)}@ml){push(@ml,$name)}}}}return sort@ml}sub highlightPurge {my ($cw,$line)=@_;$cw->configure('-colored'=>$line);my$cli=$cw->cget('-colorinf');if (@$cli){splice(@$cli,$line)};$cw->highlightVisual}sub highlightVisual {my$cw=shift;return if ($blockHighlight);my$end=$cw->visualend;my$col=$cw->cget('-colored');if ($col < $end){$col=$cw->highlight($col,$end);$cw->configure(-colored=>$col)};$cw->matchCheck}sub insert {my$cw=shift;my$pos=shift;$pos=$cw->index($pos);my$begin=$cw->linenumber("$pos - 1 chars");$cw->SUPER::insert($pos,@_);$cw->highlightCheck($begin,$cw->linenumber("insert lineend"))}sub Insert {my$cw=shift;$cw->SUPER::Insert(@_);$cw->see('insert')}sub InsertKeypress {my ($cw,$char)=@_;if ($char ne ''){my$index=$cw->index('insert');my$line=$cw->linenumber($index);if ($char =~ /^\S$/o and!$cw->OverstrikeMode and!$cw->tagRanges('sel')){my$undo_item=$cw->getUndoAtIndex(-1);if (defined($undo_item)&& ($undo_item->[0]eq 'delete')&& ($undo_item->[2]==$index)){$cw->Tk::Text::insert($index,$char);$undo_item->[2]=$cw->index('insert');$cw->highlightCheck($line,$line);$cw->see('insert');return}}$cw->addGlobStart;$cw->Tk::Text::InsertKeypress($char);$cw->addGlobEnd}}sub linenumber {my ($cw,$index)=@_;if (not defined($index)){$index='insert'}my$id=$cw->index($index);my ($line,$pos)=split(/\./o,$id);return$line}sub Load {my$cw=shift;my@r=$cw->SUPER::Load(@_);$cw->highlightVisual;return@r}sub matchCheck {my$cw=shift;my$c=$cw->get('insert','insert + 1 chars');my$p=$cw->index('match');if ($p ne '0.0'){$cw->tagRemove('Match',$p,"$p + 1 chars");$cw->markSet('match','0.0');$cw->markUnset('MyMatch')}if ($c){my$v=$cw->cget('-match');my$p=index($v,$c);if ($p ne -1){my$count=0;my$found=0;if ($p % 2){my$m=substr($v,$p - 1,1);$cw->matchFind('-backwards',$c,$m,$cw->index('insert'),$cw->index('0.0'),)}else {my$m=substr($v,$p + 1,1);$cw->matchFind('-forwards',$c,$m,$cw->index('insert + 1 chars'),$cw->index('end'),)}}}$cw->updateCall}sub matchFind {my ($cw,$dir,$char,$ochar,$start,$stop)=@_;my$pattern="\\$char|\\$ochar";my$found=0;my$count=0;while ((not $found)and (my$i=$cw->search($dir,'-regexp','-nocase','--',$pattern,$start,$stop))){my$k=$cw->get($i,"$i + 1 chars");if ($k eq $ochar){if ($count > 0){$count--;if ($dir eq '-forwards'){$start=$cw->index("$i + 1 chars")}else {$start=$i}}else {$cw->markSet('match',$i);$cw->tagAdd('Match',$i,"$i + 1 chars");$cw->markSet('MyMatch',$i);$cw->tagRaise('Match');$found=1}}elsif ($k eq $char){$count++;if ($dir eq '-forwards'){$start=$cw->index("$i + 1 chars")}else {$start=$i}}elsif ($i eq $start){$found=1}}}sub matchoptions {my$cw=shift;if (my$o=shift){my@op=();if (ref($o)){@op=@$o}else {@op=split(/\s+/o,$o)}$cw->tagConfigure('Match',@op)}}sub PostPopupMenu {my$cw=shift;my@r;if (not $cw->cget('-disablemenu')){@r=$cw->SUPER::PostPopupMenu(@_)}}sub rulesConfigure {my$cw=shift;if (my$plug=$cw->Subwidget('formatter')){my$rules=$plug->rules;my@r=@$rules;for my$k (@r){$cw->tagConfigure(@$k)};$cw->configure(-colored=>1,-colorinf=>[[$plug->stateGet]])}}sub setRule {my$cw=shift;my@rule=@_;if (my$plug=$cw->Subwidget('formatter')){my$rules=$plug->rules;my@r=@$rules;for (my$k=0;$k<=$#r;$k++){if ($rule[0]eq $r[$k]->[0]){@{$r[$k]}=@rule}};$cw->configure(-rules=>\@r)}}sub rulesDelete {my$cw=shift;if (my$plug=$cw->Subwidget('formatter')){my$rules=$plug->rules;for my$r (@$rules){$cw->tagDelete($r->[0])}}}sub rulesEdit {my$cw=shift;require Tk::TextHighlight::RulesEditor;$cw->RulesEditor(-class=>'Toplevel',)}sub rulesFetch {my$cw=shift;my$dir=$cw->cget('-rulesdir');my$syntax=$cw->cget('-syntax');$cw->configure(-rules=>undef);my$result=0;if ($dir and (-e "$dir/$syntax.rules")){my$file="$dir/$syntax.rules";if (my$rl=retrieve("$dir/$syntax.rules")){$cw->configure(-rules=>$rl);$result=1}}return$result}sub rulesSave {my$cw=shift;my$dir=$cw->cget('-rulesdir');if ($dir){my$syntax=$cw->cget('-syntax');my$file="$dir/$syntax.rules";store($cw->cget('-rules'),$file)}}sub scan {my$cw=shift;my@r=$cw->SUPER::scan(@_);$cw->highlightVisual;return@r}sub selectionModify {my ($cw,$char,$mode)=@_;my@ranges=$cw->tagRanges('sel');if (@ranges eq 2){my$start=$cw->index($ranges[0]);my$end=$cw->index($ranges[1]);while ($cw->compare($start,"<",$end)){if ($mode){if ($cw->get("$start linestart","$start linestart + 1 chars")eq $char){$cw->delete("$start linestart","$start linestart + 1 chars")}}else {$cw->insert("$start linestart",$char)}$start=$cw->index("$start + 1 lines")}$cw->tagAdd('sel',@ranges)}}sub selectionComment {my$cw=shift;$cw->selectionModify($cw->cget('-commentchar'),0)}sub selectionIndent {my$cw=shift;$cw->selectionModify($cw->cget('-indentchar'),0)}sub selectionUnComment {my$cw=shift;$cw->selectionModify($cw->cget('-commentchar'),1)}sub selectionUnIndent {my$cw=shift;$cw->selectionModify($cw->cget('-indentchar'),1)}sub syntax {my$cw=shift;if (@_){my$name=shift;my$fm;eval ("require Tk::TextHighlight::$name;	\$fm = new Tk::TextHighlight::$name(\$cw);");$cw->Advertise('formatter',$fm);$cw->configure('-langname'=>$name)}return$cw->cget('-langname')}sub yview {my$cw=shift;my@r=();if (@_){@r=$cw->SUPER::yview(@_);if ($_[1]> 0){my ($p)=caller;$nodoEvent=1 if ($p =~ /scroll/io);$cw->highlightVisual}}else {@r=$cw->SUPER::yview}return@r}sub see {my$cw=shift;my@r=$cw->SUPER::see(@_);$cw->highlightVisual;return@r}sub updateCall {my$cw=shift;my$call=$cw->cget('-updatecall');&$call;$nodoEvent=0}sub ViewMenuItems {my$cw=shift;my$s;tie$s,'Tk::Configure',$cw,'-syntax';my@stx=('None',$cw->highlightPlugList);my@rad=(['command'=>'Reset',-command=>sub {$cw->configure('-rules'=>undef);$cw->highlightPlug}]);for my$n (@stx){push(@rad,['radiobutton'=>$n,-variable=>\$s,-value=>$n,-command=>sub {$cw->configure('-rules'=>undef);$cw->highlightPlug}])}my$dir=$cw->cget('-rulesdir');my$syntax=$cw->cget('-syntax');my$menuExt=\@{$cw->SUPER::ViewMenuItems};unless ($cw->cget('-noRulesMenu')){push (@{$menuExt},['cascade'=>'Syntax',-menuitems=>[@rad],])unless ($cw->cget('-noSyntaxMenu'));push (@{$menuExt},['command'=>'Rules Editor',-command=>sub {$cw->rulesEdit},])unless ($cw->cget('-noRulesEditMenu'));push (@{$menuExt},['command'=>'Save Rules',-command=>sub {$cw->rulesSave},])if (!$cw->cget('-noSaveRulesMenu')&& $dir && (-w $dir))}return$menuExt}sub visualend {my$cw=shift;my$end=$cw->linenumber('end - 1 chars');my ($first,$last)=$cw->Tk::Text::yview;my$vend=int($last * $end)+ 2;if ($vend > $end){$vend=$end}return$vend}sub fetchKateInfo {my$cw=shift;my (%sectionHash,%extHash,%syntaxHash);for my$i (@INC){if (-e "$i/Syntax/Highlight/Engine/Kate.pm" && open KATE,"$i/Syntax/Highlight/Engine/Kate.pm"){my$inExtensions=0;my$inSyntaxes=0;my$inSections=0;while (<KATE>){chomp;$inExtensions=1 if (/\$self\-\>\{\'extensions\'\}\s*\=\s*\{/o);$inSections=1 if (/\$self\-\>\{\'sections\'\}\s*\=\s*\{/o);$inSyntaxes=1 if (/\$self\-\>\{\'syntaxes\'\}\s*\=\s*\{/o);if ($inSections){if (/\'([^\']+)\'\s*\=\>\s*\[/o){$inSections=$1;@{$sectionHash{$inSections}}=()}elsif (/\'([^\']+)\'\s*\,/o){push (@{$sectionHash{$inSections}},$1)}elsif (/\}\;/o){$inSections=0}}elsif ($inExtensions){if (/\'([^\']+)\'\s*\=\>\s*\[\'([^\']+)\'/o){my$one='^'.$1.'$';my$two=$2;$one =~ s/\./\\\./o;$one =~ s/\*/\.\*/go;$extHash{$one}="Kate::$two"}elsif (/\}\;/o){$inExtensions=0}}elsif ($inSyntaxes){if (/\'([^\']+)\'\s*\=\>\s*\[\'([^\']+)\'/o){$syntaxHash{$1}=$2}elsif (/\}\;/o){$inSyntaxes=0;close KATE;last}}}close KATE;last}}return (\%sectionHash,\%extHash,\%syntaxHash)}sub addKate2ViewMenu {my$cw=shift;my$sectionHash=shift;return undef if ($cw->cget('-noRulesMenu')|| $cw->cget('-noSyntaxMenu'));my$ViewSyntaxMenu=$cw->menu->entrycget('View','-menu')->entrycget('Syntax','-menu');my$lastMenuIndex=$ViewSyntaxMenu->index('end');my$var;my$kateIndx='end';for my$i (0..$lastMenuIndex){if ($ViewSyntaxMenu->type($i)=~ /radiobutton/o){$var=$ViewSyntaxMenu->entrycget($i,'-variable');tie $$var,'Tk::Configure',$cw,'-syntax';if ($ViewSyntaxMenu->entrycget($i,'-label')eq 'Kate'){$ViewSyntaxMenu->delete($i);last}}}my ($nextMenu,$menuTitle);for my$sect (sort keys %{$sectionHash}){$nextMenu=$ViewSyntaxMenu->Menu;for my$lang (@{$sectionHash->{$sect}}){$menuTitle="Kate::$lang";$nextMenu->radiobutton(-label=>$menuTitle,-variable=>$var,-value=>$menuTitle,-command=>sub {$cw->configure('-rules'=>undef);$cw->highlightPlug})}$ViewSyntaxMenu->insert($kateIndx,'cascade',-label=>"Kate: $sect...",-menu=>$nextMenu);++$kateIndx if ($kateIndx =~ /^\d/o)}}1;
TK_ROTEXTHIGHLIGHT

$fatpacked{"Tk/TextHighlight.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TK_TEXTHIGHLIGHT';
  package Tk::TextHighlight;use vars qw($VERSION);$VERSION='1.1.1';use base qw(Tk::Derived Tk::TextUndo);use strict;use Storable;use File::Basename;my$blockHighlight=0;my$nodoEvent=0;Construct Tk::Widget 'TextHighlight';sub Populate {my ($cw,$args)=@_;$cw->SUPER::Populate($args);$cw->ConfigSpecs(-autoindent=>[qw/PASSIVE autoindent Autoindent/,0],-match=>[qw/PASSIVE match Match/,'[]{}()'],-matchoptions=>[qw/METHOD matchoptions Matchoptions/,[-background=>'red',-foreground=>'yellow']],-indentchar=>[qw/PASSIVE indentchar Indentchar/,"\t"],-disablemenu=>[qw/PASSIVE disablemenu Disablemenu/,0],-commentchar=>[qw/PASSIVE commentchar Commentchar/,"#"],-colorinf=>[qw/PASSIVE undef undef/,[]],-colored=>[qw/PASSIVE undef undef/,0],-syntax=>[qw/PASSIVE syntax Syntax/,'None'],-rules=>[qw/PASSIVE undef undef/,undef],-rulesdir=>[qw/PASSIVE rulesdir Rulesdir/,''],-updatecall=>[qw/PASSIVE undef undef/,sub {}],-noRulesMenu=>[qw/PASSIVE undef undef/,0],-noSyntaxMenu=>[qw/PASSIVE undef undef/,0],-noRulesEditMenu=>[qw/PASSIVE undef undef/,0],-noSaveRulesMenu=>[qw/PASSIVE undef undef/,0],-noPlugInit=>[qw/PASSIVE undef undef/,0],-highlightInBackground=>[qw/PASSIVE undef undef/,0],DEFAULT=>['SELF' ],);$cw->bind('<Configure>',sub {$cw->highlightVisual});$cw->bind('<Shift-Return>',sub {$cw->doAutoIndent(0)});$cw->bind('<Return>',sub {$cw->doAutoIndent(1)});$cw->markSet('match','0.0');$cw->bind('<Control-p>',\&jumpToMatchingChar);$cw->bind('<Shift-BackSpace>',\&doShiftBackSpace);$cw->bind('<Shift-Tab>',\&deleteToEndofLine);$cw->bind('<Shift-Insert>',\&doShiftInsert)}sub configure {my$cw=shift;my$plug=$cw->Subwidget('formatter');if ($plug){for (my$i=0;$i<$#{_};$i++){if ($_[$i]=~ /\-(?:bg|background)/o){my$oldBg=$cw->cget($_[$i]);unless ($_[$i+1]eq $oldBg){$cw->SUPER::configure($_[$i]=>$_[$i+1]);$cw->configure('-rules'=>undef);$cw->highlightPlug;last}}}}$cw->SUPER::configure(@_)}sub jumpToMatchingChar {my$cw=shift;$cw->markSet('insert',$cw->index('insert'));my$pm=-1;eval {$pm=$cw->index('MyMatch')};if ($pm >= 0){my$prevMatch=$cw->index('insert');$prevMatch .= '.0' unless ($prevMatch =~ /\./o);$cw->markSet('insert',$cw->index('MyMatch'));$cw->see('insert');$cw->markSet('MyMatch',$prevMatch)}}sub doShiftBackSpace {my$cw=shift;my$curPos=$cw->index('insert');my$leftPos=$cw->index('insert linestart');$cw->delete($leftPos,$curPos)unless ($curPos <= $leftPos)}sub deleteToEndofLine {my ($cw)=@_;if ($cw->compare('insert','==','insert lineend')){$cw->delete('insert')}else {$cw->delete('insert','insert lineend')}}sub doShiftDelete {my$cw=shift;(my$curPos=$cw->index('insert'))=~ s/\..*$//o;my$startPos=($curPos > 1)? $cw->index('insert - 1 line lineend'): $cw->index('1.0');my$endPos=$cw->index('insert lineend');$cw->delete($startPos,$endPos)}sub doShiftInsert {my$cw=shift;my$insPos=$cw->index('insert lineend');$cw->insert($insPos,"\n")}sub ClassInit {my ($class,$w)=@_;$class->SUPER::ClassInit($w);$w->bind($class,'<Control-p>',sub {});$w->bind($class,'<Alt-Tab>','insertTabChar');$w->bind($class,'<Shift-BackSpace>','doShiftBackSpace');$w->bind($class,'<Shift-Delete>','doShiftDelete');$w->bind($class,'<Control-Delete>','deleteToEndofLine');$w->bind($class,'<Control-Tab>','deleteToEndofLine');$w->bind($class,'<Tab>','insertTab');$w->bind($class,'<Control-BackSpace>','doShiftBackSpace');return$class}sub clipboardCopy {my$cw=shift;my@ranges=$cw->tagRanges('sel');if (@ranges){$cw->SUPER::clipboardCopy(@_)}}sub clipboardCut {my$cw=shift;my@ranges=$cw->tagRanges('sel');if (@ranges){$cw->SUPER::clipboardCut(@_)}}sub clipboardPaste {my$cw=shift;my@ranges=$cw->tagRanges('sel');if (@ranges){$cw->tagRemove('sel','1.0','end');return}$cw->SUPER::clipboardPaste(@_)}sub delete {my$cw=shift;my$begin=$_[0];if (defined($begin)){$begin=$cw->linenumber($begin)}else {$begin=$cw->linenumber('insert')};my$end=$_[1];if (defined($end)){$end=$cw->linenumber($end)}else {$end=$begin};$cw->SUPER::delete(@_);$cw->highlightCheck($begin,$end)}sub doAutoIndent {my$cw=shift;my$doAutoIndent=shift;return unless ($doAutoIndent);if ($cw->cget('-autoindent')){my$i=$cw->index('insert linestart');if ($cw->compare($i,">",'0.0')){my$s=$cw->get("$i - 1 lines","$i - 1 lines lineend");$s =~ /^(\s*)/o;if ($1){$cw->insert('insert',$1)}$cw->insert('insert',$cw->cget('-indentchar'))if ($s =~ /[\{\[\(]\s*$/o)}}}sub EditMenuItems {my$cw=shift;return [@{$cw->SUPER::EditMenuItems},"-",["command"=>'Comment',-command=>[$cw=>'selectionComment']],["command"=>'Uncomment',-command=>[$cw=>'selectionUnComment']],"-",["command"=>'Indent',-command=>[$cw=>'selectionIndent']],["command"=>'Unindent',-command=>[$cw=>'selectionUnIndent']],]}sub EmptyDocument {my$cw=shift;my@r=$cw->SUPER::EmptyDocument(@_);$cw->highlightPurge(1);return@r}sub highlight {my ($cw,$begin,$end)=@_;$blockHighlight=1;if (not defined($end)){$end=$begin + 1};my@sel=$cw->tagRanges('sel');while ($begin < $end){$cw->highlightLine($begin);$begin++};$blockHighlight=0;return$begin}sub highlightCheck {my ($cw,$begin,$end)=@_;my$col=$cw->cget('-colored');my$cli=$cw->cget('-colorinf');if ($begin <= $col){if ($begin < $end){$cw->highlightPurge($begin)}else {my$hlt=$cw->highlightPlug;my$i=$cli->[$begin];$cw->highlight($begin);if (($col < $cw->linenumber('end'))and (not $hlt->stateCompare($i))){$cw->highlightPurge($begin)}};$cw->matchCheck}else {$cw->highlightVisual}}sub highlightLine {my ($cw,$num)=@_;my$hlt=$cw->highlightPlug;my$cli=$cw->cget('-colorinf');my$k=$cli->[$num - 1];$hlt->stateSet(@$k);my$begin="$num.0";my$end=$cw->index("$num.0 lineend");my$rl=$hlt->rules;for my$tn (@$rl){$cw->tagRemove($tn->[0],$begin,$end)}my$txt=$cw->get($begin,$end);my@v;if ($txt){my$pos=0;my$start=0;my@h=$hlt->highlight("$txt\n");while (@h ne 0){$start=$pos;$pos += shift@h;my$tag=shift@h;$cw->tagAdd($tag,"$num.$start","$num.$pos")};$cw->DoOneEvent(2)unless ($nodoEvent ||!$cw->cget('-highlightInBackground'))};$cli->[$num]=[$hlt->stateGet ]}sub highlightPlug {my$cw=shift;my$plug=$cw->Subwidget('formatter');my$syntax=$cw->cget('-syntax');$syntax =~ s/\:\:.*$//o;my$rules=$cw->cget('-rules');if (not defined($plug)){$plug=$cw->highlightPlugInit}elsif (ref($syntax)){if ($syntax ne $plug){$plug=$cw->highlightPlugInit}}elsif ($syntax ne $plug->syntax){$cw->rulesDelete;$plug=$cw->highlightPlugInit;$cw->highlightPurge(1)}elsif (defined($rules)){if ($#{$rules}>= 0 && $rules ne $plug->rules){$cw->rulesDelete;$plug->rules($rules);$cw->rulesConfigure;$cw->highlightPurge(1)}}else {$cw->rulesDelete;$cw->highlightPlugInit;$cw->highlightPurge(1)}return$plug}sub highlightPlugInit {my$cw=shift;my$syntax=$cw->cget('-syntax');if (not defined($cw->cget('-rules'))){$cw->rulesFetch};my$plug;my$lang='';if (ref($syntax)){$plug=$syntax}else {$lang=$1 if ($syntax =~ s/\:\:(.*)$//o);my@opt=();if (my$rules=$cw->cget('-rules')){push(@opt,$rules)}my$evalStr="require Tk::TextHighlight::$syntax; \$plug = new Tk::TextHighlight::$syntax(" .($lang ? "'$lang', " : '')."\@opt);";eval$evalStr;unless ($@ ||!defined($plug)||!defined($plug->rules)|| $cw->cget('-noPlugInit')){my$rules=$plug->rules;$cw->configure(-rules=>\@$rules)}}$cw->Advertise('formatter',$plug);$cw->rulesConfigure;my$bg=$cw->cget(-background);my ($red,$green,$blue)=$cw->rgb($bg);my@rgb=sort {$b <=> $a}($red,$green,$blue);my$max=$rgb[0]+$rgb[1];my$daytime=1;my$currentrules=$plug->rules;if ($max <= 52500){$daytime=0;for (my$k=0;$k<=$#{$currentrules};$k++){if ($currentrules->[$k]->[2]eq 'black'){$cw->setRule($currentrules->[$k]->[0],$currentrules->[$k]->[1],'white')}}}for (my$k=0;$k<=$#{$currentrules};$k++){if (defined($currentrules->[$k]->[2])and $currentrules->[$k]->[2]eq $bg){$cw->setRule($currentrules->[$k]->[0],$currentrules->[$k]->[1],($daytime ? 'black' : 'white'))}};$cw->update;unless ($cw->cget('-noSyntaxMenu')){my@kateMenus;my$ViewSyntaxMenu=$cw->menu->entrycget('View','-menu')->entrycget('Syntax','-menu');my$lastMenuIndex=$ViewSyntaxMenu->index('end');my$var;for my$i (0..$lastMenuIndex){if ($ViewSyntaxMenu->type($i)=~ /radiobutton/o){$var=$ViewSyntaxMenu->entrycget($i,'-variable');tie $$var,'Tk::Configure',$cw,'-syntax';unless (ref($syntax)){$$var=$lang ? ($syntax.'::'.$lang): $syntax}last}}}return$plug}sub highlightPlugList {my$cw=shift;my@ml=();my$haveKate=0;for my$d (@INC){my@fl=<$d/Tk/TextHighlight/*.pm>;for my$file (@fl){my ($name,$path,$suffix)=fileparse($file,"\.pm");if ($name eq 'Kate'){eval 'use Syntax::Highlight::Engine::Kate; $haveKate = 1; 1' unless ($haveKate);if ($haveKate){unless (grep {($name eq $_)}@ml){push(@ml,$name)}}}elsif ($name !~ /^(?:None|Template|RulesEditor)/o){unless (grep {($name eq $_)}@ml){push(@ml,$name)}}}}return sort@ml}sub highlightPurge {my ($cw,$line)=@_;$cw->configure('-colored'=>$line);my$cli=$cw->cget('-colorinf');if (@$cli){splice(@$cli,$line)};$cw->highlightVisual}sub highlightVisual {my$cw=shift;return if ($blockHighlight);my$end=$cw->visualend;my$col=$cw->cget('-colored');if ($col < $end){$col=$cw->highlight($col,$end);$cw->configure(-colored=>$col)};$cw->matchCheck}sub insert {my$cw=shift;my$pos=shift;$pos=$cw->index($pos);my$begin=$cw->linenumber("$pos - 1 chars");$cw->SUPER::insert($pos,@_);$cw->highlightCheck($begin,$cw->linenumber("insert lineend"))}sub Insert {my$cw=shift;$cw->SUPER::Insert(@_);$cw->see('insert')}sub InsertKeypress {my ($cw,$char)=@_;if ($char ne ''){my$index=$cw->index('insert');my$line=$cw->linenumber($index);if ($char =~ /^\S$/o and!$cw->OverstrikeMode and!$cw->tagRanges('sel')){my$undo_item=$cw->getUndoAtIndex(-1);if (defined($undo_item)&& ($undo_item->[0]eq 'delete')&& ($undo_item->[2]==$index)){$cw->Tk::Text::insert($index,$char);$undo_item->[2]=$cw->index('insert');$cw->highlightCheck($line,$line);$cw->see('insert');return}}$cw->addGlobStart;$cw->Tk::Text::InsertKeypress($char);$cw->addGlobEnd}}sub linenumber {my ($cw,$index)=@_;if (not defined($index)){$index='insert'}my$id=$cw->index($index);my ($line,$pos)=split(/\./o,$id);return$line}sub Load {my$cw=shift;my@r=$cw->SUPER::Load(@_);$cw->highlightVisual;return@r}sub matchCheck {my$cw=shift;my$c=$cw->get('insert','insert + 1 chars');my$p=$cw->index('match');if ($p ne '0.0'){$cw->tagRemove('Match',$p,"$p + 1 chars");$cw->markSet('match','0.0');$cw->markUnset('MyMatch')}if ($c){my$v=$cw->cget('-match');my$p=index($v,$c);if ($p ne -1){my$count=0;my$found=0;if ($p % 2){my$m=substr($v,$p - 1,1);$cw->matchFind('-backwards',$c,$m,$cw->index('insert'),$cw->index('0.0'),)}else {my$m=substr($v,$p + 1,1);$cw->matchFind('-forwards',$c,$m,$cw->index('insert + 1 chars'),$cw->index('end'),)}}}$cw->updateCall}sub matchFind {my ($cw,$dir,$char,$ochar,$start,$stop)=@_;my$pattern="\\$char|\\$ochar";my$found=0;my$count=0;while ((not $found)and (my$i=$cw->search($dir,'-regexp','-nocase','--',$pattern,$start,$stop))){my$k=$cw->get($i,"$i + 1 chars");if ($k eq $ochar){if ($count > 0){$count--;if ($dir eq '-forwards'){$start=$cw->index("$i + 1 chars")}else {$start=$i}}else {$cw->markSet('match',$i);$cw->tagAdd('Match',$i,"$i + 1 chars");$cw->markSet('MyMatch',$i);$cw->tagRaise('Match');$found=1}}elsif ($k eq $char){$count++;if ($dir eq '-forwards'){$start=$cw->index("$i + 1 chars")}else {$start=$i}}elsif ($i eq $start){$found=1}}}sub matchoptions {my$cw=shift;if (my$o=shift){my@op=();if (ref($o)){@op=@$o}else {@op=split(/\s+/o,$o)}$cw->tagConfigure('Match',@op)}}sub PostPopupMenu {my$cw=shift;my@r;if (not $cw->cget('-disablemenu')){@r=$cw->SUPER::PostPopupMenu(@_)}}sub rulesConfigure {my$cw=shift;if (my$plug=$cw->Subwidget('formatter')){my$rules=$plug->rules;my@r=@$rules;for my$k (@r){$cw->tagConfigure(@$k)};$cw->configure(-colored=>1,-colorinf=>[[$plug->stateGet]])}}sub setRule {my$cw=shift;my@rule=@_;if (my$plug=$cw->Subwidget('formatter')){my$rules=$plug->rules;my@r=@$rules;for (my$k=0;$k<=$#r;$k++){if ($rule[0]eq $r[$k]->[0]){@{$r[$k]}=@rule}};$cw->configure(-rules=>\@r)}}sub rulesDelete {my$cw=shift;if (my$plug=$cw->Subwidget('formatter')){my$rules=$plug->rules;for my$r (@$rules){$cw->tagDelete($r->[0])}}}sub rulesEdit {my$cw=shift;require Tk::TextHighlight::RulesEditor;$cw->RulesEditor(-class=>'Toplevel',)}sub rulesFetch {my$cw=shift;my$dir=$cw->cget('-rulesdir');my$syntax=$cw->cget('-syntax');$cw->configure(-rules=>undef);my$result=0;if ($dir and (-e "$dir/$syntax.rules")){my$file="$dir/$syntax.rules";if (my$rl=retrieve("$dir/$syntax.rules")){$cw->configure(-rules=>$rl);$result=1}}return$result}sub rulesSave {my$cw=shift;my$dir=$cw->cget('-rulesdir');if ($dir){my$syntax=$cw->cget('-syntax');my$file="$dir/$syntax.rules";store($cw->cget('-rules'),$file)}}sub scan {my$cw=shift;my@r=$cw->SUPER::scan(@_);$cw->highlightVisual;return@r}sub selectionModify {my ($cw,$char,$mode)=@_;my@ranges=$cw->tagRanges('sel');if (@ranges eq 2){my$start=$cw->index($ranges[0]);my$end=$cw->index($ranges[1]);while ($cw->compare($start,"<",$end)){if ($mode){if ($cw->get("$start linestart","$start linestart + 1 chars")eq $char){$cw->delete("$start linestart","$start linestart + 1 chars")}}else {$cw->insert("$start linestart",$char)}$start=$cw->index("$start + 1 lines")}$cw->tagAdd('sel',@ranges)}}sub selectionComment {my$cw=shift;$cw->selectionModify($cw->cget('-commentchar'),0)}sub selectionIndent {my$cw=shift;$cw->selectionModify($cw->cget('-indentchar'),0)}sub selectionUnComment {my$cw=shift;$cw->selectionModify($cw->cget('-commentchar'),1)}sub selectionUnIndent {my$cw=shift;$cw->selectionModify($cw->cget('-indentchar'),1)}sub syntax {my$cw=shift;if (@_){my$name=shift;my$fm;eval ("require Tk::TextHighlight::$name;	\$fm = new Tk::TextHighlight::$name(\$cw);");$cw->Advertise('formatter',$fm);$cw->configure('-langname'=>$name)}return$cw->cget('-langname')}sub yview {my$cw=shift;my@r=();if (@_){@r=$cw->SUPER::yview(@_);if ($_[1]> 0){my ($p)=caller;$nodoEvent=1 if ($p =~ /scroll/io);$cw->highlightVisual}}else {@r=$cw->SUPER::yview}return@r}sub see {my$cw=shift;my@r=$cw->SUPER::see(@_);$cw->highlightVisual;return@r}sub updateCall {my$cw=shift;my$call=$cw->cget('-updatecall');&$call;$nodoEvent=0}sub ViewMenuItems {my$cw=shift;my$s;tie$s,'Tk::Configure',$cw,'-syntax';my@stx=('None',$cw->highlightPlugList);my@rad=(['command'=>'Reset',-command=>sub {$cw->configure('-rules'=>undef);$cw->highlightPlug}]);for my$n (@stx){push(@rad,['radiobutton'=>$n,-variable=>\$s,-value=>$n,-command=>sub {$cw->configure('-rules'=>undef);$cw->highlightPlug}])}my$dir=$cw->cget('-rulesdir');my$syntax=$cw->cget('-syntax');my$menuExt=\@{$cw->SUPER::ViewMenuItems};unless ($cw->cget('-noRulesMenu')){push (@{$menuExt},['cascade'=>'Syntax',-menuitems=>[@rad],])unless ($cw->cget('-noSyntaxMenu'));push (@{$menuExt},['command'=>'Rules Editor',-command=>sub {$cw->rulesEdit},])unless ($cw->cget('-noRulesEditMenu'));push (@{$menuExt},['command'=>'Save Rules',-command=>sub {$cw->rulesSave},])if (!$cw->cget('-noSaveRulesMenu')&& $dir && (-w $dir))}return$menuExt}sub visualend {my$cw=shift;my$end=$cw->linenumber('end - 1 chars');my ($first,$last)=$cw->Tk::Text::yview;my$vend=int($last * $end)+ 2;if ($vend > $end){$vend=$end}return$vend}sub fetchKateInfo {my$cw=shift;my (%sectionHash,%extHash,%syntaxHash);for my$i (@INC){if (-e "$i/Syntax/Highlight/Engine/Kate.pm" && open KATE,"$i/Syntax/Highlight/Engine/Kate.pm"){my$inExtensions=0;my$inSyntaxes=0;my$inSections=0;while (<KATE>){chomp;$inExtensions=1 if (/\$self\-\>\{\'extensions\'\}\s*\=\s*\{/o);$inSections=1 if (/\$self\-\>\{\'sections\'\}\s*\=\s*\{/o);$inSyntaxes=1 if (/\$self\-\>\{\'syntaxes\'\}\s*\=\s*\{/o);if ($inSections){if (/\'([^\']+)\'\s*\=\>\s*\[/o){$inSections=$1;@{$sectionHash{$inSections}}=()}elsif (/\'([^\']+)\'\s*\,/o){push (@{$sectionHash{$inSections}},$1)}elsif (/\}\;/o){$inSections=0}}elsif ($inExtensions){if (/\'([^\']+)\'\s*\=\>\s*\[\'([^\']+)\'/o){my$one='^'.$1.'$';my$two=$2;$one =~ s/\./\\\./o;$one =~ s/\*/\.\*/go;$extHash{$one}="Kate::$two"}elsif (/\}\;/o){$inExtensions=0}}elsif ($inSyntaxes){if (/\'([^\']+)\'\s*\=\>\s*\[\'([^\']+)\'/o){$syntaxHash{$1}=$2}elsif (/\}\;/o){$inSyntaxes=0;close KATE;last}}}close KATE;last}}return (\%sectionHash,\%extHash,\%syntaxHash)}sub addKate2ViewMenu {my$cw=shift;my$sectionHash=shift;return undef if ($cw->cget('-noRulesMenu')|| $cw->cget('-noSyntaxMenu'));my$ViewSyntaxMenu=$cw->menu->entrycget('View','-menu')->entrycget('Syntax','-menu');my$lastMenuIndex=$ViewSyntaxMenu->index('end');my$var;my$kateIndx='end';for my$i (0..$lastMenuIndex){if ($ViewSyntaxMenu->type($i)=~ /radiobutton/o){$var=$ViewSyntaxMenu->entrycget($i,'-variable');tie $$var,'Tk::Configure',$cw,'-syntax';if ($ViewSyntaxMenu->entrycget($i,'-label')eq 'Kate'){$ViewSyntaxMenu->delete($i);last}}}my ($nextMenu,$menuTitle);for my$sect (sort keys %{$sectionHash}){$nextMenu=$ViewSyntaxMenu->Menu;for my$lang (@{$sectionHash->{$sect}}){$menuTitle="Kate::$lang";$nextMenu->radiobutton(-label=>$menuTitle,-variable=>$var,-value=>$menuTitle,-command=>sub {$cw->configure('-rules'=>undef);$cw->highlightPlug})}$ViewSyntaxMenu->insert($kateIndx,'cascade',-label=>"Kate: $sect...",-menu=>$nextMenu);++$kateIndx if ($kateIndx =~ /^\d/o)}}sub insertTab {my ($w)=@_;$w->Insert($w->cget('-indentchar'));$w->focus;$w->break}sub insertTabChar {my ($w)=@_;$w->Insert("\t");$w->focus;$w->break}1;
TK_TEXTHIGHLIGHT

$fatpacked{"Tk/TextHighlight/Template.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TK_TEXTHIGHLIGHT_TEMPLATE';
  package Tk::TextHighlight::Template;use vars qw($VERSION);$VERSION='0.3';use strict;use Data::Dumper;sub new {my ($proto,$rules)=@_;my$class=ref($proto)|| $proto;if (not defined($rules)){$rules=[]};my$self={};$self->{'lists'}={};$self->{'out'}=[];$self->{'rules'}=$rules,$self->{'stack'}=[];$self->{'snippet'}='';$self->{'callbacks'}={};$self->{'oneliners'}=[],bless ($self,$class);return$self}sub callbacks {my$hlt=shift;if (@_){$hlt->{'callbacks'}=shift};return$hlt->{'callbacks'}}sub highlight {my ($hlt,$text)=@_;$hlt->snippetParse;my$out=$hlt->out;@$out=();while ($text){my$sub=$hlt->callbacks->{$hlt->stackTop};$text=&$sub($hlt,$text)}$hlt->snippetParse;return @$out}sub lists {my$hlt=shift;if (@_){$hlt->{'lists'}=shift};return$hlt->{'lists'}}sub listAdd {my$hlt=shift;my$listname=shift;my$lst=$hlt->lists;if (@_){$lst->{$listname}=[@_]}else {$lst->{$listname}=[]}my$r=$hlt->lists->{$listname}}sub rules {my$hlt=shift;if (@_){$hlt->{'rules'}=shift}return$hlt->{'rules'}}sub out {my$hlt=shift;if (@_){$hlt->{'out'}=shift}return$hlt->{'out'}}sub parserError {my ($hlt,$text)=@_;my$s=$hlt->stack;if (@$s eq 1){warn "Parser error\n\tmode: '" .$hlt->stackTop ."'\n" ."text: '$text'\nparsing  as plain text";$hlt->snippetParse($text);$text=''}else {warn "Parser error\n\tmode: '" .$hlt->stackTop ."'\n" ."text: '$text'\nexiting mode";$hlt->stackPull};return$text}sub snippet {my$hlt=shift;if (@_){$hlt->{'snippet'}=shift}return$hlt->{'snippet'}}sub snippetAppend {my ($hlt,$ch)=@_;$hlt->{'snippet'}=$hlt->{'snippet'}.$ch}sub snippetParse {my$hlt=shift;my$snip=shift;my$attr=shift;unless (defined($snip)){$snip=$hlt->snippet}unless (defined($attr)){$attr=$hlt->stackTop}my$out=$hlt->{'out'};if ($snip){push(@$out,length($snip),$attr);$hlt->snippet('')}}sub stack {my$hlt=shift;return$hlt->{'stack'}}sub stackPush {my ($hlt,$val)=@_;my$stack=$hlt->stack;unshift(@$stack,$val)}sub stackPull {my ($hlt,$val)=@_;my$stack=$hlt->stack;return shift(@$stack)}sub stackTop {my$hlt=shift;return$hlt->stack->[0]}sub stateCompare {my ($hlt,$state)=@_;my$h=[$hlt->stateGet ];my$equal=1;if (Dumper($h)ne Dumper($state)){$equal=0};return$equal}sub stateGet {my$hlt=shift;my$s=$hlt->stack;return @$s}sub stateSet {my$hlt=shift;my$s=$hlt->stack;@$s=(@_)}sub syntax {my$hlt=shift;my$class=ref$hlt;$class =~ /Tk::TextHighlight::(.*)/o;return $1}sub tokenParse {my$hlt=shift;my$tkn=shift;$hlt->stackPush($tkn);$hlt->snippetParse(@_);$hlt->stackPull}sub tokenTest {my ($hlt,$test,$list)=@_;my$l=$hlt->lists->{$list};my@list=reverse sort @$l;my@rl=grep {(substr($test,0,length($_))eq $_)}@list;if (@rl){return$rl[0]}else {return undef}}1;
TK_TEXTHIGHLIGHT_TEMPLATE

$fatpacked{"Tree/R.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TREE_R';
  package Tree::R;use strict;use warnings;require Exporter;use SelfLoader qw(AUTOLOAD);our@ISA=qw(Exporter);our%EXPORT_TAGS=('all'=>[qw() ]);our@EXPORT_OK=(@{$EXPORT_TAGS{'all'}});our@EXPORT=qw();our$VERSION='0.072';sub new {my$package=shift;my%opt=@_;my$self={};for my$k (keys%opt){$self->{$k}=$opt{$k}}$self->{m}=2 unless$self->{m};$self->{M}=5 unless$self->{M};bless$self=>(ref($package)or $package);return$self}sub objects {my ($self,$objects,$N)=@_;return unless$self->{root};$N=$self->{root}unless$N;return unless$N;unless ($N->[0]){push @$objects,$N->[1]}else {for my$entry (@{$N->[1]}){$self->objects($objects,$entry)}}}sub query_point {my($self,$x,$y,$objects,$N)=@_;return unless$self->{root};$N=$self->{root}unless$N;return unless$x >= $N->[2]and $x <= $N->[4]and $y >= $N->[3]and $y <= $N->[5];unless ($N->[0]){push @$objects,$N->[1]}else {for my$entry (@{$N->[1]}){$self->query_point($x,$y,$objects,$entry)}}}sub query_completely_within_rect {my($self,$minx,$miny,$maxx,$maxy,$objects,$Node)=@_;return unless$self->{root};$Node=$self->{root}unless$Node;my@entries;push@entries,\$Node;while (@entries>0){my$N=pop@entries;if (${$N}->[2]> $maxx or ${$N}->[4]< $minx or ${$N}->[3]> $maxy or ${$N}->[5]< $miny){next}else {if ((!${$N}->[0])and (${$N}->[2]>= $minx)and (${$N}->[4]<= $maxx)and (${$N}->[3]>= $miny)and (${$N}->[5]<= $maxy)){push @$objects,${$N}->[1]}if (${$N}->[0]){for my$e (@{${$N}->[1]}){push@entries,\$e}}}}return$objects}sub query_partly_within_rect {my($self,$minx,$miny,$maxx,$maxy,$objects,$Node)=@_;return unless$self->{root};$Node=$self->{root}unless$Node;my@entries;push@entries,\$Node;while (@entries>0){my$N=pop@entries;if (${$N}->[2]> $maxx or ${$N}->[4]< $minx or ${$N}->[3]> $maxy or ${$N}->[5]< $miny){next}else {if (!${$N}->[0]){push @$objects,${$N}->[1]}else {for my$e (@{${$N}->[1]}){push@entries,\$e}}}}return$objects}sub insert {my ($self,$object,@rect)=@_;my$child=[0,$object,@rect];unless ($self->{root}){$self->{root}=[1,[$child],@rect]}else {my$N=$self->ChooseSubTree(@rect);push @{$N->[1]},$child;$self->QuadraticSplit($N->[1])if @{$N->[1]}> $self->{M}}}sub get_leaf {my ($self,$object,$leaf,$index_of_leaf,$parent)=@_;$leaf=$self->{root}unless$leaf;for my$index (0..$#{$leaf->[1]}){my$entry=$leaf->[1]->[$index];unless ($entry->[0]){return ($parent,$index_of_leaf,$leaf,$index)if$entry->[1]==$object}else {my@ret=$self->get_leaf($object,$entry,$index,$leaf);return@ret if@ret}}return ()}sub set_bboxes {my ($self,$N)=@_;$N=$self->{root}unless$N;return @$N[2..5]if$N->[0]==0;my@bbox;for my$child (@{$N->[1]}){my@bbox_of_child=$self->set_bboxes($child);@bbox=@bbox ? enlarged_rect(@bbox_of_child,@bbox): @bbox_of_child}@$N[2..5]=@bbox;return@bbox}sub remove {my ($self,$object)=@_;my ($parent,$index_of_leaf,$leaf,$index)=$self->get_leaf($object);return unless$leaf;splice(@{$leaf->[1]},$index,1);if ($parent and @{$leaf->[1]}< $self->{m}){splice(@{$parent->[1]},$index_of_leaf,1);if (@{$parent->[1]}< $self->{m}){my@new_child_list;for my$entry (@{$parent->[1]}){for my$child (@{$entry->[1]}){push@new_child_list,$child}}$parent->[1]=[@new_child_list]}$self->set_bboxes();for my$child (@{$leaf->[1]}){my$N=$self->ChooseSubTree(@$child[2..5]);push @{$N->[1]},$child;$self->QuadraticSplit($N->[1])if @{$N->[1]}> $self->{M}}}else {$self->set_bboxes()}delete$self->{root}unless defined$self->{root}->[2]}sub dump {my ($self,$N,$level)=@_;return unless$self->{root};$N=$self->{root}unless$N;return unless$N;$level=0 unless$level;unless ($N->[0]){print "($level) object $N $N->[1] rect @$N[2..5]\n"}else {print "($level) subtree $N $N->[1] rect @$N[2..5]\n";for my$entry (@{$N->[1]}){$self->dump($entry,$level+1)}}}sub ChooseSubTree {my ($self,@rect)=@_;unless ($self->{root}){$self->{root}=[1,[],@rect];return$self->{root}}my$N=$self->{root};CS2: @$N[2..5]=enlarged_rect(@$N[2..5],@rect);unless ($N->[1]->[0]->[0]){return$N}else {my$chosen;my$needed_enlargement_of_chosen;my$area_of_chosen;for my$entry (@{$N->[1]}){my@rect_of_entry=@$entry[2..5];my$area=area_of_rect(@rect_of_entry);my$needed_enlargement=area_of_rect(enlarged_rect(@rect_of_entry,@rect))- $area;if (!$chosen or $needed_enlargement < $needed_enlargement_of_chosen or $area < $area_of_chosen){$chosen=$entry;$needed_enlargement_of_chosen=$needed_enlargement;$area_of_chosen=$area}}$N=$chosen;goto CS2}}sub QuadraticSplit {my($self,$group)=@_;my($E1,$E2)=PickSeeds($group);$E2=splice(@$group,$E2,1);$E1=splice(@$group,$E1,1);$E1=[1,[$E1],@$E1[2..5]];$E2=[1,[$E2],@$E2[2..5]];do {DistributeEntry($group,$E1,$E2)}until @$group==0 or @$E1==$self->{M}-$self->{m}+1 or @$E2==$self->{M}-$self->{m}+1;unless (@$group==0){if (@$E1 < @$E2){while (@$group > 1){add_to_group($E1,pop @$group)}}else {while (@$group > 1){add_to_group($E2,pop @$group)}}}push @$group,($E1,$E2)}sub PickSeeds {my($group)=@_;my ($seed1,$seed2,$d,$e1);for ($e1=0;$e1 < @$group-1;$e1++){my@rect1=@{$group->[$e1]}[2..5];my$a1=area_of_rect(@rect1);my$e2;for ($e2=$e1+1;$e2 < @$group;$e2++){my@rect2=@{$group->[$e2]}[2..5];my@R=enlarged_rect(@rect1,@rect2);my$d_test=area_of_rect(@R)- $a1 - area_of_rect(@rect2);if (!$d or $d_test > $d){$seed1=min($e1,$e2);$seed2=max($e1,$e2)}}}return ($seed1,$seed2)}sub DistributeEntry {my($from,$to1,$to2)=@_;my$area_of_to1=area_of_rect(@$to1[2..5]);my$area_of_to2=area_of_rect(@$to2[2..5]);my ($next,$area_of_enlarged1,$area_of_enlarged2)=PickNext($from,$to1,$to2,$area_of_to1,$area_of_to2);my$cmp=$area_of_enlarged1 - $area_of_to1 <=> $area_of_enlarged2 - $area_of_to2;$cmp=$area_of_to1 <=> $area_of_to2 if$cmp==0;$cmp=@{$to1->[1]}<=> @{$to2->[1]}if$cmp==0;if ($cmp <= 0){add_to_group($to1,$from->[$next]);splice(@$from,$next,1)}elsif ($cmp > 0){add_to_group($to2,$from->[$next]);splice(@$from,$next,1)}}sub PickNext {my($from,$to1,$to2,$area_of_to1,$area_of_to2)=@_;my$next;my$max_diff;my$area_of_enlarged1;my$area_of_enlarged2;my@cover_of_to1=@$to1[2..5];my@cover_of_to2=@$to2[2..5];for my$i (0..$#$from){my$a1=area_of_rect(enlarged_rect(@cover_of_to1,@{$from->[$i]}[2..5]));$area_of_enlarged1=$a1 unless defined$area_of_enlarged1;my$a2=area_of_rect(enlarged_rect(@cover_of_to2,@{$from->[$i]}[2..5]));$area_of_enlarged2=$a2 unless defined$area_of_enlarged2;my$diff=abs(($area_of_enlarged1 - $area_of_to1)- ($area_of_enlarged2 - $area_of_to2));if (!$next or $diff > $max_diff){$next=$i;$max_diff=$diff;$area_of_enlarged1=$a1;$area_of_enlarged2=$a2}}return ($next,$area_of_enlarged1,$area_of_enlarged2)}sub add_to_group {my($to,$entry)=@_;push @{$to->[1]},$entry;@$to[2..5]=enlarged_rect(@$to[2..5],@$entry[2..5])}sub enlarged_rect {return (min($_[0],$_[4]),min($_[1],$_[5]),max($_[2],$_[6]),max($_[3],$_[7]))}sub area_of_rect {($_[3]-$_[1])*($_[2]-$_[0])}sub min {$_[0]> $_[1]? $_[1]: $_[0]}sub max {$_[0]> $_[1]? $_[0]: $_[1]}1;
TREE_R

$fatpacked{"Treemap.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TREEMAP';
  package Treemap;use 5.006;use strict;use warnings;use Carp;require Exporter;our@ISA=qw(Exporter);our@EXPORT_OK=();our@EXPORT=qw();our$VERSION='0.02';sub new {my$proto=shift;my$class=ref($proto)|| $proto;my$self={RECT=>undef,TEXT=>undef,CACHE=>1,INPUT=>undef,OUTPUT=>undef,PADDING=>5,SPACING=>5,@_,};die "No 'INPUT' object was specified in call to " .$class ."::new, cannot proceed.\nSee: perldoc Treemap\nError occured" if (!$self->{INPUT});die "No 'OUTPUT' object was specified in call to " .$class ."::new, cannot proceed.\nSee: perldoc Treemap\nError occured" if (!$self->{OUTPUT});bless$self,$class;return$self}sub rect {print " ";print "rect: @_\n"}sub text {print " ";print "text: @_\n"}sub map {my$self=shift;my$width=$self->{OUTPUT}->width;my$height=$self->{OUTPUT}->height;$self->_map($self->{INPUT}->treedata,0,0,$width-1,$height-1)}sub _map {my$self=shift;my (@p,@q,$tree,$o);($tree,$p[0],$p[1],$q[0],$q[1],$o)=@_;$o=$o || 0;$self->{OUTPUT }->rect($p[0],$p[1],$q[0],$q[1],$tree->{colour});my($pt,$qt)=$self->_shrink(\@p,\@q,$self->{PADDING});my@r=@$pt;my@s=@$qt;if($tree->{children}){my$width=abs($r[$o]- $s[$o]);my$size=$tree->{size};for my$child(@{$tree->{children}}){$s[$o]=$r[$o]+ $width * ($child->{size}/ $size)if ($size > 0);{my($rt,$st)=$self->_shrink(\@r,\@s,$self->{SPACING});my@r=@{$rt};my@s=@{$st};$self->_map($child,$r[0],$r[1],$s[0],$s[1],($o xor 1))}$r[$o]=$s[$o]}}$self->{OUTPUT }->text($p[0],$p[1],$q[0],$q[1],$tree->{name},($tree->{children}?1:undef))}sub _shrink {my$self=shift;my ($p,$q,$shr)=@_;my ($w,$h,$r,$s);my ($w_shrink,$h_shrink)=(0,0);$w=$q->[0]- $p->[0];$h=$q->[1]- $p->[1];if ($shr =~ /^([\d]+)%$/){my$pct=(100 - $1)/ 100;my$w2=(($w**2)*$pct)**0.5;$shr=(abs($w)- $w2)/ 2}if (abs($w)>= $shr){if ($w > 0){$w_shrink=$shr}elsif($w < 0){$w_shrink= - $shr}}else {$w_shrink=$w / 2}if (abs($h)>= $shr){if ($h > 0){$h_shrink=$shr}elsif($h < 0){$h_shrink= - $shr}}else {$h_shrink=$h / 2}$self->{DEBUG}&& print "Shrinking by $w_shrink, $h_shrink\n";$r->[0]=$p->[0]+ $w_shrink;$r->[1]=$p->[1]+ $h_shrink;$s->[0]=$q->[0]- $w_shrink;$s->[1]=$q->[1]- $h_shrink;return ($r,$s)}1;
TREEMAP

$fatpacked{"Treemap/Input.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TREEMAP_INPUT';
  package Treemap::Input;use 5.006;use strict;use warnings;use Carp;require Exporter;our@ISA=qw(Exporter);our@EXPORT_OK=();our@EXPORT=qw();our$VERSION='0.01';sub new {my$proto=shift;my$class=ref($proto)|| $proto;my$self={@_,};bless$self,$class;return$self}sub treedata {my$self=shift;return$self->{DATA }}1;
TREEMAP_INPUT

$fatpacked{"Treemap/Input/Cache.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TREEMAP_INPUT_CACHE';
  package Treemap::Simple;use 5.006;use strict;use warnings;use Carp;require Exporter;our@ISA=qw(Exporter);our@EXPORT_OK=();our@EXPORT=qw();our$VERSION='0.01';sub new {my$proto=shift;my$class=ref($proto)|| $proto;my$self={};bless$self,$class;return$self}1;
TREEMAP_INPUT_CACHE

$fatpacked{"Treemap/Input/Dir.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TREEMAP_INPUT_DIR';
  package Treemap::Input::Dir;use 5.006;use strict;use warnings;use Carp;use File::Basename;require Exporter;require Treemap::Input;our@ISA=qw(Treemap::Input Exporter);our@EXPORT_OK=();our@EXPORT=qw();our$VERSION='0.01';sub new {my$classname=shift;my$self=$classname->SUPER::new(@_);$self->_init(@_);return$self}sub _init {my$self=shift;$self->{FOLLOW_SYMLINK}=$self->{FOLLOW_SYMLINK}|| undef}sub load {my$self=shift;my($path)=@_;if ($self->{DATA }=$self->_load($path)){return 1}return 0}sub _load {my$self=shift;my($path)=@_;my($tree,$DH,@children,$size);@children=();$size=0;opendir($DH,$path);while(my$dir_entry=readdir($DH)){next if($dir_entry =~ /^\.{1,2}$/);my$item;my$filename="$path/$dir_entry";if(!$self->{FOLLOW_SYMLINK}&& -l $filename){next}if(-d $filename){$item=$self->_load($filename);$item->{name}=basename($item->{name})}elsif(-f $filename){($item->{size},my$mtime)=(stat($filename))[7,9];$item->{name}=$dir_entry;$item->{colour}=$self->_colour_by_mtime($mtime)}else {next}push(@children,$item);$size += $item->{size}}close($DH);$tree->{name}=$path;$tree->{size}=$size;$tree->{colour}="#FFFFFF";$tree->{children}=\@children if(scalar(@children)> 0);return$tree}sub _colour_by_mtime {my$self=shift;my$mtime=shift;my$ctime=time;my$age=1 + ($ctime - $mtime)/ (60 * 60);my$level=int (log($age)* 10);$level=100 if ($level > 100);$level=int(255 * ($level / 100));return sprintf("#%02X%02X%02X",255-$level,0,$level)}sub _colour_by_type {my$self=shift;my$ext=shift;$ext =~ m/(\w)(\w)?(\w)?/}1;
TREEMAP_INPUT_DIR

$fatpacked{"Treemap/Input/Input.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TREEMAP_INPUT_INPUT';
  package Treemap::Simple;use 5.006;use strict;use warnings;use Carp;require Exporter;our@ISA=qw(Exporter);our@EXPORT_OK=();our@EXPORT=qw();our$VERSION='0.01';sub new {my$proto=shift;my$class=ref($proto)|| $proto;my$self={};bless$self,$class;return$self}1;
TREEMAP_INPUT_INPUT

$fatpacked{"Treemap/Input/XML.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TREEMAP_INPUT_XML';
  package Treemap::Input::XML;use 5.006;use strict;use warnings;use Carp;use XML::TreePP;require Exporter;require Treemap::Input;our@ISA=qw(Treemap::Input Exporter);our@EXPORT_OK=();our@EXPORT=qw();our$VERSION='0.01';sub load {my$self=shift;my($path)=@_;if ($self->{DATA }=$self->_load($path)){return 1}return 0}sub _load {my$self=shift;my($path)=@_;my$xml=XML::TreePP->new(attr_prefix=>"",force_array=>[qw(children)]);return$xml->parsefile($path)}1;
TREEMAP_INPUT_XML

$fatpacked{"Treemap/Output.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TREEMAP_OUTPUT';
  package Treemap::Output;use 5.006;use strict;use warnings;use Carp;require Exporter;our@ISA=qw(Exporter);our@EXPORT_OK=();our@EXPORT=qw();our$VERSION='0.01';sub new {my$proto=shift;my$class=ref($proto)|| $proto;my$self={@_,};bless$self,$class;return$self}1;
TREEMAP_OUTPUT

$fatpacked{"Treemap/Output/Imager.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TREEMAP_OUTPUT_IMAGER';
  package Treemap::Output::Imager;use 5.006;use strict;use warnings;use Carp;require Exporter;require Treemap::Output;require Imager;require Imager::Font;require Imager::Color;our@ISA=qw(Treemap::Output Exporter);our@EXPORT_OK=();our@EXPORT=qw();our$VERSION='0.01';sub new {my$classname=shift;my$self=$classname->SUPER::new(@_);$self->_init(@_);return$self}sub _init {my$self=shift;$self->{WIDTH}=$self->{WIDTH}|| 400;$self->{HEIGHT}=$self->{HEIGHT}|| 300;$self->{PADDING}=$self->{PADDING}|| 5;$self->{SPACING}=$self->{SPACING}|| 5;$self->{BORDER_COLOUR}=$self->{BORDER_COLOUR}|| "#000000";$self->{FONT_COLOUR}=$self->{FONT_COLOUR}|| "#000000";$self->{MIN_FONT_SIZE}=$self->{MIN_FONT_SIZE}|| 5;$self->{FONT_FILE}=$self->{FONT_FILE}|| "ImUgly.ttf";$self->{TEXT_DEBUG}=$self->{TEXT_DEBUG}|| 0;$self->{DEBUG}=$self->{DEBUG}|| 0;$self->{IMAGE}=Imager->new(xsize=>$self->{WIDTH},ysize=>$self->{HEIGHT});$self->{ALPHA}=Imager->new();$self->{DEBUG}&& print STDERR "Created a new image object.\n";$self->{COLOUR_CACHE}->{$self->{BORDER_COLOUR}}=Imager::Color->new($self->{BORDER_COLOUR});$self->{ALPHA_FONT}=Imager::Color->new(0,0,0,110);$self->{SOLID_FONT}=Imager::Color->new($self->{FONT_COLOUR});$self->{FONT}=Imager::Font->new(file=>$self->{FONT_FILE},color=>$self->{SOLID_FONT},aa=>1,type=>'ft2');$self->{font_iters}=0}sub save {my$self=shift;my ($filename)=@_;$self->{IMAGE}->write(file=>$filename);return 1}sub rect {my$self=shift;my ($x1,$y1,$x2,$y2,$colour)=@_;my$area=($x2 - $x1)* ($y2 - $y1);if (!$self->{COLOUR_CACHE}->{$colour}){$self->{COLOUR_CACHE}->{$colour}=Imager::Color->new($colour)}$self->{IMAGE}->box(color=>$self->{COLOUR_CACHE}->{$colour},xmin=>$x1,ymin=>$y1,xmax=>$x2,ymax=>$y2,filled=>1);return 1 if ($area < 3);$self->{IMAGE}->box(color=>$self->{COLOUR_CACHE}->{$self->{BORDER_COLOUR}},xmin=>$x1,ymin=>$y1,xmax=>$x2,ymax=>$y2,filled=>0);return 1}sub text {my$self=shift;my ($x1,$y1,$x2,$y2,$text,$children)=@_;my$x=$x1 + ($x2 - $x1)/ 2;my$y=$y1 + ($y2 - $y1)/ 2;my$width=abs($x2 - $x1);my$height=abs($y2 - $y1);return 1 if ($width < 20);return 1 if ($height < 10);my$size=$self->_font_fit($width,$height,$text);return 1 if (!$size);my@metrix=$self->{FONT}->bounding_box(string=>$text,size=>$size,canon=>1);if($children){$x -= $metrix[2]/2;$y -= $metrix[3]/2;$self->{ALPHA}->img_set(xsize=>$metrix[2],ysize=>$metrix[3],channels=>4);$self->{ALPHA}->string(font=>$self->{FONT},text=>$text,x=>0,y=>$metrix[3]+$metrix[1],color=>$self->{ALPHA_FONT},size=>$size);$self->{IMAGE}->rubthrough(src=>$self->{ALPHA},tx=>$x,ty=>$y)}else {$x -= $metrix[2]/2;$y += $metrix[3]/3;my$top_pad=int(($height - $metrix[5])* 0.1);$top_pad=($top_pad > 5)? 5 : $top_pad;$y=$y1 + $metrix[5]+ $top_pad;$self->{IMAGE}->string(font=>$self->{FONT},text=>$text,x=>$x,y=>$y,color=>$self->{SOLID_FONT},size=>$size)}return 1}sub _font_fit {my$self=shift;my ($width,$height,$text)=@_;my$DEBUG=$self->{TEXT_DEBUG};return unless$text && (length($text))&& $height && $width;my$local_iters=0;$self->{TEXT_DEBUG}&& print STDERR "$text:\n";unless ($self->{ACWPP}){$self->{ACWPP}=$self->_calc_avg_char_weight_per_pt();croak("Initialization of font fitting algorhythm failed.")unless ($self->{ACWPP})}my$size=int(($width / length($text))/ $self->{ACWPP});return if ($size <= ($self->{MIN_FONT_SIZE}- 2));my@metrix=$self->{FONT}->bounding_box(string=>$text,size=>$size,canon=>1);if (($metrix[2]<= $width)&& ($metrix[3]> $height)){if ((abs($height - $metrix[3])/ $height)* $size >= 3){$self->{font_iters}++;$local_iters++;$self->{TEXT_DEBUG}&& print STDERR "\tHeight restricted, changing $size =>";$size=int($size * ($height / $metrix[3]));$self->{TEXT_DEBUG}&& print STDERR "$size.\n";@metrix=$self->{FONT}->bounding_box(string=>$text,size=>$size,canon=>1)}}elsif ((abs($width - $metrix[2])/ $width)* $size >= 3){$self->{font_iters}++;$local_iters++;$self->{TEXT_DEBUG}&& print STDERR "\tOff by 3pts+, changing $size =>";$size=int($size * ($width / $metrix[2]));$self->{TEXT_DEBUG}&& print STDERR "$size.\n";@metrix=$self->{FONT}->bounding_box(string=>$text,size=>$size,canon=>1)}if (($metrix[2]> $width)|| ($metrix[3]> $height)){$self->{TEXT_DEBUG}&& print STDERR "\tGuess ($size) too large.\n";while (($metrix[2]> $width)|| ($metrix[3]> $height)){$self->{font_iters}++;$local_iters++;$size--;return if ($size < 5);@metrix=$self->{FONT}->bounding_box(string=>$text,size=>$size,canon=>1)}}elsif (($metrix[2]<= $width)&& ($metrix[3]<= $height)){$self->{TEXT_DEBUG}&& print STDERR "\tGuess ($size) fits, adjusting.\n";while (($metrix[2]<= $width)&& ($metrix[3]<= $height)){$self->{font_iters}++;$local_iters++;$size++;$size++ if ($size > 50);@metrix=$self->{FONT}->bounding_box(string=>$text,size=>$size,canon=>1)}$size--}$self->{TEXT_DEBUG}&& print STDERR "\t$local_iters :: " .$self->{font_iters}." => $size\n";$size=int($size * 0.9);return if ($size < $self->{MIN_FONT_SIZE});return$size}sub _calc_avg_char_weight_per_pt {my$self=shift;my$wieghting_string="rstlnaei0RST.-";my$sample_size=50;my@metrix=$self->{FONT}->bounding_box(string=>$wieghting_string,size=>$sample_size,canon=>1);my$sample_width=$metrix[2];return unless ($sample_width);return ($sample_width / length($wieghting_string)/ $sample_size)}sub width {my$self=shift;return$self->{WIDTH}}sub height {my$self=shift;return$self->{HEIGHT}}sub font_height {my$self=shift;return "12"}sub padding {my$self=shift;return$self->{PADDING}}sub spacing {my$self=shift;return$self->{SPACING}}1;
TREEMAP_OUTPUT_IMAGER

$fatpacked{"Treemap/Output/PrintedText.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TREEMAP_OUTPUT_PRINTEDTEXT';
  package Treemap::Output::PrintedText;use 5.006;use strict;use warnings;use Carp;require Exporter;require Treemap::Output;our@ISA=qw(Treemap::Output Exporter);our@EXPORT_OK=();our@EXPORT=qw();our$VERSION='0.01';sub save {my$self=shift;return 1}sub rect {my$self=shift;$self->{DEPTH}=$self->{DEPTH}| 0;print " " x ($self->{DEPTH}* 3);print "rect: @_\n";$self->{DEPTH}++}sub text {my$self=shift;$self->{DEPTH}--;print " " x ($self->{DEPTH}* 3);print "text: @_\n"}sub width {return "1024"}sub height {return "768"}sub font_height {return "10"}sub padding {return "10"}1;
TREEMAP_OUTPUT_PRINTEDTEXT

$fatpacked{"Treemap/Simple.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TREEMAP_SIMPLE';
  package Treemap::Simple;use 5.006;use strict;use warnings;use Carp;require Exporter;our@ISA=qw(Exporter Treemap);our@EXPORT_OK=();our@EXPORT=qw();our$VERSION='0.01';sub new {my$proto=shift;my$class=ref($proto)|| $proto;my$self={};bless$self,$class;return$self}1;
TREEMAP_SIMPLE

$fatpacked{"Treemap/Squarified.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TREEMAP_SQUARIFIED';
  package Treemap::Squarified;use 5.006;use strict;use warnings;use Carp;require Exporter;require Treemap;our@ISA=qw(Treemap Exporter);our@EXPORT_OK=();our@EXPORT=qw();our$VERSION='0.02';sub _map {my$self=shift;my (@p,@q,$tree);my$debug=undef;($tree,$p[0],$p[1],$q[0],$q[1])=@_;$self->{DEBUG}&& print STDERR "Drawing space for $tree->{name}:\n\t@p, @q\n";$self->{OUTPUT }->rect($p[0],$p[1],$q[0],$q[1],$tree->{colour});if($tree->{children}){my ($pt,$qt)=$self->_shrink(\@p,\@q,$self->{PADDING});my@p=@{$pt};my@q=@{$qt};$self->{DEBUG}&& print STDERR "\tI have " .scalar(@{$tree->{children}})." children... ";if(scalar(@{$tree->{children}})< 3){$self->{DEBUG}&& print STDERR "SLICE.\n";my (@r,@s,$o,$width);$o=(abs($p[0]-$q[0])> abs($p[1]-$q[1])? 0 : 1);@r=@p;@s=@q;$width=abs($s[$o]- $r[$o]);for my$child(@{$tree->{children}}){$s[$o]=$r[$o]+ $width * ($child->{size}/ $tree->{size})if($tree->{size}> 0);{my ($st,$rt)=$self->_shrink(\@s,\@r,$self->{SPACING});my@s=@{$st};my@r=@{$rt};$self->_map($child,$r[0],$r[1],$s[0],$s[1])}$r[$o]=$s[$o]}}else {$self->{DEBUG}&& print STDERR "SQUARIFY.\n";my@indices=0..(scalar(@{$tree->{children}})- 1);my@sorted_children=sort {$tree->{children}->[$b]->{size}<=> $tree->{children}->[$a]->{size}}@indices;my ($area,$parent_area,$parent_aspect,$usable_width,$usable_height,@j,@k,$o);$area=0;$parent_area=$tree->{size};@j=@p;@k=@q;$o=(abs($j[0]-$k[0])> abs($j[1]-$k[1])? 0 : 1);$usable_width=0;while($parent_area > 0 && @sorted_children > 0){$parent_area -= $area;$area=0;$j[$o]=$j[$o]+ $usable_width;last if ($j[0]==$k[0]|| $j[1]==$k[1]);$o=(abs($j[0]-$k[0])> abs($j[1]-$k[1])? 0 : 1);$parent_aspect=(abs($j[$o]- $k[$o])/ abs($j[($o xor 1)]- $k[($o xor 1)]));my$scaled_height=sqrt($parent_area / $parent_aspect);my@special_children;my$aspect=0;while(scalar(@sorted_children)> 0){my$child=shift(@sorted_children);push(@special_children,$child);my$area_test=$area + $tree->{children}->[$child]->{size};my$aspect_test=$self->_find_worst($tree->{children},\@special_children,$area_test,$scaled_height);if($aspect_test > $aspect){$self->{DEBUG}&& print STDERR "\t\t$aspect_test is a BETTER aspect ratio than $aspect\n";$area=$area_test;$aspect=$aspect_test}else {$self->{DEBUG}&& print STDERR "\t\t$aspect_test is a WORSE aspect ratio than $aspect\n";pop(@special_children);unshift(@sorted_children,$child);last}}if(@special_children > 0){$self->{DEBUG}&& print STDERR "\t\t\tHandling Special Children: @special_children\n";my (@r,@s);my$o_xor=($o xor 1);$usable_width=($k[$o]-$j[$o])* ($area / $parent_area);$usable_height=$k[$o_xor]- $j[$o_xor];@r=@j;@s=@k;$s[$o]=$r[$o]+ $usable_width;$self->{DEBUG}&& print STDERR "\t\t\tUsable Space for Special Children: $usable_width x $usable_height\n";for my$child(@special_children){$s[$o_xor]=$r[$o_xor]+ $usable_height * ($tree->{children}->[$child]->{size}/ $area)if($area > 0);{my ($st,$rt)=$self->_shrink(\@s,\@r,$self->{SPACING});my@s=@{$st};my@r=@{$rt};$self->_map($tree->{children}->[$child],$r[0],$r[1],$s[0],$s[1])}$r[$o_xor]=$s[$o_xor]}}else {$self->{DEBUG}&& print STDERR "No special children... awww\n"}}}}$self->{OUTPUT }->text($p[0],$p[1],$q[0],$q[1],$tree->{name},($tree->{children}?1:undef))}sub _find_worst {my$self=shift;my ($tree,$set,$area,$height)=@_;my$width=$area / $height;my$width_squared=$width ** 2;my$worst=undef;for my$item(@{$set}){return 0 if$tree->[$item]->{size}==0;my$aspect=$width_squared / $tree->[$item]->{size};$aspect=1 / $aspect if ($aspect > 1);if ($worst){$worst=$aspect if ($aspect < $worst)}else {$worst=$aspect}}return$worst}1;
TREEMAP_SQUARIFIED

$fatpacked{"Treemap/Strip.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TREEMAP_STRIP';
  package Treemap::Strip;use 5.006;use strict;use warnings;use Carp;require Exporter;our@ISA=qw(Exporter Treemap);our@EXPORT_OK=();our@EXPORT=qw();our$VERSION='0.01';sub new {my$proto=shift;my$class=ref($proto)|| $proto;my$self={};$self->{RECT }=\&rect;$self->{TEXT }=\&text;bless$self,$class;return$self}sub map {my$self=shift;my (@p,@q,$tree,$o);($tree,$p[0],$p[1],$q[0],$q[1],$o)=@_;$o=$o || 0;&{$self->{RECT }}($p[0],$p[1],$q[0],$q[1],$tree->{colour});if($tree->{children}){my@r=@p;my@s=@q;my$width=abs($p[$o]- $q[$o]);my$size=$tree->{size};for my$child(@{$tree->{children}}){$s[$o]=$r[$o]+ $width * ($child->{size}/ $size)if ($size > 0);$self->map($child,$r[0],$r[1],$s[0],$s[1],($o xor 1));$r[$o]=$s[$o]}}}1;
TREEMAP_STRIP

$fatpacked{"XML/TreePP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'XML_TREEPP';
  package XML::TreePP;use strict;use Carp;use Symbol;use vars qw($VERSION);$VERSION='0.43';my$XML_ENCODING='UTF-8';my$INTERNAL_ENCODING='UTF-8';my$USER_AGENT='XML-TreePP/'.$VERSION.' ';my$ATTR_PREFIX='-';my$TEXT_NODE_KEY='#text';my$USE_ENCODE_PM=($] >= 5.008);my$ALLOW_UTF8_FLAG=($] >= 5.008001);my$EMPTY_ELEMENT_TAG_END=' />';sub new {my$package=shift;my$self={@_};bless$self,$package;$self}sub die {my$self=shift;my$mess=shift;return if$self->{ignore_error};Carp::croak$mess}sub warn {my$self=shift;my$mess=shift;return if$self->{ignore_error};Carp::carp$mess}sub set {my$self=shift;my$key=shift;my$val=shift;if (defined$val){$self->{$key}=$val}else {delete$self->{$key}}}sub get {my$self=shift;my$key=shift;$self->{$key}if exists$self->{$key}}sub writefile {my$self=shift;my$file=shift;my$tree=shift or return$self->die('Invalid tree');my$encode=shift;return$self->die('Invalid filename')unless defined$file;my$text=$self->write($tree,$encode);if ($ALLOW_UTF8_FLAG && utf8::is_utf8($text)){utf8::encode($text)}$self->write_raw_xml($file,$text)}sub write {my$self=shift;my$tree=shift or return$self->die('Invalid tree');my$from=$self->{internal_encoding}|| $INTERNAL_ENCODING;my$to=shift || $self->{output_encoding}|| $XML_ENCODING;my$decl=$self->{xml_decl};$decl='<?xml version="1.0" encoding="' .$to .'" ?>' unless defined$decl;local$self->{__first_out};if (exists$self->{first_out}){my$keys=$self->{first_out};$keys=[$keys]unless ref$keys;$self->{__first_out}={map {$keys->[$_]=>$_}0 .. $#$keys }}local$self->{__last_out};if (exists$self->{last_out}){my$keys=$self->{last_out};$keys=[$keys]unless ref$keys;$self->{__last_out}={map {$keys->[$_]=>$_}0 .. $#$keys }}my$tnk=$self->{text_node_key}if exists$self->{text_node_key};$tnk=$TEXT_NODE_KEY unless defined$tnk;local$self->{text_node_key}=$tnk;my$apre=$self->{attr_prefix}if exists$self->{attr_prefix};$apre=$ATTR_PREFIX unless defined$apre;local$self->{__attr_prefix_len}=length($apre);local$self->{__attr_prefix_rex}=$apre;local$self->{__indent};if (exists$self->{indent}&& $self->{indent}){$self->{__indent}=' ' x $self->{indent}}if (!UNIVERSAL::isa($tree,'HASH')){return$self->die('Invalid tree')}my$text=$self->hash_to_xml(undef,$tree);if ($from && $to){my$stat=$self->encode_from_to(\$text,$from,$to);return$self->die("Unsupported encoding: $to")unless$stat}return$text if ($decl eq '');join("\n",$decl,$text)}sub parsehttp {my$self=shift;local$self->{__user_agent};if (exists$self->{user_agent}){my$agent=$self->{user_agent};$agent .= $USER_AGENT if ($agent =~ /\s$/s);$self->{__user_agent}=$agent if ($agent ne '')}else {$self->{__user_agent}=$USER_AGENT}my$http=$self->{__http_module};unless ($http){$http=$self->find_http_module(@_);$self->{__http_module}=$http}if ($http eq 'LWP::UserAgent'){return$self->parsehttp_lwp(@_)}elsif ($http eq 'HTTP::Lite'){return$self->parsehttp_lite(@_)}else {return$self->die("LWP::UserAgent or HTTP::Lite is required: $_[1]")}}sub find_http_module {my$self=shift || {};if (exists$self->{lwp_useragent}&& ref$self->{lwp_useragent}){return 'LWP::UserAgent' if defined$LWP::UserAgent::VERSION;return 'LWP::UserAgent' if&load_lwp_useragent();return$self->die("LWP::UserAgent is required: $_[1]")}if (exists$self->{http_lite}&& ref$self->{http_lite}){return 'HTTP::Lite' if defined$HTTP::Lite::VERSION;return 'HTTP::Lite' if&load_http_lite();return$self->die("HTTP::Lite is required: $_[1]")}return 'LWP::UserAgent' if defined$LWP::UserAgent::VERSION;return 'HTTP::Lite' if defined$HTTP::Lite::VERSION;return 'LWP::UserAgent' if&load_lwp_useragent();return 'HTTP::Lite' if&load_http_lite();return$self->die("LWP::UserAgent or HTTP::Lite is required: $_[1]")}sub load_lwp_useragent {return$LWP::UserAgent::VERSION if defined$LWP::UserAgent::VERSION;local $@;eval {require LWP::UserAgent};$LWP::UserAgent::VERSION}sub load_http_lite {return$HTTP::Lite::VERSION if defined$HTTP::Lite::VERSION;local $@;eval {require HTTP::Lite};$HTTP::Lite::VERSION}sub load_tie_ixhash {return$Tie::IxHash::VERSION if defined$Tie::IxHash::VERSION;local $@;eval {require Tie::IxHash};$Tie::IxHash::VERSION}sub parsehttp_lwp {my$self=shift;my$method=shift or return$self->die('Invalid HTTP method');my$url=shift or return$self->die('Invalid URL');my$body=shift;my$header=shift;my$ua=$self->{lwp_useragent}if exists$self->{lwp_useragent};if (!ref$ua){$ua=LWP::UserAgent->new();$ua->env_proxy();$ua->agent($self->{__user_agent})if defined$self->{__user_agent}}else {$ua->agent($self->{__user_agent})if exists$self->{user_agent}}my$req=HTTP::Request->new($method,$url);my$ct=0;if (ref$header){for my$field (sort keys %$header){my$value=$header->{$field};$req->header($field=>$value);$ct ++ if ($field =~ /^Content-Type$/i)}}if (defined$body &&!$ct){$req->header('Content-Type'=>'application/x-www-form-urlencoded')}$req->add_content_utf8($body)if defined$body;my$res=$ua->request($req);my$code=$res->code();my$text;if ($res->can('decoded_content')){$text=$res->decoded_content(charset=>'none')}else {$text=$res->content()}my$tree=$self->parse(\$text)if$res->is_success();wantarray ? ($tree,$text,$code): $tree}sub parsehttp_lite {my$self=shift;my$method=shift or return$self->die('Invalid HTTP method');my$url=shift or return$self->die('Invalid URL');my$body=shift;my$header=shift;my$http=HTTP::Lite->new();$http->method($method);my$ua=0;if (ref$header){for my$field (sort keys %$header){my$value=$header->{$field};$http->add_req_header($field,$value);$ua ++ if ($field =~ /^User-Agent$/i)}}if (defined$self->{__user_agent}&&!$ua){$http->add_req_header('User-Agent',$self->{__user_agent})}$http->{content}=$body if defined$body;my$code=$http->request($url)or return;my$text=$http->body();my$tree=$self->parse(\$text);wantarray ? ($tree,$text,$code): $tree}sub parsefile {my$self=shift;my$file=shift;return$self->die('Invalid filename')unless defined$file;my$text=$self->read_raw_xml($file);$self->parse(\$text)}sub parse {my$self=shift;my$text=ref $_[0]? ${$_[0]}: $_[0];return$self->die('Null XML source')unless defined$text;my$from=&xml_decl_encoding(\$text)|| $XML_ENCODING;my$to=$self->{internal_encoding}|| $INTERNAL_ENCODING;if ($from && $to){my$stat=$self->encode_from_to(\$text,$from,$to);return$self->die("Unsupported encoding: $from")unless$stat}local$self->{__force_array};local$self->{__force_array_all};if (exists$self->{force_array}){my$force=$self->{force_array};$force=[$force]unless ref$force;$self->{__force_array}={map {$_=>1}@$force };$self->{__force_array_all}=$self->{__force_array}->{'*'}}local$self->{__force_hash};local$self->{__force_hash_all};if (exists$self->{force_hash}){my$force=$self->{force_hash};$force=[$force]unless ref$force;$self->{__force_hash}={map {$_=>1}@$force };$self->{__force_hash_all}=$self->{__force_hash}->{'*'}}my$tnk=$self->{text_node_key}if exists$self->{text_node_key};$tnk=$TEXT_NODE_KEY unless defined$tnk;local$self->{text_node_key}=$tnk;my$apre=$self->{attr_prefix}if exists$self->{attr_prefix};$apre=$ATTR_PREFIX unless defined$apre;local$self->{attr_prefix}=$apre;if (exists$self->{use_ixhash}&& $self->{use_ixhash}){return$self->die("Tie::IxHash is required.")unless&load_tie_ixhash()}if (exists$self->{require_xml_decl}&& $self->{require_xml_decl}){return$self->die("XML declaration not found")unless looks_like_xml(\$text)}my$flat=$self->xml_to_flat(\$text);my$class=$self->{base_class}if exists$self->{base_class};my$tree=$self->flat_to_tree($flat,'',$class);if (ref$tree){if (defined$class){bless($tree,$class)}elsif (exists$self->{elem_class}&& $self->{elem_class}){bless($tree,$self->{elem_class})}}wantarray ? ($tree,$text): $tree}sub xml_to_flat {my$self=shift;my$textref=shift;my$flat=[];my$prefix=$self->{attr_prefix};my$ixhash=(exists$self->{use_ixhash}&& $self->{use_ixhash});my$deref=\&xml_unescape;my$xml_deref=(exists$self->{xml_deref}&& $self->{xml_deref});if ($xml_deref){if ((exists$self->{utf8_flag}&& $self->{utf8_flag})|| ($ALLOW_UTF8_FLAG && utf8::is_utf8($$textref))){$deref=\&xml_deref_string}else {$deref=\&xml_deref_octet}}while ($$textref =~ m{
          ([^<]*) <
          ((
              \? ([^<>]*) \?
          )|(
              \!\[CDATA\[(.*?)\]\]
          )|(
              \!DOCTYPE\s+([^\[\]<>]*(?:\[.*?\]\s*)?)
          )|(
              \!--(.*?)--
          )|(
              ([^\!\?\s<>](?:"[^"]*"|'[^']*'|[^"'<>])*)
          ))
          > ([^<]*)
      }sxg){my ($ahead,$match,$typePI,$contPI,$typeCDATA,$contCDATA,$typeDocT,$contDocT,$typeCmnt,$contCmnt,$typeElem,$contElem,$follow)=($1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13);if (defined$ahead && $ahead =~ /\S/){$ahead =~ s/([^\040-\076])/sprintf("\\x%02X",ord($1))/eg;$self->warn("Invalid string: [$ahead] before <$match>")}if ($typeElem){my$node={};if ($contElem =~ s#^/##){$node->{endTag}++}elsif ($contElem =~ s#/$##){$node->{emptyTag}++}else {$node->{startTag}++}$node->{tagName}=$1 if ($contElem =~ s#^(\S+)\s*##);unless ($node->{endTag}){my$attr;while ($contElem =~ m{
                      ([^\s\=\"\']+)\s*=\s*(?:(")(.*?)"|'(.*?)')
                  }sxg){my$key=$1;my$val=&$deref($2 ? $3 : $4);if (!ref$attr){$attr={};tie(%$attr,'Tie::IxHash')if$ixhash}$attr->{$prefix.$key}=$val}$node->{attributes}=$attr if ref$attr}push(@$flat,$node)}elsif ($typeCDATA){if (exists$self->{cdata_scalar_ref}&& $self->{cdata_scalar_ref}){push(@$flat,\$contCDATA)}else {push(@$flat,$contCDATA)}}elsif ($typeCmnt){}elsif ($typeDocT){}elsif ($typePI){}else {$self->warn("Invalid Tag: <$match>")}if ($follow =~ /\S/){my$val=&$deref($follow);push(@$flat,$val)}}$flat}sub flat_to_tree {my$self=shift;my$source=shift;my$parent=shift;my$class=shift;my$tree={};my$text=[];if (exists$self->{use_ixhash}&& $self->{use_ixhash}){tie(%$tree,'Tie::IxHash')}while (scalar @$source){my$node=shift @$source;if (!ref$node || UNIVERSAL::isa($node,"SCALAR")){push(@$text,$node);next}my$name=$node->{tagName};if ($node->{endTag}){last if ($parent eq $name);return$self->die("Invalid tag sequence: <$parent></$name>")}my$elem=$node->{attributes};my$forcehash=$self->{__force_hash_all}|| $self->{__force_hash}->{$name};my$subclass;if (defined$class){my$escname=$name;$escname =~ s/\W/_/sg;$subclass=$class.'::'.$escname}if ($node->{startTag}){my$child=$self->flat_to_tree($source,$name,$subclass);next unless defined$child;my$hasattr=scalar keys %$elem if ref$elem;if (UNIVERSAL::isa($child,"HASH")){if ($hasattr){%$elem=(%$elem,%$child)}else {$elem=$child}}else {if ($hasattr){$elem->{$self->{text_node_key}}=$child}elsif ($forcehash){$elem={$self->{text_node_key}=>$child }}else {$elem=$child}}}elsif ($forcehash &&!ref$elem){$elem={}}if (ref$elem && UNIVERSAL::isa($elem,"HASH")){if (defined$subclass){bless($elem,$subclass)}elsif (exists$self->{elem_class}&& $self->{elem_class}){my$escname=$name;$escname =~ s/\W/_/sg;my$elmclass=$self->{elem_class}.'::'.$escname;bless($elem,$elmclass)}}$tree->{$name}||=[];push(@{$tree->{$name}},$elem)}if (!$self->{__force_array_all}){for my$key (keys %$tree){next if$self->{__force_array}->{$key};next if (1 < scalar @{$tree->{$key}});$tree->{$key}=shift @{$tree->{$key}}}}my$haschild=scalar keys %$tree;if (scalar @$text){if (scalar @$text==1){$text=shift @$text}elsif (!scalar grep {ref $_}@$text){$text=join('',@$text)}else {my$join=join('',map {ref $_ ? $$_ : $_}@$text);$text=\$join}if ($haschild){$tree->{$self->{text_node_key}}=$text}else {$tree=$text}}elsif (!$haschild){$tree=""}$tree}sub hash_to_xml {my$self=shift;my$name=shift;my$hash=shift;my$out=[];my$attr=[];my$allkeys=[keys %$hash ];my$fo=$self->{__first_out}if ref$self->{__first_out};my$lo=$self->{__last_out}if ref$self->{__last_out};my$firstkeys=[sort {$fo->{$a}<=> $fo->{$b}}grep {exists$fo->{$_}}@$allkeys ]if ref$fo;my$lastkeys=[sort {$lo->{$a}<=> $lo->{$b}}grep {exists$lo->{$_}}@$allkeys ]if ref$lo;$allkeys=[grep {!exists$fo->{$_}}@$allkeys ]if ref$fo;$allkeys=[grep {!exists$lo->{$_}}@$allkeys ]if ref$lo;unless (exists$self->{use_ixhash}&& $self->{use_ixhash}){$allkeys=[sort @$allkeys ]}my$prelen=$self->{__attr_prefix_len};my$pregex=$self->{__attr_prefix_rex};my$textnk=$self->{text_node_key};my$tagend=$self->{empty_element_tag_end}|| $EMPTY_ELEMENT_TAG_END;for my$keys ($firstkeys,$allkeys,$lastkeys){next unless ref$keys;my$elemkey=$prelen ? [grep {substr($_,0,$prelen)ne $pregex}@$keys ]: $keys;my$attrkey=$prelen ? [grep {substr($_,0,$prelen)eq $pregex}@$keys ]: [];for my$key (@$elemkey){my$val=$hash->{$key};if (!defined$val){next if ($key eq $textnk);push(@$out,"<$key$tagend")}elsif (UNIVERSAL::isa($val,'HASH')){my$child=$self->hash_to_xml($key,$val);push(@$out,$child)}elsif (UNIVERSAL::isa($val,'ARRAY')){my$child=$self->array_to_xml($key,$val);push(@$out,$child)}elsif (UNIVERSAL::isa($val,'SCALAR')){my$child=$self->scalaref_to_cdata($key,$val);push(@$out,$child)}else {my$ref=ref$val;$self->warn("Unsupported reference type: $ref in $key")if$ref;my$child=$self->scalar_to_xml($key,$val);push(@$out,$child)}}for my$key (@$attrkey){my$name=substr($key,$prelen);my$val=&xml_escape($hash->{$key});push(@$attr,' ' .$name .'="' .$val .'"')}}my$jattr=join('',@$attr);if (defined$name && scalar @$out &&!grep {!/^</s}@$out){if (defined$self->{__indent}){s/^(\s*<)/$self->{__indent}$1/mg foreach @$out}unshift(@$out,"\n")}my$text=join('',@$out);if (defined$name){if (scalar @$out){$text="<$name$jattr>$text</$name>\n"}else {$text="<$name$jattr$tagend\n"}}$text}sub array_to_xml {my$self=shift;my$name=shift;my$array=shift;my$out=[];my$tagend=$self->{empty_element_tag_end}|| $EMPTY_ELEMENT_TAG_END;for my$val (@$array){if (!defined$val){push(@$out,"<$name$tagend\n")}elsif (UNIVERSAL::isa($val,'HASH')){my$child=$self->hash_to_xml($name,$val);push(@$out,$child)}elsif (UNIVERSAL::isa($val,'ARRAY')){my$child=$self->array_to_xml($name,$val);push(@$out,$child)}elsif (UNIVERSAL::isa($val,'SCALAR')){my$child=$self->scalaref_to_cdata($name,$val);push(@$out,$child)}else {my$ref=ref$val;$self->warn("Unsupported reference type: $ref in $name")if$ref;my$child=$self->scalar_to_xml($name,$val);push(@$out,$child)}}my$text=join('',@$out);$text}sub scalaref_to_cdata {my$self=shift;my$name=shift;my$ref=shift;my$data=defined $$ref ? $$ref : '';$data =~ s#(]])(>)#$1]]><![CDATA[$2#g;my$text='<![CDATA[' .$data .']]>';$text="<$name>$text</$name>\n" if ($name ne $self->{text_node_key});$text}sub scalar_to_xml {my$self=shift;my$name=shift;my$scalar=shift;my$copy=$scalar;my$text=&xml_escape($copy);$text="<$name>$text</$name>\n" if ($name ne $self->{text_node_key});$text}sub write_raw_xml {my$self=shift;my$file=shift;my$fh=Symbol::gensym();open($fh,">$file")or return$self->die("$! - $file");print$fh @_;close($fh)}sub read_raw_xml {my$self=shift;my$file=shift;my$fh=Symbol::gensym();open($fh,$file)or return$self->die("$! - $file");local $/=undef;my$text=<$fh>;close($fh);$text}sub looks_like_xml {my$textref=shift;my$args=($$textref =~ /^(?:\s*\xEF\xBB\xBF)?\s*<\?xml(\s+\S.*)\?>/s)[0];if (!$args){return}return$args}sub xml_decl_encoding {my$textref=shift;return unless defined $$textref;my$args=looks_like_xml($textref)or return;my$getcode=($args =~ /\s+encoding=(".*?"|'.*?')/)[0]or return;$getcode =~ s/^['"]//;$getcode =~ s/['"]$//;$getcode}sub encode_from_to {my$self=shift;my$txtref=shift or return;my$from=shift or return;my$to=shift or return;unless (defined$Encode::EUCJPMS::VERSION){$from='EUC-JP' if ($from =~ /\beuc-?jp-?(win|ms)$/i);$to='EUC-JP' if ($to =~ /\beuc-?jp-?(win|ms)$/i)}my$RE_IS_UTF8=qr/^utf-?8$/i;if ($from =~ $RE_IS_UTF8){$$txtref =~ s/^\xEF\xBB\xBF//s}my$setflag=$self->{utf8_flag}if exists$self->{utf8_flag};if (!$ALLOW_UTF8_FLAG && $setflag){return$self->die("Perl 5.8.1 is required for utf8_flag: $]")}if ($USE_ENCODE_PM){&load_encode();my$encver=($Encode::VERSION =~ /^([\d\.]+)/)[0];my$check=($encver < 2.13)? 0x400 : Encode::FB_XMLCREF();my$encfrom=Encode::find_encoding($from)if$from;return$self->die("Unknown encoding: $from")unless ref$encfrom;my$encto=Encode::find_encoding($to)if$to;return$self->die("Unknown encoding: $to")unless ref$encto;if ($ALLOW_UTF8_FLAG && utf8::is_utf8($$txtref)){if ($to =~ $RE_IS_UTF8){}else {$$txtref=$encto->encode($$txtref,$check)}}else {$$txtref=$encfrom->decode($$txtref);if ($to =~ $RE_IS_UTF8 && $setflag){}else {$$txtref=$encto->encode($$txtref,$check)}}}elsif ((uc($from)eq 'ISO-8859-1' || uc($from)eq 'US-ASCII' || uc($from)eq 'LATIN-1')&& uc($to)eq 'UTF-8'){&latin1_to_utf8($txtref)}else {my$jfrom=&get_jcode_name($from);my$jto=&get_jcode_name($to);return$to if (uc($jfrom)eq uc($jto));if ($jfrom && $jto){&load_jcode();if (defined$Jcode::VERSION){Jcode::convert($txtref,$jto,$jfrom)}else {return$self->die("Jcode.pm is required: $from to $to")}}else {return$self->die("Encode.pm is required: $from to $to")}}$to}sub load_jcode {return if defined$Jcode::VERSION;local $@;eval {require Jcode}}sub load_encode {return if defined$Encode::VERSION;local $@;eval {require Encode}}sub latin1_to_utf8 {my$strref=shift;$$strref =~ s{
          ([\x80-\xFF])
      }{
          pack( 'C2' => 0xC0|(ord($1)>>6),0x80|(ord($1)&0x3F) )
      }exg}sub get_jcode_name {my$src=shift;my$dst;if ($src =~ /^utf-?8$/i){$dst='utf8'}elsif ($src =~ /^euc.*jp(-?(win|ms))?$/i){$dst='euc'}elsif ($src =~ /^(shift.*jis|cp932|windows-31j)$/i){$dst='sjis'}elsif ($src =~ /^iso-2022-jp/){$dst='jis'}$dst}sub xml_escape {my$str=shift;return '' unless defined$str;$str =~ s{
          ([\x00-\x08\x0B\x0C\x0E-\x1F\x7F])
      }{
          sprintf( '&#%d;', ord($1) );
      }gex;$str =~ s/&(?!#(\d+;|x[\dA-Fa-f]+;))/&amp;/g;$str =~ s/</&lt;/g;$str =~ s/>/&gt;/g;$str =~ s/'/&apos;/g;$str =~ s/"/&quot;/g;$str}sub xml_unescape {my$str=shift;my$map={qw(quot " lt < gt > apos ' amp &)};$str =~ s{
          (&(?:\#(\d{1,3})|\#x([0-9a-fA-F]{1,2})|(quot|lt|gt|apos|amp));)
      }{
          $4 ? $map->{$4} : &code_to_ascii( $3 ? hex($3) : $2, $1 );
      }gex;$str}sub xml_deref_octet {my$str=shift;my$map={qw(quot " lt < gt > apos ' amp &)};$str =~ s{
          (&(?:\#(\d{1,7})|\#x([0-9a-fA-F]{1,6})|(quot|lt|gt|apos|amp));)
      }{
          $4 ? $map->{$4} : &code_to_utf8( $3 ? hex($3) : $2, $1 );
      }gex;$str}sub xml_deref_string {my$str=shift;my$map={qw(quot " lt < gt > apos ' amp &)};$str =~ s{
          (&(?:\#(\d{1,7})|\#x([0-9a-fA-F]{1,6})|(quot|lt|gt|apos|amp));)
      }{
          $4 ? $map->{$4} : pack( U => $3 ? hex($3) : $2 );
      }gex;$str}sub code_to_ascii {my$code=shift;if ($code <= 0x007F){return pack(C=>$code)}return shift if scalar @_;sprintf('&#%d;',$code)}sub code_to_utf8 {my$code=shift;if ($code <= 0x007F){return pack(C=>$code)}elsif ($code <= 0x07FF){return pack(C2=>0xC0|($code>>6),0x80|($code&0x3F))}elsif ($code <= 0xFFFF){return pack(C3=>0xE0|($code>>12),0x80|(($code>>6)&0x3F),0x80|($code&0x3F))}elsif ($code <= 0x10FFFF){return pack(C4=>0xF0|($code>>18),0x80|(($code>>12)&0x3F),0x80|(($code>>6)&0x3F),0x80|($code&0x3F))}return shift if scalar @_;sprintf('&#x%04X;',$code)}1;
XML_TREEPP

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
     if (my $fat = $_[0]{$_[1]}) {
       return sub {
         return 0 unless length $fat;
         $fat =~ s/^([^\n]*\n?)//;
         $_ = $1;
         return 1;
       };
     }
     return;
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

